//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * Search journey dashboards by team ids
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Journey dashboards search request
     * @return Success. The list of journey dashboards is returned
     * @deprecated
     */
    getJourneyDashboardByTeamId(x_TENANT_ID: string, body?: DashboardQueryDtoServiceRequest | undefined): Promise<JourneyDashboardDtoIEnumerableServiceResponse>;
    /**
     * Search journey dashboards by journey ids
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Journey dashboards search request
     * @return Success. The list of journey dashboards is returned
     * @deprecated
     */
    getDashboardByJourneyIds(x_TENANT_ID: string, body?: DashboardQueryListDtoServiceRequest | undefined): Promise<JourneyDashboardDtoIEnumerableServiceResponse>;
    /**
     * Get journey instance by id
     * @param journeyInstanceId Journey instance id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param if_None_Match (optional) ETag value from previous API response. Should be used to optimize the short polling. Must be wrapped in double quotes.
     * @return Success. Journey instance is returned
     */
    getJourneyInstanceById(journeyInstanceId: string, x_TENANT_ID: string, if_None_Match?: string | undefined): Promise<JourneyInstanceDtoServiceResponse>;
    /**
     * Get journey instance task by id
     * @param journeyInstanceId Journey instance id
     * @param taskId Task id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. journey instance task is returned
     */
    getTaskById(journeyInstanceId: string, taskId: string, x_TENANT_ID: string): Promise<TaskServiceResponse>;
    /**
     * Get journey instances by entity id
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of journey instances is returned
     */
    getInstancesByEntityId(entityId: string, x_TENANT_ID: string): Promise<JourneyInstanceLightDtoIEnumerableServiceResponse>;
    /**
     * Get linked journeys by main journey id
     * @param journeyInstanceId Parent Journey instance id
     * @param onlyActive If set to `true` return only linked journeys with Active status otherwise it will return everything including Rejected.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param applicationType (optional) Name of the initial triggered service
     * @return Success. Linked journey instances are returned
     */
    getLinkedJourneysById(journeyInstanceId: string, onlyActive: boolean, x_TENANT_ID: string, applicationType?: ApplicationTypeDto | undefined): Promise<JourneyInstanceLightDtoIEnumerableServiceResponse>;
    /**
     * Get lifecycle status of all journey instances by entity id
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journeys lifecycle status is returned
     */
    getLifecycleStatusByEntityId(entityId: string, x_TENANT_ID: string): Promise<LifecycleStatusSummaryServiceResponse>;
    /**
     * Get journey Schedules
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of journey Schedules is returned
     */
    getAllJourneySchedules(x_TENANT_ID: string): Promise<JourneyScheduleDtoIEnumerableServiceResponse>;
    /**
     * Get journey Schedule by id
     * @param journeyScheduleId Journey Schedule id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. An instance of journey Schedule is returned
     */
    getJourneyScheduleById(journeyScheduleId: string, x_TENANT_ID: string): Promise<JourneyScheduleVersionDtoServiceResponse>;
    /**
     * Get journey Schedule by id and version
     * @param journeyScheduleId Journey Schedule id
     * @param versionNumber Journey Schedule version number
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey Schedule is returned
     */
    getJourneyScheduleVersionById(journeyScheduleId: string, versionNumber: number, x_TENANT_ID: string): Promise<JourneyScheduleVersionDtoServiceResponse>;
    /**
     * Search Journey Schedule Date records by the Schedule Date
     * @param scheduleDate The date the journeys are scheduled for launch e.g. 2019-01-31
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of journey schedule Dates is returned
     */
    getScheduleDatesByScheduleDate(scheduleDate: string, x_TENANT_ID: string): Promise<void>;
    /**
     * Get journey Schedule Date by id
     * @param journeyScheduleDateId Journey Schedule id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. An instance of journey Schedule Date is returned
     */
    getJourneyScheduleDateById(journeyScheduleDateId: string, x_TENANT_ID: string): Promise<JourneyScheduleDateDtoServiceResponse>;
    /**
     * Get journey schemas
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of journey schemas is returned
     * @deprecated
     */
    getAllJourneySchemas(x_TENANT_ID: string): Promise<JourneySchemaDtoIEnumerableServiceResponse>;
    /**
     * Get journey schemas (lite)
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of lite journey schemas is returned
     */
    getAllJourneySchemasLite(x_TENANT_ID: string): Promise<JourneySchemaLiteDtoIEnumerableServiceResponse>;
    /**
     * Get journey schema by id
     * @param journeySchemaId Journey schema id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. An instance of journey schema is returned
     */
    getJourneySchemaById(journeySchemaId: string, x_TENANT_ID: string): Promise<JourneySchemaVersionDtoServiceResponse>;
    /**
     * Get journey schema by id and version
     * @param journeySchemaId Journey schema id
     * @param versionNumber Journey schema version number
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey schema is returned
     */
    getJourneySchemaVersionById(journeySchemaId: string, versionNumber: number, x_TENANT_ID: string): Promise<JourneySchemaVersionDtoServiceResponse>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/journeyquery";

    }

    /**
     * Search journey dashboards by team ids
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Journey dashboards search request
     * @return Success. The list of journey dashboards is returned
     * @deprecated
     */
    getJourneyDashboardByTeamId(x_TENANT_ID: string, body?: DashboardQueryDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyDashboardDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-dashboard/dashboard/team";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetJourneyDashboardByTeamId(_response);
        });
    }

    protected processGetJourneyDashboardByTeamId(response: AxiosResponse): Promise<JourneyDashboardDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneyDashboardDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneyDashboardDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyDashboardDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Search journey dashboards by journey ids
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Journey dashboards search request
     * @return Success. The list of journey dashboards is returned
     * @deprecated
     */
    getDashboardByJourneyIds(x_TENANT_ID: string, body?: DashboardQueryListDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyDashboardDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-dashboard/journey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboardByJourneyIds(_response);
        });
    }

    protected processGetDashboardByJourneyIds(response: AxiosResponse): Promise<JourneyDashboardDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneyDashboardDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneyDashboardDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyDashboardDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get journey instance by id
     * @param journeyInstanceId Journey instance id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param if_None_Match (optional) ETag value from previous API response. Should be used to optimize the short polling. Must be wrapped in double quotes.
     * @return Success. Journey instance is returned
     */
    getJourneyInstanceById(journeyInstanceId: string, x_TENANT_ID: string, if_None_Match?: string | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyInstanceDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-instance/{journeyInstanceId}";
        if (journeyInstanceId === undefined || journeyInstanceId === null)
            throw new Error("The parameter 'journeyInstanceId' must be defined.");
        url_ = url_.replace("{journeyInstanceId}", encodeURIComponent("" + journeyInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "If-None-Match": if_None_Match !== undefined && if_None_Match !== null ? "" + if_None_Match : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetJourneyInstanceById(_response);
        });
    }

    protected processGetJourneyInstanceById(response: AxiosResponse): Promise<JourneyInstanceDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneyInstanceDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneyInstanceDtoServiceResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 304) {
            const _responseText = response.data;
            return throwException("The If-None-Match header value is up to date and no journey instance will be returned", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyInstanceDtoServiceResponse>(null as any);
    }

    /**
     * Get journey instance task by id
     * @param journeyInstanceId Journey instance id
     * @param taskId Task id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. journey instance task is returned
     */
    getTaskById(journeyInstanceId: string, taskId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<TaskServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-instance/{journeyInstanceId}/task/{taskId}";
        if (journeyInstanceId === undefined || journeyInstanceId === null)
            throw new Error("The parameter 'journeyInstanceId' must be defined.");
        url_ = url_.replace("{journeyInstanceId}", encodeURIComponent("" + journeyInstanceId));
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTaskById(_response);
        });
    }

    protected processGetTaskById(response: AxiosResponse): Promise<TaskServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TaskServiceResponse.fromJS(resultData200);
            return Promise.resolve<TaskServiceResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TaskServiceResponse>(null as any);
    }

    /**
     * Get journey instances by entity id
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of journey instances is returned
     */
    getInstancesByEntityId(entityId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<JourneyInstanceLightDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-instance/search?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInstancesByEntityId(_response);
        });
    }

    protected processGetInstancesByEntityId(response: AxiosResponse): Promise<JourneyInstanceLightDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneyInstanceLightDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneyInstanceLightDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyInstanceLightDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get linked journeys by main journey id
     * @param journeyInstanceId Parent Journey instance id
     * @param onlyActive If set to `true` return only linked journeys with Active status otherwise it will return everything including Rejected.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param applicationType (optional) Name of the initial triggered service
     * @return Success. Linked journey instances are returned
     */
    getLinkedJourneysById(journeyInstanceId: string, onlyActive: boolean, x_TENANT_ID: string, applicationType?: ApplicationTypeDto | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyInstanceLightDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-instance/{journeyInstanceId}/linked-journeys?";
        if (journeyInstanceId === undefined || journeyInstanceId === null)
            throw new Error("The parameter 'journeyInstanceId' must be defined.");
        url_ = url_.replace("{journeyInstanceId}", encodeURIComponent("" + journeyInstanceId));
        if (onlyActive === undefined || onlyActive === null)
            throw new Error("The parameter 'onlyActive' must be defined and cannot be null.");
        else
            url_ += "onlyActive=" + encodeURIComponent("" + onlyActive) + "&";
        if (applicationType === null)
            throw new Error("The parameter 'applicationType' cannot be null.");
        else if (applicationType !== undefined)
            url_ += "applicationType=" + encodeURIComponent("" + applicationType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLinkedJourneysById(_response);
        });
    }

    protected processGetLinkedJourneysById(response: AxiosResponse): Promise<JourneyInstanceLightDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneyInstanceLightDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneyInstanceLightDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyInstanceLightDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get lifecycle status of all journey instances by entity id
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journeys lifecycle status is returned
     */
    getLifecycleStatusByEntityId(entityId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LifecycleStatusSummaryServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-instance/lifecycle-status/entity/{entityId}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLifecycleStatusByEntityId(_response);
        });
    }

    protected processGetLifecycleStatusByEntityId(response: AxiosResponse): Promise<LifecycleStatusSummaryServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LifecycleStatusSummaryServiceResponse.fromJS(resultData200);
            return Promise.resolve<LifecycleStatusSummaryServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LifecycleStatusSummaryServiceResponse>(null as any);
    }

    /**
     * Get journey Schedules
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of journey Schedules is returned
     */
    getAllJourneySchedules(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<JourneyScheduleDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schedule";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllJourneySchedules(_response);
        });
    }

    protected processGetAllJourneySchedules(response: AxiosResponse): Promise<JourneyScheduleDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneyScheduleDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneyScheduleDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyScheduleDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get journey Schedule by id
     * @param journeyScheduleId Journey Schedule id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. An instance of journey Schedule is returned
     */
    getJourneyScheduleById(journeyScheduleId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<JourneyScheduleVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schedule/{journeyScheduleId}";
        if (journeyScheduleId === undefined || journeyScheduleId === null)
            throw new Error("The parameter 'journeyScheduleId' must be defined.");
        url_ = url_.replace("{journeyScheduleId}", encodeURIComponent("" + journeyScheduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetJourneyScheduleById(_response);
        });
    }

    protected processGetJourneyScheduleById(response: AxiosResponse): Promise<JourneyScheduleVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneyScheduleVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneyScheduleVersionDtoServiceResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyScheduleVersionDtoServiceResponse>(null as any);
    }

    /**
     * Get journey Schedule by id and version
     * @param journeyScheduleId Journey Schedule id
     * @param versionNumber Journey Schedule version number
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey Schedule is returned
     */
    getJourneyScheduleVersionById(journeyScheduleId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<JourneyScheduleVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schedule/{journeyScheduleId}/version/{versionNumber}";
        if (journeyScheduleId === undefined || journeyScheduleId === null)
            throw new Error("The parameter 'journeyScheduleId' must be defined.");
        url_ = url_.replace("{journeyScheduleId}", encodeURIComponent("" + journeyScheduleId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetJourneyScheduleVersionById(_response);
        });
    }

    protected processGetJourneyScheduleVersionById(response: AxiosResponse): Promise<JourneyScheduleVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneyScheduleVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneyScheduleVersionDtoServiceResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyScheduleVersionDtoServiceResponse>(null as any);
    }

    /**
     * Search Journey Schedule Date records by the Schedule Date
     * @param scheduleDate The date the journeys are scheduled for launch e.g. 2019-01-31
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of journey schedule Dates is returned
     */
    getScheduleDatesByScheduleDate(scheduleDate: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schedule-date/search?";
        if (scheduleDate === undefined || scheduleDate === null)
            throw new Error("The parameter 'scheduleDate' must be defined and cannot be null.");
        else
            url_ += "scheduleDate=" + encodeURIComponent("" + scheduleDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetScheduleDatesByScheduleDate(_response);
        });
    }

    protected processGetScheduleDatesByScheduleDate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get journey Schedule Date by id
     * @param journeyScheduleDateId Journey Schedule id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. An instance of journey Schedule Date is returned
     */
    getJourneyScheduleDateById(journeyScheduleDateId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<JourneyScheduleDateDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schedule-date/{journeyScheduleDateId}";
        if (journeyScheduleDateId === undefined || journeyScheduleDateId === null)
            throw new Error("The parameter 'journeyScheduleDateId' must be defined.");
        url_ = url_.replace("{journeyScheduleDateId}", encodeURIComponent("" + journeyScheduleDateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetJourneyScheduleDateById(_response);
        });
    }

    protected processGetJourneyScheduleDateById(response: AxiosResponse): Promise<JourneyScheduleDateDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneyScheduleDateDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneyScheduleDateDtoServiceResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyScheduleDateDtoServiceResponse>(null as any);
    }

    /**
     * Get journey schemas
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of journey schemas is returned
     * @deprecated
     */
    getAllJourneySchemas(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<JourneySchemaDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllJourneySchemas(_response);
        });
    }

    protected processGetAllJourneySchemas(response: AxiosResponse): Promise<JourneySchemaDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneySchemaDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneySchemaDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneySchemaDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get journey schemas (lite)
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of lite journey schemas is returned
     */
    getAllJourneySchemasLite(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<JourneySchemaLiteDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schema/lite";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllJourneySchemasLite(_response);
        });
    }

    protected processGetAllJourneySchemasLite(response: AxiosResponse): Promise<JourneySchemaLiteDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneySchemaLiteDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneySchemaLiteDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneySchemaLiteDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get journey schema by id
     * @param journeySchemaId Journey schema id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. An instance of journey schema is returned
     */
    getJourneySchemaById(journeySchemaId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<JourneySchemaVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schema/{journeySchemaId}";
        if (journeySchemaId === undefined || journeySchemaId === null)
            throw new Error("The parameter 'journeySchemaId' must be defined.");
        url_ = url_.replace("{journeySchemaId}", encodeURIComponent("" + journeySchemaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetJourneySchemaById(_response);
        });
    }

    protected processGetJourneySchemaById(response: AxiosResponse): Promise<JourneySchemaVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneySchemaVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneySchemaVersionDtoServiceResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneySchemaVersionDtoServiceResponse>(null as any);
    }

    /**
     * Get journey schema by id and version
     * @param journeySchemaId Journey schema id
     * @param versionNumber Journey schema version number
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey schema is returned
     */
    getJourneySchemaVersionById(journeySchemaId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<JourneySchemaVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schema/{journeySchemaId}/version/{versionNumber}";
        if (journeySchemaId === undefined || journeySchemaId === null)
            throw new Error("The parameter 'journeySchemaId' must be defined.");
        url_ = url_.replace("{journeySchemaId}", encodeURIComponent("" + journeySchemaId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetJourneySchemaVersionById(_response);
        });
    }

    protected processGetJourneySchemaVersionById(response: AxiosResponse): Promise<JourneySchemaVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JourneySchemaVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<JourneySchemaVersionDtoServiceResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneySchemaVersionDtoServiceResponse>(null as any);
    }
}

/** Response DTO representing associated access layers */
export class AccessLayerDto implements IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;

    constructor(data?: IAccessLayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["geographic"])) {
                this.geographic = [] as any;
                for (let item of _data["geographic"])
                    this.geographic!.push(item);
            }
            if (Array.isArray(_data["businessRelated"])) {
                this.businessRelated = [] as any;
                for (let item of _data["businessRelated"])
                    this.businessRelated!.push(item);
            }
        }
    }

    static fromJS(data: any): AccessLayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.geographic)) {
            data["geographic"] = [];
            for (let item of this.geographic)
                data["geographic"].push(item);
        }
        if (Array.isArray(this.businessRelated)) {
            data["businessRelated"] = [];
            for (let item of this.businessRelated)
                data["businessRelated"].push(item);
        }
        return data;
    }
}

/** Response DTO representing associated access layers */
export interface IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;
}

/** The types of application */
export enum ApplicationTypeDto {
    JourneyLaunchpad = "JourneyLaunchpad",
    RelatedPartyLaunchpad = "RelatedPartyLaunchpad",
    OngoingScreeningJourney = "OngoingScreeningJourney",
    OgsRelatedClientJourneyLaunchpad = "OgsRelatedClientJourneyLaunchpad",
    CompleteClientOffboarding = "CompleteClientOffboarding",
    CompleteClientReOnboarding = "CompleteClientReOnboarding",
}

export class ApproveAction implements IApproveAction {
    comment?: string | undefined;
    decision?: Decision;
    created?: Date;

    constructor(data?: IApproveAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
            this.decision = _data["decision"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApproveAction {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["decision"] = this.decision;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IApproveAction {
    comment?: string | undefined;
    decision?: Decision;
    created?: Date;
}

export class Approver implements IApprover {
    subject?: string | undefined;
    successor?: Approver | undefined;
    action?: ApproveAction | undefined;
    readonly hasProcessedRequest?: boolean;

    constructor(data?: IApprover) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.successor = _data["successor"] ? Approver.fromJS(_data["successor"]) : <any>undefined;
            this.action = _data["action"] ? ApproveAction.fromJS(_data["action"]) : <any>undefined;
            (<any>this).hasProcessedRequest = _data["hasProcessedRequest"];
        }
    }

    static fromJS(data: any): Approver {
        data = typeof data === 'object' ? data : {};
        let result = new Approver();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["successor"] = this.successor ? this.successor.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["hasProcessedRequest"] = this.hasProcessedRequest;
        return data;
    }
}

export interface IApprover {
    subject?: string | undefined;
    successor?: Approver | undefined;
    action?: ApproveAction | undefined;
    hasProcessedRequest?: boolean;
}

export class Task implements ITask {
    id?: string;
    schemaTaskId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    status?: string | undefined;
    order?: number;
    taskType?: string | undefined;
    assignedTo?: string | undefined;
    reassignComment?: string | undefined;
    reopenComment?: string | undefined;
    reopened?: Date | undefined;
    started?: Date;
    completed?: Date;
    cancelled?: Date;
    completedBy?: string | undefined;
    teamId?: string | undefined;
    conditions?: Condition[] | undefined;
    completeAfter?: string[] | undefined;
    isBranchedTask?: boolean;
    preEvaluationStatus?: string | undefined;
    readonly isHidden?: boolean;
    readonly isCompleted?: boolean;
    readonly isSkipped?: boolean;
    readonly isInEvaluation?: boolean;
    readonly isConditional?: boolean;

    protected _discriminator: string;

    constructor(data?: ITask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Task";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.schemaTaskId = _data["schemaTaskId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.order = _data["order"];
            this.taskType = _data["taskType"];
            this.assignedTo = _data["assignedTo"];
            this.reassignComment = _data["reassignComment"];
            this.reopenComment = _data["reopenComment"];
            this.reopened = _data["reopened"] ? new Date(_data["reopened"].toString()) : <any>undefined;
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.cancelled = _data["cancelled"] ? new Date(_data["cancelled"].toString()) : <any>undefined;
            this.completedBy = _data["completedBy"];
            this.teamId = _data["teamId"];
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(Condition.fromJS(item));
            }
            if (Array.isArray(_data["completeAfter"])) {
                this.completeAfter = [] as any;
                for (let item of _data["completeAfter"])
                    this.completeAfter!.push(item);
            }
            this.isBranchedTask = _data["isBranchedTask"];
            this.preEvaluationStatus = _data["preEvaluationStatus"];
            (<any>this).isHidden = _data["isHidden"];
            (<any>this).isCompleted = _data["isCompleted"];
            (<any>this).isSkipped = _data["isSkipped"];
            (<any>this).isInEvaluation = _data["isInEvaluation"];
            (<any>this).isConditional = _data["isConditional"];
        }
    }

    static fromJS(data: any): Task {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "BranchableTask") {
            let result = new BranchableTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DataReviewTask") {
            let result = new DataReviewTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "EntityDataConditionTask") {
            let result = new EntityDataConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ConditionTask") {
            let result = new TaskConditionalGateway();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "IfThenConditionTask") {
            let result = new IfThenConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RiskAssessConditionPolicy") {
            let result = new RiskAssessmentConditionPolicyTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RiskAssessmentConditionTask") {
            let result = new RiskAssessmentConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScreeningMaterialityAssessmentConditionTask") {
            let result = new ScreeningMaterialityAssessmentConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScreeningMaterialityAssessmentConditionTaskOgs") {
            let result = new ScreeningMaterialityAssessmentConditionTaskOgs();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CancelInflightJourneysTask") {
            let result = new CancelInflightJourneysTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CombinedPolicyTask") {
            let result = new CombinedPolicyTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ConflictResolutionTask") {
            let result = new ConflictResolutionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "EntityGroupManagementTask") {
            let result = new EntityGroupManagementTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ExternalDataTask") {
            let result = new ExternalDataTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "FinancialAnalysisTask") {
            let result = new FinancialAnalysisTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "GroupTask") {
            let result = new GroupTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "IndividualIdvTask") {
            let result = new IndividualIdvTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ManualTask") {
            let result = new ManualTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PolicyTask") {
            let result = new PolicyTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ProposedChangesTask") {
            let result = new ProposedChangesTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RelatedPartyJourneyCheckpointTask") {
            let result = new RelatedPartyJourneyCheckpointTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "eSignatureReviewSignedDocumentsTask") {
            let result = new ReviewSignedDocumentsTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScreeningMatchResolutionTask") {
            let result = new ScreeningMatchResolutionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScreeningMatchResolutionTaskOgs") {
            let result = new ScreeningMatchResolutionTaskOgs();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScreeningMaterialityAssessmentTask") {
            let result = new ScreeningMaterialityAssessmentTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScreeningMaterialityAssessmentTaskOgs") {
            let result = new ScreeningMaterialityAssessmentTaskOgs();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SealedTask") {
            let result = new SealedTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ServiceTask") {
            let result = new ServiceTask();
            result.init(data);
            return result;
        }
        let result = new Task();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["id"] = this.id;
        data["schemaTaskId"] = this.schemaTaskId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["status"] = this.status;
        data["order"] = this.order;
        data["taskType"] = this.taskType;
        data["assignedTo"] = this.assignedTo;
        data["reassignComment"] = this.reassignComment;
        data["reopenComment"] = this.reopenComment;
        data["reopened"] = this.reopened ? this.reopened.toISOString() : <any>undefined;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["cancelled"] = this.cancelled ? this.cancelled.toISOString() : <any>undefined;
        data["completedBy"] = this.completedBy;
        data["teamId"] = this.teamId;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        if (Array.isArray(this.completeAfter)) {
            data["completeAfter"] = [];
            for (let item of this.completeAfter)
                data["completeAfter"].push(item);
        }
        data["isBranchedTask"] = this.isBranchedTask;
        data["preEvaluationStatus"] = this.preEvaluationStatus;
        data["isHidden"] = this.isHidden;
        data["isCompleted"] = this.isCompleted;
        data["isSkipped"] = this.isSkipped;
        data["isInEvaluation"] = this.isInEvaluation;
        data["isConditional"] = this.isConditional;
        return data;
    }
}

export interface ITask {
    id?: string;
    schemaTaskId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    status?: string | undefined;
    order?: number;
    taskType?: string | undefined;
    assignedTo?: string | undefined;
    reassignComment?: string | undefined;
    reopenComment?: string | undefined;
    reopened?: Date | undefined;
    started?: Date;
    completed?: Date;
    cancelled?: Date;
    completedBy?: string | undefined;
    teamId?: string | undefined;
    conditions?: Condition[] | undefined;
    completeAfter?: string[] | undefined;
    isBranchedTask?: boolean;
    preEvaluationStatus?: string | undefined;
    isHidden?: boolean;
    isCompleted?: boolean;
    isSkipped?: boolean;
    isInEvaluation?: boolean;
    isConditional?: boolean;
}

export class BranchableTask extends Task implements IBranchableTask {
    branches?: { [key: string]: Task; } | undefined;

    protected _discriminator: string;

    constructor(data?: IBranchableTask) {
        super(data);
        this._discriminator = "BranchableTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["branches"]) {
                this.branches = {} as any;
                for (let key in _data["branches"]) {
                    if (_data["branches"].hasOwnProperty(key))
                        (<any>this.branches)![key] = _data["branches"][key] ? Task.fromJS(_data["branches"][key]) : new Task();
                }
            }
        }
    }

    static fromJS(data: any): BranchableTask {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "DataReviewTask") {
            let result = new DataReviewTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "EntityDataConditionTask") {
            let result = new EntityDataConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ConditionTask") {
            let result = new TaskConditionalGateway();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "IfThenConditionTask") {
            let result = new IfThenConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RiskAssessConditionPolicy") {
            let result = new RiskAssessmentConditionPolicyTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RiskAssessmentConditionTask") {
            let result = new RiskAssessmentConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScreeningMaterialityAssessmentConditionTask") {
            let result = new ScreeningMaterialityAssessmentConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScreeningMaterialityAssessmentConditionTaskOgs") {
            let result = new ScreeningMaterialityAssessmentConditionTaskOgs();
            result.init(data);
            return result;
        }
        let result = new BranchableTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        if (this.branches) {
            data["branches"] = {};
            for (let key in this.branches) {
                if (this.branches.hasOwnProperty(key))
                    (<any>data["branches"])[key] = this.branches[key] ? this.branches[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBranchableTask extends ITask {
    branches?: { [key: string]: Task; } | undefined;
}

export class CancelInflightJourneysTask extends Task implements ICancelInflightJourneysTask {

    constructor(data?: ICancelInflightJourneysTask) {
        super(data);
        this._discriminator = "CancelInflightJourneysTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CancelInflightJourneysTask {
        data = typeof data === 'object' ? data : {};
        let result = new CancelInflightJourneysTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICancelInflightJourneysTask extends ITask {
}

export enum ChannelTypeDto {
    Internal = "Internal",
    External = "External",
    InternalAndExternal = "InternalAndExternal",
}

export class CombinedPolicyTask extends Task implements ICombinedPolicyTask {
    policyTarget?: string | undefined;
    policyRequirementTypes?: string[] | undefined;
    businessCategory?: string[] | undefined;
    documentPersistence?: boolean | undefined;

    constructor(data?: ICombinedPolicyTask) {
        super(data);
        this._discriminator = "CombinedPolicyTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.policyTarget = _data["policyTarget"];
            if (Array.isArray(_data["policyRequirementTypes"])) {
                this.policyRequirementTypes = [] as any;
                for (let item of _data["policyRequirementTypes"])
                    this.policyRequirementTypes!.push(item);
            }
            if (Array.isArray(_data["businessCategory"])) {
                this.businessCategory = [] as any;
                for (let item of _data["businessCategory"])
                    this.businessCategory!.push(item);
            }
            this.documentPersistence = _data["documentPersistence"];
        }
    }

    static fromJS(data: any): CombinedPolicyTask {
        data = typeof data === 'object' ? data : {};
        let result = new CombinedPolicyTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyTarget"] = this.policyTarget;
        if (Array.isArray(this.policyRequirementTypes)) {
            data["policyRequirementTypes"] = [];
            for (let item of this.policyRequirementTypes)
                data["policyRequirementTypes"].push(item);
        }
        if (Array.isArray(this.businessCategory)) {
            data["businessCategory"] = [];
            for (let item of this.businessCategory)
                data["businessCategory"].push(item);
        }
        data["documentPersistence"] = this.documentPersistence;
        super.toJSON(data);
        return data;
    }
}

export interface ICombinedPolicyTask extends ITask {
    policyTarget?: string | undefined;
    policyRequirementTypes?: string[] | undefined;
    businessCategory?: string[] | undefined;
    documentPersistence?: boolean | undefined;
}

export class Condition implements ICondition {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;

    constructor(data?: ICondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Condition {
        data = typeof data === 'object' ? data : {};
        let result = new Condition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICondition {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
}

export class ConditionDefinition implements IConditionDefinition {
    fieldName?: string | undefined;
    value?: string[] | undefined;
    valueType?: string | undefined;
    dataSource?: string | undefined;
    operation?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
    readonly isCondition?: boolean;

    constructor(data?: IConditionDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.valueType = _data["valueType"];
            this.dataSource = _data["dataSource"];
            this.operation = _data["operation"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinition.fromJS(item));
            }
            (<any>this).isCondition = _data["isCondition"];
        }
    }

    static fromJS(data: any): ConditionDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["valueType"] = this.valueType;
        data["dataSource"] = this.dataSource;
        data["operation"] = this.operation;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        data["isCondition"] = this.isCondition;
        return data;
    }
}

export interface IConditionDefinition {
    fieldName?: string | undefined;
    value?: string[] | undefined;
    valueType?: string | undefined;
    dataSource?: string | undefined;
    operation?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
    isCondition?: boolean;
}

/** Represents condition */
export class ConditionDefinitionDto implements IConditionDefinitionDto {
    /** Name of the field to evaluate */
    fieldName?: string | undefined;
    /** List of values */
    value?: string[] | undefined;
    /** Type of the value */
    valueType?: string | undefined;
    /** Data source from which field is retrieved. If empty then Entity Data properties will be used. */
    dataSource?: string | undefined;
    /** Logical operation to be performed to match the values */
    operation?: string | undefined;
    /** Logical operation to be performed on the operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;

    constructor(data?: IConditionDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.valueType = _data["valueType"];
            this.dataSource = _data["dataSource"];
            this.operation = _data["operation"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["valueType"] = this.valueType;
        data["dataSource"] = this.dataSource;
        data["operation"] = this.operation;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents condition */
export interface IConditionDefinitionDto {
    /** Name of the field to evaluate */
    fieldName?: string | undefined;
    /** List of values */
    value?: string[] | undefined;
    /** Type of the value */
    valueType?: string | undefined;
    /** Data source from which field is retrieved. If empty then Entity Data properties will be used. */
    dataSource?: string | undefined;
    /** Logical operation to be performed to match the values */
    operation?: string | undefined;
    /** Logical operation to be performed on the operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;
}

/** Represents condition root */
export class ConditionDto implements IConditionDto {
    /** The ID of the condition */
    id?: string;
    /** The name of the condition */
    name?: string | undefined;
    /** The description of the condition */
    description?: string | undefined;
    /** Logical operation on the Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDto.Operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;

    constructor(data?: IConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents condition root */
export interface IConditionDto {
    /** The ID of the condition */
    id?: string;
    /** The name of the condition */
    name?: string | undefined;
    /** The description of the condition */
    description?: string | undefined;
    /** Logical operation on the Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDto.Operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;
}

export class ConflictResolutionTask extends Task implements IConflictResolutionTask {

    constructor(data?: IConflictResolutionTask) {
        super(data);
        this._discriminator = "ConflictResolutionTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ConflictResolutionTask {
        data = typeof data === 'object' ? data : {};
        let result = new ConflictResolutionTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IConflictResolutionTask extends ITask {
}

/** Request DTO representing dashboard query data */
export class DashboardQueryDto implements IDashboardQueryDto {
    /** Ids of the teams the user is member of */
    teamIds?: string[] | undefined;

    constructor(data?: IDashboardQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["teamIds"])) {
                this.teamIds = [] as any;
                for (let item of _data["teamIds"])
                    this.teamIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DashboardQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.teamIds)) {
            data["teamIds"] = [];
            for (let item of this.teamIds)
                data["teamIds"].push(item);
        }
        return data;
    }
}

/** Request DTO representing dashboard query data */
export interface IDashboardQueryDto {
    /** Ids of the teams the user is member of */
    teamIds?: string[] | undefined;
}

/** Service request data */
export class DashboardQueryDtoServiceRequest implements IDashboardQueryDtoServiceRequest {
    /** The service request DTO */
    data?: DashboardQueryDto | undefined;

    constructor(data?: IDashboardQueryDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DashboardQueryDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DashboardQueryDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardQueryDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IDashboardQueryDtoServiceRequest {
    /** The service request DTO */
    data?: DashboardQueryDto | undefined;
}

/** Request DTO representing dashboard query data */
export class DashboardQueryListDto implements IDashboardQueryListDto {
    /** List of journey ids */
    list?: string[] | undefined;

    constructor(data?: IDashboardQueryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(item);
            }
        }
    }

    static fromJS(data: any): DashboardQueryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardQueryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item);
        }
        return data;
    }
}

/** Request DTO representing dashboard query data */
export interface IDashboardQueryListDto {
    /** List of journey ids */
    list?: string[] | undefined;
}

/** Service request data */
export class DashboardQueryListDtoServiceRequest implements IDashboardQueryListDtoServiceRequest {
    /** The service request DTO */
    data?: DashboardQueryListDto | undefined;

    constructor(data?: IDashboardQueryListDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DashboardQueryListDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DashboardQueryListDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardQueryListDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IDashboardQueryListDtoServiceRequest {
    /** The service request DTO */
    data?: DashboardQueryListDto | undefined;
}

export class DataReviewTask extends BranchableTask implements IDataReviewTask {
    approvalMethod?: string | undefined;
    outcome?: string | undefined;
    message?: string | undefined;
    policyTarget?: string | undefined;
    policyCategory?: string | undefined;
    policyRequirementType?: string | undefined;
    businessCategory?: string[] | undefined;
    businessSubCategory?: string | undefined;
    includeReviseOutcome?: boolean;
    includeRiskSection?: boolean;

    constructor(data?: IDataReviewTask) {
        super(data);
        this._discriminator = "DataReviewTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.approvalMethod = _data["approvalMethod"];
            this.outcome = _data["outcome"];
            this.message = _data["message"];
            this.policyTarget = _data["policyTarget"];
            this.policyCategory = _data["policyCategory"];
            this.policyRequirementType = _data["policyRequirementType"];
            if (Array.isArray(_data["businessCategory"])) {
                this.businessCategory = [] as any;
                for (let item of _data["businessCategory"])
                    this.businessCategory!.push(item);
            }
            this.businessSubCategory = _data["businessSubCategory"];
            this.includeReviseOutcome = _data["includeReviseOutcome"];
            this.includeRiskSection = _data["includeRiskSection"];
        }
    }

    static fromJS(data: any): DataReviewTask {
        data = typeof data === 'object' ? data : {};
        let result = new DataReviewTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalMethod"] = this.approvalMethod;
        data["outcome"] = this.outcome;
        data["message"] = this.message;
        data["policyTarget"] = this.policyTarget;
        data["policyCategory"] = this.policyCategory;
        data["policyRequirementType"] = this.policyRequirementType;
        if (Array.isArray(this.businessCategory)) {
            data["businessCategory"] = [];
            for (let item of this.businessCategory)
                data["businessCategory"].push(item);
        }
        data["businessSubCategory"] = this.businessSubCategory;
        data["includeReviseOutcome"] = this.includeReviseOutcome;
        data["includeRiskSection"] = this.includeRiskSection;
        super.toJSON(data);
        return data;
    }
}

export interface IDataReviewTask extends IBranchableTask {
    approvalMethod?: string | undefined;
    outcome?: string | undefined;
    message?: string | undefined;
    policyTarget?: string | undefined;
    policyCategory?: string | undefined;
    policyRequirementType?: string | undefined;
    businessCategory?: string[] | undefined;
    businessSubCategory?: string | undefined;
    includeReviseOutcome?: boolean;
    includeRiskSection?: boolean;
}

export enum Decision {
    Approve = "Approve",
    Reject = "Reject",
}

export class TaskConditionalGateway extends BranchableTask implements ITaskConditionalGateway {
    outcome?: string | undefined;

    protected _discriminator: string;

    constructor(data?: ITaskConditionalGateway) {
        super(data);
        this._discriminator = "TaskConditionalGateway";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.outcome = _data["outcome"];
        }
    }

    static fromJS(data: any): TaskConditionalGateway {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "EntityDataConditionTask") {
            let result = new EntityDataConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "IfThenConditionTask") {
            let result = new IfThenConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RiskAssessConditionPolicy") {
            let result = new RiskAssessmentConditionPolicyTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RiskAssessmentConditionTask") {
            let result = new RiskAssessmentConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScreeningMaterialityAssessmentConditionTask") {
            let result = new ScreeningMaterialityAssessmentConditionTask();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScreeningMaterialityAssessmentConditionTaskOgs") {
            let result = new ScreeningMaterialityAssessmentConditionTaskOgs();
            result.init(data);
            return result;
        }
        let result = new TaskConditionalGateway();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["outcome"] = this.outcome;
        super.toJSON(data);
        return data;
    }
}

export interface ITaskConditionalGateway extends IBranchableTask {
    outcome?: string | undefined;
}

export class EntityDataConditionTask extends TaskConditionalGateway implements IEntityDataConditionTask {
    property?: string | undefined;
    value?: string | undefined;

    constructor(data?: IEntityDataConditionTask) {
        super(data);
        this._discriminator = "EntityDataConditionTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.property = _data["property"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EntityDataConditionTask {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDataConditionTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["property"] = this.property;
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IEntityDataConditionTask extends ITaskConditionalGateway {
    property?: string | undefined;
    value?: string | undefined;
}

export class EntityGroupManagementTask extends Task implements IEntityGroupManagementTask {

    constructor(data?: IEntityGroupManagementTask) {
        super(data);
        this._discriminator = "EntityGroupManagementTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): EntityGroupManagementTask {
        data = typeof data === 'object' ? data : {};
        let result = new EntityGroupManagementTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IEntityGroupManagementTask extends ITask {
}

export class ExternalDataTask extends Task implements IExternalDataTask {

    constructor(data?: IExternalDataTask) {
        super(data);
        this._discriminator = "ExternalDataTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ExternalDataTask {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalDataTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IExternalDataTask extends ITask {
}

export class FinancialAnalysisTask extends Task implements IFinancialAnalysisTask {
    businessCategory?: string[] | undefined;

    constructor(data?: IFinancialAnalysisTask) {
        super(data);
        this._discriminator = "FinancialAnalysisTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["businessCategory"])) {
                this.businessCategory = [] as any;
                for (let item of _data["businessCategory"])
                    this.businessCategory!.push(item);
            }
        }
    }

    static fromJS(data: any): FinancialAnalysisTask {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialAnalysisTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.businessCategory)) {
            data["businessCategory"] = [];
            for (let item of this.businessCategory)
                data["businessCategory"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFinancialAnalysisTask extends ITask {
    businessCategory?: string[] | undefined;
}

export class GroupTask extends Task implements IGroupTask {
    subTasks?: Task[] | undefined;

    constructor(data?: IGroupTask) {
        super(data);
        this._discriminator = "GroupTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["subTasks"])) {
                this.subTasks = [] as any;
                for (let item of _data["subTasks"])
                    this.subTasks!.push(Task.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupTask {
        data = typeof data === 'object' ? data : {};
        let result = new GroupTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subTasks)) {
            data["subTasks"] = [];
            for (let item of this.subTasks)
                data["subTasks"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IGroupTask extends ITask {
    subTasks?: Task[] | undefined;
}

export class IfThenConditionTask extends TaskConditionalGateway implements IIfThenConditionTask {
    property?: string | undefined;

    constructor(data?: IIfThenConditionTask) {
        super(data);
        this._discriminator = "IfThenConditionTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.property = _data["property"];
        }
    }

    static fromJS(data: any): IfThenConditionTask {
        data = typeof data === 'object' ? data : {};
        let result = new IfThenConditionTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["property"] = this.property;
        super.toJSON(data);
        return data;
    }
}

export interface IIfThenConditionTask extends ITaskConditionalGateway {
    property?: string | undefined;
}

export class IndividualIdvTask extends Task implements IIndividualIdvTask {

    constructor(data?: IIndividualIdvTask) {
        super(data);
        this._discriminator = "IndividualIdvTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): IndividualIdvTask {
        data = typeof data === 'object' ? data : {};
        let result = new IndividualIdvTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIndividualIdvTask extends ITask {
}

/** Response DTO representing journey dashboard data */
export class JourneyDashboardDto implements IJourneyDashboardDto {
    /** The UiD of the journey instance */
    id?: string;
    /** The UiD of the entity that journey instance belongs to */
    entityId?: string;
    /** Journey instance start date */
    started?: Date | undefined;
    /** Journey instance type */
    type?: string | undefined;
    /** Journey instance status */
    status?: string | undefined;
    /** Journey instance percent of progress */
    progress?: number;
    /** The UiD of the current task that is in progress */
    currentTaskId?: string;
    /** Name of the current task in progress */
    currentTask?: string | undefined;
    /** The UiD of the team that the current task is assigned to */
    teamId?: string | undefined;
    /** List of tasks that are in the journey */
    tasks?: TaskDashboard[] | undefined;
    /** The UiD of the journey schema */
    journeySchemaId?: string;
    /** Channel type describing whether journeys will be initiated by internal teams (Internal) or external customers through Portal (External) */
    channelType?: ChannelTypeDto;

    constructor(data?: IJourneyDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityId = _data["entityId"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.status = _data["status"];
            this.progress = _data["progress"];
            this.currentTaskId = _data["currentTaskId"];
            this.currentTask = _data["currentTask"];
            this.teamId = _data["teamId"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(TaskDashboard.fromJS(item));
            }
            this.journeySchemaId = _data["journeySchemaId"];
            this.channelType = _data["channelType"];
        }
    }

    static fromJS(data: any): JourneyDashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyDashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityId"] = this.entityId;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["status"] = this.status;
        data["progress"] = this.progress;
        data["currentTaskId"] = this.currentTaskId;
        data["currentTask"] = this.currentTask;
        data["teamId"] = this.teamId;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        data["journeySchemaId"] = this.journeySchemaId;
        data["channelType"] = this.channelType;
        return data;
    }
}

/** Response DTO representing journey dashboard data */
export interface IJourneyDashboardDto {
    /** The UiD of the journey instance */
    id?: string;
    /** The UiD of the entity that journey instance belongs to */
    entityId?: string;
    /** Journey instance start date */
    started?: Date | undefined;
    /** Journey instance type */
    type?: string | undefined;
    /** Journey instance status */
    status?: string | undefined;
    /** Journey instance percent of progress */
    progress?: number;
    /** The UiD of the current task that is in progress */
    currentTaskId?: string;
    /** Name of the current task in progress */
    currentTask?: string | undefined;
    /** The UiD of the team that the current task is assigned to */
    teamId?: string | undefined;
    /** List of tasks that are in the journey */
    tasks?: TaskDashboard[] | undefined;
    /** The UiD of the journey schema */
    journeySchemaId?: string;
    /** Channel type describing whether journeys will be initiated by internal teams (Internal) or external customers through Portal (External) */
    channelType?: ChannelTypeDto;
}

/** Service response data */
export class JourneyDashboardDtoIEnumerableServiceResponse implements IJourneyDashboardDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: JourneyDashboardDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneyDashboardDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(JourneyDashboardDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyDashboardDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyDashboardDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneyDashboardDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: JourneyDashboardDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing all journey instance data */
export class JourneyInstanceDto implements IJourneyInstanceDto {
    /** The UiD of the journey instance */
    id?: string;
    /** The UiD of the entity draft */
    entityDraftId?: string;
    /** The UiD of the entity that journey instance belongs to */
    entityId?: string;
    /** The UiD of the journey schema */
    journeySchemaId?: string;
    /** The VersionNumber of the journey schema */
    journeySchemaVersionNumber?: number | undefined;
    /** The UiD of the grouped journeys */
    applicationId?: string | undefined;
    /** Status of the journey from specific application */
    applicationStatus?: string | undefined;
    /** Type of the service that triggered the application */
    applicationType?: ApplicationTypeDto | undefined;
    /** Journey instance start date */
    started?: Date | undefined;
    /** Journey instance cancelled date */
    cancelled?: Date | undefined;
    /** Journey instance last updated by */
    lastUpdatedBy?: string | undefined;
    /** Journey instance completed date */
    completed?: Date | undefined;
    /** Journey schema short identifier */
    identifier?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** Journey instance status */
    status?: string | undefined;
    /** Journey instance name */
    name?: string | undefined;
    /** Journey instance access layers determining the access to the entity */
    accessLayers?: AccessLayerDto | undefined;
    /** Flag indicating if current user has required access layers to access this journey instance */
    hasRequiredAccessLayers?: boolean;
    /** Collection of jurisdictions this journey operates on */
    jurisdictions?: string[] | undefined;
    /** List of journey instance stages */
    stages?: JourneyInstanceStageDto[] | undefined;
    /** Represents progress of current stage */
    stats?: JourneyStatsDto | undefined;
    /** If true, next conditional stages/processes/tasks of the Journey Instance will be evaluated each time data source is updated */
    preEvaluationEnabled?: boolean;
    /** Version of JourneyInstance */
    version?: number;

    constructor(data?: IJourneyInstanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityDraftId = _data["entityDraftId"];
            this.entityId = _data["entityId"];
            this.journeySchemaId = _data["journeySchemaId"];
            this.journeySchemaVersionNumber = _data["journeySchemaVersionNumber"];
            this.applicationId = _data["applicationId"];
            this.applicationStatus = _data["applicationStatus"];
            this.applicationType = _data["applicationType"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.cancelled = _data["cancelled"] ? new Date(_data["cancelled"].toString()) : <any>undefined;
            this.lastUpdatedBy = _data["lastUpdatedBy"];
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.identifier = _data["identifier"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.hasRequiredAccessLayers = _data["hasRequiredAccessLayers"];
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(item);
            }
            if (Array.isArray(_data["stages"])) {
                this.stages = [] as any;
                for (let item of _data["stages"])
                    this.stages!.push(JourneyInstanceStageDto.fromJS(item));
            }
            this.stats = _data["stats"] ? JourneyStatsDto.fromJS(_data["stats"]) : <any>undefined;
            this.preEvaluationEnabled = _data["preEvaluationEnabled"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): JourneyInstanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyInstanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityDraftId"] = this.entityDraftId;
        data["entityId"] = this.entityId;
        data["journeySchemaId"] = this.journeySchemaId;
        data["journeySchemaVersionNumber"] = this.journeySchemaVersionNumber;
        data["applicationId"] = this.applicationId;
        data["applicationStatus"] = this.applicationStatus;
        data["applicationType"] = this.applicationType;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["cancelled"] = this.cancelled ? this.cancelled.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["identifier"] = this.identifier;
        data["type"] = this.type;
        data["status"] = this.status;
        data["name"] = this.name;
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["hasRequiredAccessLayers"] = this.hasRequiredAccessLayers;
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item);
        }
        if (Array.isArray(this.stages)) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        data["stats"] = this.stats ? this.stats.toJSON() : <any>undefined;
        data["preEvaluationEnabled"] = this.preEvaluationEnabled;
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing all journey instance data */
export interface IJourneyInstanceDto {
    /** The UiD of the journey instance */
    id?: string;
    /** The UiD of the entity draft */
    entityDraftId?: string;
    /** The UiD of the entity that journey instance belongs to */
    entityId?: string;
    /** The UiD of the journey schema */
    journeySchemaId?: string;
    /** The VersionNumber of the journey schema */
    journeySchemaVersionNumber?: number | undefined;
    /** The UiD of the grouped journeys */
    applicationId?: string | undefined;
    /** Status of the journey from specific application */
    applicationStatus?: string | undefined;
    /** Type of the service that triggered the application */
    applicationType?: ApplicationTypeDto | undefined;
    /** Journey instance start date */
    started?: Date | undefined;
    /** Journey instance cancelled date */
    cancelled?: Date | undefined;
    /** Journey instance last updated by */
    lastUpdatedBy?: string | undefined;
    /** Journey instance completed date */
    completed?: Date | undefined;
    /** Journey schema short identifier */
    identifier?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** Journey instance status */
    status?: string | undefined;
    /** Journey instance name */
    name?: string | undefined;
    /** Journey instance access layers determining the access to the entity */
    accessLayers?: AccessLayerDto | undefined;
    /** Flag indicating if current user has required access layers to access this journey instance */
    hasRequiredAccessLayers?: boolean;
    /** Collection of jurisdictions this journey operates on */
    jurisdictions?: string[] | undefined;
    /** List of journey instance stages */
    stages?: JourneyInstanceStageDto[] | undefined;
    /** Represents progress of current stage */
    stats?: JourneyStatsDto | undefined;
    /** If true, next conditional stages/processes/tasks of the Journey Instance will be evaluated each time data source is updated */
    preEvaluationEnabled?: boolean;
    /** Version of JourneyInstance */
    version?: number;
}

/** Service response data */
export class JourneyInstanceDtoServiceResponse implements IJourneyInstanceDtoServiceResponse {
    /** The service response DTO */
    data?: JourneyInstanceDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneyInstanceDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneyInstanceDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyInstanceDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyInstanceDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneyInstanceDtoServiceResponse {
    /** The service response DTO */
    data?: JourneyInstanceDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing journey instance data without Stages object */
export class JourneyInstanceLightDto implements IJourneyInstanceLightDto {
    /** The UiD of the journey instance */
    id?: string;
    /** The UiD of the entity draft */
    entityDraftId?: string;
    /** The UiD of the entity that journey instance belongs to */
    entityId?: string;
    /** The UiD of the journey schema */
    journeySchemaId?: string;
    /** The VersionNumber of the journey schema */
    journeySchemaVersionNumber?: number | undefined;
    /** The UiD of the grouped journeys */
    applicationId?: string | undefined;
    /** Status of the journey from specific application */
    applicationStatus?: string | undefined;
    /** Type of the service that triggered the application */
    applicationType?: ApplicationTypeDto | undefined;
    /** Journey instance start date */
    started?: Date | undefined;
    /** Journey instance cancelled date */
    cancelled?: Date | undefined;
    /** Journey instance last updated by */
    lastUpdatedBy?: string | undefined;
    /** Journey instance completed date */
    completed?: Date | undefined;
    /** Journey schema short identifier */
    identifier?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** Journey instance status */
    status?: string | undefined;
    /** Journey instance name */
    name?: string | undefined;
    /** Journey instance access layers determining the access to the entity */
    accessLayers?: AccessLayerDto | undefined;
    /** Flag indicating if current user has required access layers to access this journey instance */
    hasRequiredAccessLayers?: boolean;
    /** Collection of jurisdictions this journey operates on */
    jurisdictions?: string[] | undefined;

    constructor(data?: IJourneyInstanceLightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityDraftId = _data["entityDraftId"];
            this.entityId = _data["entityId"];
            this.journeySchemaId = _data["journeySchemaId"];
            this.journeySchemaVersionNumber = _data["journeySchemaVersionNumber"];
            this.applicationId = _data["applicationId"];
            this.applicationStatus = _data["applicationStatus"];
            this.applicationType = _data["applicationType"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.cancelled = _data["cancelled"] ? new Date(_data["cancelled"].toString()) : <any>undefined;
            this.lastUpdatedBy = _data["lastUpdatedBy"];
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.identifier = _data["identifier"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.hasRequiredAccessLayers = _data["hasRequiredAccessLayers"];
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(item);
            }
        }
    }

    static fromJS(data: any): JourneyInstanceLightDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyInstanceLightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityDraftId"] = this.entityDraftId;
        data["entityId"] = this.entityId;
        data["journeySchemaId"] = this.journeySchemaId;
        data["journeySchemaVersionNumber"] = this.journeySchemaVersionNumber;
        data["applicationId"] = this.applicationId;
        data["applicationStatus"] = this.applicationStatus;
        data["applicationType"] = this.applicationType;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["cancelled"] = this.cancelled ? this.cancelled.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["identifier"] = this.identifier;
        data["type"] = this.type;
        data["status"] = this.status;
        data["name"] = this.name;
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["hasRequiredAccessLayers"] = this.hasRequiredAccessLayers;
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item);
        }
        return data;
    }
}

/** Response DTO representing journey instance data without Stages object */
export interface IJourneyInstanceLightDto {
    /** The UiD of the journey instance */
    id?: string;
    /** The UiD of the entity draft */
    entityDraftId?: string;
    /** The UiD of the entity that journey instance belongs to */
    entityId?: string;
    /** The UiD of the journey schema */
    journeySchemaId?: string;
    /** The VersionNumber of the journey schema */
    journeySchemaVersionNumber?: number | undefined;
    /** The UiD of the grouped journeys */
    applicationId?: string | undefined;
    /** Status of the journey from specific application */
    applicationStatus?: string | undefined;
    /** Type of the service that triggered the application */
    applicationType?: ApplicationTypeDto | undefined;
    /** Journey instance start date */
    started?: Date | undefined;
    /** Journey instance cancelled date */
    cancelled?: Date | undefined;
    /** Journey instance last updated by */
    lastUpdatedBy?: string | undefined;
    /** Journey instance completed date */
    completed?: Date | undefined;
    /** Journey schema short identifier */
    identifier?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** Journey instance status */
    status?: string | undefined;
    /** Journey instance name */
    name?: string | undefined;
    /** Journey instance access layers determining the access to the entity */
    accessLayers?: AccessLayerDto | undefined;
    /** Flag indicating if current user has required access layers to access this journey instance */
    hasRequiredAccessLayers?: boolean;
    /** Collection of jurisdictions this journey operates on */
    jurisdictions?: string[] | undefined;
}

/** Service response data */
export class JourneyInstanceLightDtoIEnumerableServiceResponse implements IJourneyInstanceLightDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: JourneyInstanceLightDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneyInstanceLightDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(JourneyInstanceLightDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyInstanceLightDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyInstanceLightDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneyInstanceLightDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: JourneyInstanceLightDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Journey Instance Process metadata */
export class JourneyInstanceProcessDto implements IJourneyInstanceProcessDto {
    /** The UiD of the process */
    id?: string;
    /** The UiD of the journey schema process */
    schemaProcessId?: string | undefined;
    /** Process name */
    name?: string | undefined;
    /** Process description */
    description?: string | undefined;
    /** Process status */
    status?: string | undefined;
    /** Process order */
    order?: number;
    /** Determines the order of completing tasks. Defaults to Sequential.
One of Sequential, AnyOrder */
    tasksCompletionOrder?: string | undefined;
    /** List of process tasks */
    tasks?: Task[] | undefined;
    /** Process started date */
    started?: Date | undefined;
    /** Process completed date */
    completed?: Date | undefined;
    /** List of conditions required to trigger process */
    conditions?: Condition[] | undefined;
    /** True if the process contains conditions, false otherwise */
    isConditional?: boolean;
    /** True if the process is completed, false otherwise */
    isCompleted?: boolean;
    /** True if the process is skipped, false otherwise */
    isSkipped?: boolean;
    /** Status of the early process evaluation, applicable only for conditional process
One of Not Run, Satisfied, Not Satisfied */
    preEvaluationStatus?: string | undefined;
    /** If true, the the process and its contents should not be rendered */
    isHidden?: boolean;

    constructor(data?: IJourneyInstanceProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.schemaProcessId = _data["schemaProcessId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.order = _data["order"];
            this.tasksCompletionOrder = _data["tasksCompletionOrder"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(Task.fromJS(item));
            }
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(Condition.fromJS(item));
            }
            this.isConditional = _data["isConditional"];
            this.isCompleted = _data["isCompleted"];
            this.isSkipped = _data["isSkipped"];
            this.preEvaluationStatus = _data["preEvaluationStatus"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): JourneyInstanceProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyInstanceProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["schemaProcessId"] = this.schemaProcessId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["status"] = this.status;
        data["order"] = this.order;
        data["tasksCompletionOrder"] = this.tasksCompletionOrder;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["isConditional"] = this.isConditional;
        data["isCompleted"] = this.isCompleted;
        data["isSkipped"] = this.isSkipped;
        data["preEvaluationStatus"] = this.preEvaluationStatus;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

/** Journey Instance Process metadata */
export interface IJourneyInstanceProcessDto {
    /** The UiD of the process */
    id?: string;
    /** The UiD of the journey schema process */
    schemaProcessId?: string | undefined;
    /** Process name */
    name?: string | undefined;
    /** Process description */
    description?: string | undefined;
    /** Process status */
    status?: string | undefined;
    /** Process order */
    order?: number;
    /** Determines the order of completing tasks. Defaults to Sequential.
One of Sequential, AnyOrder */
    tasksCompletionOrder?: string | undefined;
    /** List of process tasks */
    tasks?: Task[] | undefined;
    /** Process started date */
    started?: Date | undefined;
    /** Process completed date */
    completed?: Date | undefined;
    /** List of conditions required to trigger process */
    conditions?: Condition[] | undefined;
    /** True if the process contains conditions, false otherwise */
    isConditional?: boolean;
    /** True if the process is completed, false otherwise */
    isCompleted?: boolean;
    /** True if the process is skipped, false otherwise */
    isSkipped?: boolean;
    /** Status of the early process evaluation, applicable only for conditional process
One of Not Run, Satisfied, Not Satisfied */
    preEvaluationStatus?: string | undefined;
    /** If true, the the process and its contents should not be rendered */
    isHidden?: boolean;
}

/** Journey Instance Stage metadata */
export class JourneyInstanceStageDto implements IJourneyInstanceStageDto {
    /** The UiD of the stage */
    id?: string;
    /** The UiD of the journey schema stage */
    schemaStageId?: string | undefined;
    /** Stage name */
    name?: string | undefined;
    /** Stage description */
    description?: string | undefined;
    /** Stage status */
    status?: string | undefined;
    /** Stage order */
    order?: number;
    /** Determines the order of completing processes. Defaults to Sequential.
One of Sequential, AnyOrder */
    processesCompletionOrder?: string | undefined;
    /** Optional list of previous stages when this stage should start */
    inParallelWithStages?: string[] | undefined;
    /** Stage started date */
    started?: Date | undefined;
    /** Stage completed date */
    completed?: Date | undefined;
    /** List of stage processes */
    processes?: JourneyInstanceProcessDto[] | undefined;
    /** List of conditions required to trigger stage */
    conditions?: Condition[] | undefined;
    /** True if the stage contains conditions, false otherwise */
    isConditional?: boolean;
    /** Status of the early stage evaluation, applicable only for conditional stages
One of Not Run, Satisfied, Not Satisfied */
    preEvaluationStatus?: string | undefined;
    /** If true, the the stage and its contents should not be rendered */
    isHidden?: boolean;
    /** Represents progress of current stage */
    stats?: JourneyStatsDto | undefined;

    constructor(data?: IJourneyInstanceStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.schemaStageId = _data["schemaStageId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.order = _data["order"];
            this.processesCompletionOrder = _data["processesCompletionOrder"];
            if (Array.isArray(_data["inParallelWithStages"])) {
                this.inParallelWithStages = [] as any;
                for (let item of _data["inParallelWithStages"])
                    this.inParallelWithStages!.push(item);
            }
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            if (Array.isArray(_data["processes"])) {
                this.processes = [] as any;
                for (let item of _data["processes"])
                    this.processes!.push(JourneyInstanceProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(Condition.fromJS(item));
            }
            this.isConditional = _data["isConditional"];
            this.preEvaluationStatus = _data["preEvaluationStatus"];
            this.isHidden = _data["isHidden"];
            this.stats = _data["stats"] ? JourneyStatsDto.fromJS(_data["stats"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JourneyInstanceStageDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyInstanceStageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["schemaStageId"] = this.schemaStageId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["status"] = this.status;
        data["order"] = this.order;
        data["processesCompletionOrder"] = this.processesCompletionOrder;
        if (Array.isArray(this.inParallelWithStages)) {
            data["inParallelWithStages"] = [];
            for (let item of this.inParallelWithStages)
                data["inParallelWithStages"].push(item);
        }
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        if (Array.isArray(this.processes)) {
            data["processes"] = [];
            for (let item of this.processes)
                data["processes"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["isConditional"] = this.isConditional;
        data["preEvaluationStatus"] = this.preEvaluationStatus;
        data["isHidden"] = this.isHidden;
        data["stats"] = this.stats ? this.stats.toJSON() : <any>undefined;
        return data;
    }
}

/** Journey Instance Stage metadata */
export interface IJourneyInstanceStageDto {
    /** The UiD of the stage */
    id?: string;
    /** The UiD of the journey schema stage */
    schemaStageId?: string | undefined;
    /** Stage name */
    name?: string | undefined;
    /** Stage description */
    description?: string | undefined;
    /** Stage status */
    status?: string | undefined;
    /** Stage order */
    order?: number;
    /** Determines the order of completing processes. Defaults to Sequential.
One of Sequential, AnyOrder */
    processesCompletionOrder?: string | undefined;
    /** Optional list of previous stages when this stage should start */
    inParallelWithStages?: string[] | undefined;
    /** Stage started date */
    started?: Date | undefined;
    /** Stage completed date */
    completed?: Date | undefined;
    /** List of stage processes */
    processes?: JourneyInstanceProcessDto[] | undefined;
    /** List of conditions required to trigger stage */
    conditions?: Condition[] | undefined;
    /** True if the stage contains conditions, false otherwise */
    isConditional?: boolean;
    /** Status of the early stage evaluation, applicable only for conditional stages
One of Not Run, Satisfied, Not Satisfied */
    preEvaluationStatus?: string | undefined;
    /** If true, the the stage and its contents should not be rendered */
    isHidden?: boolean;
    /** Represents progress of current stage */
    stats?: JourneyStatsDto | undefined;
}

export class JourneyLifecycleStatus implements IJourneyLifecycleStatus {
    journeyId?: string;
    status?: string | undefined;
    name?: string | undefined;
    jurisdictions?: string[] | undefined;

    constructor(data?: IJourneyLifecycleStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeyId = _data["journeyId"];
            this.status = _data["status"];
            this.name = _data["name"];
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(item);
            }
        }
    }

    static fromJS(data: any): JourneyLifecycleStatus {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyLifecycleStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeyId"] = this.journeyId;
        data["status"] = this.status;
        data["name"] = this.name;
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item);
        }
        return data;
    }
}

export interface IJourneyLifecycleStatus {
    journeyId?: string;
    status?: string | undefined;
    name?: string | undefined;
    jurisdictions?: string[] | undefined;
}

/** Response DTO representing journey Schedule date data */
export class JourneyScheduleDateDto implements IJourneyScheduleDateDto {
    /** The UiD of the journey Schedule Date */
    id?: string;
    /** The UiD of the Entity the journey is scheduled for */
    entityId?: string;
    /** The UiD of the Journey Schedule this date is being set for */
    journeyScheduleId?: string;
    /** The date the journey will be launched for */
    scheduledDate?: Date;
    /** To track if this was manually created by a user */
    userCreated?: boolean;
    /** The reason for which the journey is scheduled */
    comment?: string | undefined;
    /** The type of Journey that will be launched */
    type?: string | undefined;

    constructor(data?: IJourneyScheduleDateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityId = _data["entityId"];
            this.journeyScheduleId = _data["journeyScheduleId"];
            this.scheduledDate = _data["scheduledDate"] ? new Date(_data["scheduledDate"].toString()) : <any>undefined;
            this.userCreated = _data["userCreated"];
            this.comment = _data["comment"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): JourneyScheduleDateDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleDateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityId"] = this.entityId;
        data["journeyScheduleId"] = this.journeyScheduleId;
        data["scheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : <any>undefined;
        data["userCreated"] = this.userCreated;
        data["comment"] = this.comment;
        data["type"] = this.type;
        return data;
    }
}

/** Response DTO representing journey Schedule date data */
export interface IJourneyScheduleDateDto {
    /** The UiD of the journey Schedule Date */
    id?: string;
    /** The UiD of the Entity the journey is scheduled for */
    entityId?: string;
    /** The UiD of the Journey Schedule this date is being set for */
    journeyScheduleId?: string;
    /** The date the journey will be launched for */
    scheduledDate?: Date;
    /** To track if this was manually created by a user */
    userCreated?: boolean;
    /** The reason for which the journey is scheduled */
    comment?: string | undefined;
    /** The type of Journey that will be launched */
    type?: string | undefined;
}

/** Service response data */
export class JourneyScheduleDateDtoServiceResponse implements IJourneyScheduleDateDtoServiceResponse {
    /** The service response DTO */
    data?: JourneyScheduleDateDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneyScheduleDateDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneyScheduleDateDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyScheduleDateDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleDateDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneyScheduleDateDtoServiceResponse {
    /** The service response DTO */
    data?: JourneyScheduleDateDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing journey Schedule data */
export class JourneyScheduleDto implements IJourneyScheduleDto {
    /** The UiD of the journey Schedule */
    id?: string;
    /** Versions associated to the journey Schedule */
    versions?: JourneyScheduleVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;

    constructor(data?: IJourneyScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(JourneyScheduleVersionDto.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): JourneyScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing journey Schedule data */
export interface IJourneyScheduleDto {
    /** The UiD of the journey Schedule */
    id?: string;
    /** Versions associated to the journey Schedule */
    versions?: JourneyScheduleVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
}

/** Service response data */
export class JourneyScheduleDtoIEnumerableServiceResponse implements IJourneyScheduleDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: JourneyScheduleDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneyScheduleDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(JourneyScheduleDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyScheduleDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneyScheduleDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: JourneyScheduleDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing journey Schedule version data */
export class JourneyScheduleVersionDto implements IJourneyScheduleVersionDto {
    /** The UiD of the journey Schedule version */
    id?: string;
    /** The UiD of the journey Schedule that the version belongs to */
    journeyScheduleId?: string;
    /** Display name of journey Schedule */
    name?: string | undefined;
    /** Journey Schedule type */
    type?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Conditions under which the Schedule can be used */
    conditions?: ConditionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number | undefined;

    constructor(data?: IJourneyScheduleVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.journeyScheduleId = _data["journeyScheduleId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): JourneyScheduleVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["journeyScheduleId"] = this.journeyScheduleId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing journey Schedule version data */
export interface IJourneyScheduleVersionDto {
    /** The UiD of the journey Schedule version */
    id?: string;
    /** The UiD of the journey Schedule that the version belongs to */
    journeyScheduleId?: string;
    /** Display name of journey Schedule */
    name?: string | undefined;
    /** Journey Schedule type */
    type?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Conditions under which the Schedule can be used */
    conditions?: ConditionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number | undefined;
}

/** Service response data */
export class JourneyScheduleVersionDtoServiceResponse implements IJourneyScheduleVersionDtoServiceResponse {
    /** The service response DTO */
    data?: JourneyScheduleVersionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneyScheduleVersionDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneyScheduleVersionDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyScheduleVersionDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleVersionDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneyScheduleVersionDtoServiceResponse {
    /** The service response DTO */
    data?: JourneyScheduleVersionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing journey schema data */
export class JourneySchemaDto implements IJourneySchemaDto {
    /** The UiD of the journey schema */
    id?: string;
    /** Versions associated to the journey schema */
    versions?: JourneySchemaVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;

    constructor(data?: IJourneySchemaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(JourneySchemaVersionDto.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): JourneySchemaDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing journey schema data */
export interface IJourneySchemaDto {
    /** The UiD of the journey schema */
    id?: string;
    /** Versions associated to the journey schema */
    versions?: JourneySchemaVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
}

/** Service response data */
export class JourneySchemaDtoIEnumerableServiceResponse implements IJourneySchemaDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: JourneySchemaDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneySchemaDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(JourneySchemaDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneySchemaDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneySchemaDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: JourneySchemaDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class JourneySchemaLiteDto implements IJourneySchemaLiteDto {
    /** The UiD of the journey schema */
    id?: string;
    /** Versions associated to the journey schema */
    versions?: JourneySchemaLiteVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;

    constructor(data?: IJourneySchemaLiteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(JourneySchemaLiteVersionDto.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): JourneySchemaLiteDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaLiteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

export interface IJourneySchemaLiteDto {
    /** The UiD of the journey schema */
    id?: string;
    /** Versions associated to the journey schema */
    versions?: JourneySchemaLiteVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
}

/** Service response data */
export class JourneySchemaLiteDtoIEnumerableServiceResponse implements IJourneySchemaLiteDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: JourneySchemaLiteDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneySchemaLiteDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(JourneySchemaLiteDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneySchemaLiteDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaLiteDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneySchemaLiteDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: JourneySchemaLiteDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class JourneySchemaLiteVersionDto implements IJourneySchemaLiteVersionDto {
    /** The UiD of the journey schema version */
    id?: string;
    /** The UiD of the journey schema that the version belongs to */
    journeySchemaId?: string;
    /** Display name of journey schema */
    name?: string | undefined;
    /** Short identifier of journey schema */
    identifier?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** Channel type describing whether journeys will be initiated by internal teams (Internal) or external customers through Portal (External)
<br /><ul><li>Internal journeys are ones that are initiated and processed by internal teams, e.g., RMs, KYC Analysts, Compliance.</li><li>External journeys are ones that are initiated and processed by the end customer via the portal.</li><li>This let's the portal quickly know which journey to pick up and which to ignore.</li></ul> */
    channelType?: ChannelTypeDto;
    /** Version number for given Aggregate (concurrency check) */
    version?: number | undefined;

    constructor(data?: IJourneySchemaLiteVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.journeySchemaId = _data["journeySchemaId"];
            this.name = _data["name"];
            this.identifier = _data["identifier"];
            this.type = _data["type"];
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.channelType = _data["channelType"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): JourneySchemaLiteVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaLiteVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["journeySchemaId"] = this.journeySchemaId;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["type"] = this.type;
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["channelType"] = this.channelType;
        data["version"] = this.version;
        return data;
    }
}

export interface IJourneySchemaLiteVersionDto {
    /** The UiD of the journey schema version */
    id?: string;
    /** The UiD of the journey schema that the version belongs to */
    journeySchemaId?: string;
    /** Display name of journey schema */
    name?: string | undefined;
    /** Short identifier of journey schema */
    identifier?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** Channel type describing whether journeys will be initiated by internal teams (Internal) or external customers through Portal (External)
<br /><ul><li>Internal journeys are ones that are initiated and processed by internal teams, e.g., RMs, KYC Analysts, Compliance.</li><li>External journeys are ones that are initiated and processed by the end customer via the portal.</li><li>This let's the portal quickly know which journey to pick up and which to ignore.</li></ul> */
    channelType?: ChannelTypeDto;
    /** Version number for given Aggregate (concurrency check) */
    version?: number | undefined;
}

/** Journey Schema Process metadata */
export class JourneySchemaProcessDto implements IJourneySchemaProcessDto {
    /** The UiD of the process */
    id?: string;
    /** Process name */
    name?: string | undefined;
    /** Process description */
    description?: string | undefined;
    /** Process order */
    order?: number;
    /** Determines the order of completing tasks. Defaults to Sequential.
One of Sequential, AnyOrder */
    tasksCompletionOrder?: string | undefined;
    /** List of process tasks */
    tasks?: Task[] | undefined;
    /** List of conditions required to trigger process */
    conditions?: Condition[] | undefined;
    /** True if the process contains conditions, false otherwise */
    isConditional?: boolean;

    constructor(data?: IJourneySchemaProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.order = _data["order"];
            this.tasksCompletionOrder = _data["tasksCompletionOrder"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(Task.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(Condition.fromJS(item));
            }
            this.isConditional = _data["isConditional"];
        }
    }

    static fromJS(data: any): JourneySchemaProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["order"] = this.order;
        data["tasksCompletionOrder"] = this.tasksCompletionOrder;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["isConditional"] = this.isConditional;
        return data;
    }
}

/** Journey Schema Process metadata */
export interface IJourneySchemaProcessDto {
    /** The UiD of the process */
    id?: string;
    /** Process name */
    name?: string | undefined;
    /** Process description */
    description?: string | undefined;
    /** Process order */
    order?: number;
    /** Determines the order of completing tasks. Defaults to Sequential.
One of Sequential, AnyOrder */
    tasksCompletionOrder?: string | undefined;
    /** List of process tasks */
    tasks?: Task[] | undefined;
    /** List of conditions required to trigger process */
    conditions?: Condition[] | undefined;
    /** True if the process contains conditions, false otherwise */
    isConditional?: boolean;
}

/** Journey Schema Stage metadata */
export class JourneySchemaStageDto implements IJourneySchemaStageDto {
    /** The UiD of the stage */
    id?: string;
    /** Stage name */
    name?: string | undefined;
    /** Stage description */
    description?: string | undefined;
    /** Stage order */
    order?: number;
    /** Determines the order of completing processes. Defaults to Sequential.
One of Sequential, AnyOrder */
    processesCompletionOrder?: string | undefined;
    /** Optional list of previous stages when this stage should start */
    inParallelWithStages?: string[] | undefined;
    /** List of stage processes */
    processes?: JourneySchemaProcessDto[] | undefined;
    /** List of conditions required to trigger stage */
    conditions?: Condition[] | undefined;
    /** True if the stage contains conditions, false otherwise */
    isConditional?: boolean;

    constructor(data?: IJourneySchemaStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.order = _data["order"];
            this.processesCompletionOrder = _data["processesCompletionOrder"];
            if (Array.isArray(_data["inParallelWithStages"])) {
                this.inParallelWithStages = [] as any;
                for (let item of _data["inParallelWithStages"])
                    this.inParallelWithStages!.push(item);
            }
            if (Array.isArray(_data["processes"])) {
                this.processes = [] as any;
                for (let item of _data["processes"])
                    this.processes!.push(JourneySchemaProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(Condition.fromJS(item));
            }
            this.isConditional = _data["isConditional"];
        }
    }

    static fromJS(data: any): JourneySchemaStageDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaStageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["order"] = this.order;
        data["processesCompletionOrder"] = this.processesCompletionOrder;
        if (Array.isArray(this.inParallelWithStages)) {
            data["inParallelWithStages"] = [];
            for (let item of this.inParallelWithStages)
                data["inParallelWithStages"].push(item);
        }
        if (Array.isArray(this.processes)) {
            data["processes"] = [];
            for (let item of this.processes)
                data["processes"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["isConditional"] = this.isConditional;
        return data;
    }
}

/** Journey Schema Stage metadata */
export interface IJourneySchemaStageDto {
    /** The UiD of the stage */
    id?: string;
    /** Stage name */
    name?: string | undefined;
    /** Stage description */
    description?: string | undefined;
    /** Stage order */
    order?: number;
    /** Determines the order of completing processes. Defaults to Sequential.
One of Sequential, AnyOrder */
    processesCompletionOrder?: string | undefined;
    /** Optional list of previous stages when this stage should start */
    inParallelWithStages?: string[] | undefined;
    /** List of stage processes */
    processes?: JourneySchemaProcessDto[] | undefined;
    /** List of conditions required to trigger stage */
    conditions?: Condition[] | undefined;
    /** True if the stage contains conditions, false otherwise */
    isConditional?: boolean;
}

/** Response DTO representing journey schema version data */
export class JourneySchemaVersionDto implements IJourneySchemaVersionDto {
    /** The UiD of the journey schema version */
    id?: string;
    /** The UiD of the journey schema that the version belongs to */
    journeySchemaId?: string;
    /** Display name of journey schema */
    name?: string | undefined;
    /** Short identifier of journey schema */
    identifier?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** Channel type describing whether journeys will be initiated by internal teams (Internal) or external customers through Portal (External)
<br /><ul><li>Internal journeys are ones that are initiated and processed by internal teams, e.g., RMs, KYC Analysts, Compliance.</li><li>External journeys are ones that are initiated and processed by the end customer via the portal.</li><li>This let's the portal quickly know which journey to pick up and which to ignore.</li></ul> */
    channelType?: ChannelTypeDto;
    /** Version number for given Aggregate (concurrency check) */
    version?: number | undefined;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Collection of stages defining journey */
    stages?: JourneySchemaStageDto[] | undefined;
    /** Conditions under which the schema can be used */
    conditions?: ConditionDto[] | undefined;
    /** External Conditions under which the schema can be used */
    externalConditions?: ConditionDto[] | undefined;
    /** If true, next conditional stages/processes/tasks of the Journey Instance will be evaluated each time data source is updated */
    preEvaluationEnabled?: boolean;

    constructor(data?: IJourneySchemaVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.journeySchemaId = _data["journeySchemaId"];
            this.name = _data["name"];
            this.identifier = _data["identifier"];
            this.type = _data["type"];
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.channelType = _data["channelType"];
            this.version = _data["version"];
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            if (Array.isArray(_data["stages"])) {
                this.stages = [] as any;
                for (let item of _data["stages"])
                    this.stages!.push(JourneySchemaStageDto.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            if (Array.isArray(_data["externalConditions"])) {
                this.externalConditions = [] as any;
                for (let item of _data["externalConditions"])
                    this.externalConditions!.push(ConditionDto.fromJS(item));
            }
            this.preEvaluationEnabled = _data["preEvaluationEnabled"];
        }
    }

    static fromJS(data: any): JourneySchemaVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["journeySchemaId"] = this.journeySchemaId;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["type"] = this.type;
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["channelType"] = this.channelType;
        data["version"] = this.version;
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        if (Array.isArray(this.stages)) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        if (Array.isArray(this.externalConditions)) {
            data["externalConditions"] = [];
            for (let item of this.externalConditions)
                data["externalConditions"].push(item.toJSON());
        }
        data["preEvaluationEnabled"] = this.preEvaluationEnabled;
        return data;
    }
}

/** Response DTO representing journey schema version data */
export interface IJourneySchemaVersionDto {
    /** The UiD of the journey schema version */
    id?: string;
    /** The UiD of the journey schema that the version belongs to */
    journeySchemaId?: string;
    /** Display name of journey schema */
    name?: string | undefined;
    /** Short identifier of journey schema */
    identifier?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** Channel type describing whether journeys will be initiated by internal teams (Internal) or external customers through Portal (External)
<br /><ul><li>Internal journeys are ones that are initiated and processed by internal teams, e.g., RMs, KYC Analysts, Compliance.</li><li>External journeys are ones that are initiated and processed by the end customer via the portal.</li><li>This let's the portal quickly know which journey to pick up and which to ignore.</li></ul> */
    channelType?: ChannelTypeDto;
    /** Version number for given Aggregate (concurrency check) */
    version?: number | undefined;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Collection of stages defining journey */
    stages?: JourneySchemaStageDto[] | undefined;
    /** Conditions under which the schema can be used */
    conditions?: ConditionDto[] | undefined;
    /** External Conditions under which the schema can be used */
    externalConditions?: ConditionDto[] | undefined;
    /** If true, next conditional stages/processes/tasks of the Journey Instance will be evaluated each time data source is updated */
    preEvaluationEnabled?: boolean;
}

/** Service response data */
export class JourneySchemaVersionDtoServiceResponse implements IJourneySchemaVersionDtoServiceResponse {
    /** The service response DTO */
    data?: JourneySchemaVersionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneySchemaVersionDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneySchemaVersionDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneySchemaVersionDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaVersionDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneySchemaVersionDtoServiceResponse {
    /** The service response DTO */
    data?: JourneySchemaVersionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Represents the progress of journey instance or stage */
export class JourneyStatsDto implements IJourneyStatsDto {
    /** Number of completed tasks */
    completed?: number;
    /** Number of total (visible) tasks */
    total?: number;
    /** Progress in percents */
    progress?: number;

    constructor(data?: IJourneyStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.completed = _data["completed"];
            this.total = _data["total"];
            this.progress = _data["progress"];
        }
    }

    static fromJS(data: any): JourneyStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["completed"] = this.completed;
        data["total"] = this.total;
        data["progress"] = this.progress;
        return data;
    }
}

/** Represents the progress of journey instance or stage */
export interface IJourneyStatsDto {
    /** Number of completed tasks */
    completed?: number;
    /** Number of total (visible) tasks */
    total?: number;
    /** Progress in percents */
    progress?: number;
}

export enum LifecycleStatus {
    Unknown = "Unknown",
    OnboardingInProgress = "OnboardingInProgress",
    MaintenanceInProgress = "MaintenanceInProgress",
    Compliant = "Compliant",
    ReviewInProgress = "ReviewInProgress",
    PendingOffboarding = "PendingOffboarding",
    ClientOffboarded = "ClientOffboarded",
}

export class LifecycleStatusSummary implements ILifecycleStatusSummary {
    status?: LifecycleStatus;
    factors?: { [key: string]: LifecycleStatusSummaryFactor; } | undefined;

    constructor(data?: ILifecycleStatusSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            if (_data["factors"]) {
                this.factors = {} as any;
                for (let key in _data["factors"]) {
                    if (_data["factors"].hasOwnProperty(key))
                        (<any>this.factors)![key] = _data["factors"][key] ? LifecycleStatusSummaryFactor.fromJS(_data["factors"][key]) : new LifecycleStatusSummaryFactor();
                }
            }
        }
    }

    static fromJS(data: any): LifecycleStatusSummary {
        data = typeof data === 'object' ? data : {};
        let result = new LifecycleStatusSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        if (this.factors) {
            data["factors"] = {};
            for (let key in this.factors) {
                if (this.factors.hasOwnProperty(key))
                    (<any>data["factors"])[key] = this.factors[key] ? this.factors[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface ILifecycleStatusSummary {
    status?: LifecycleStatus;
    factors?: { [key: string]: LifecycleStatusSummaryFactor; } | undefined;
}

export class LifecycleStatusSummaryFactor implements ILifecycleStatusSummaryFactor {
    status?: LifecycleSummaryFactorStatus;
    journeys?: JourneyLifecycleStatus[] | undefined;

    constructor(data?: ILifecycleStatusSummaryFactor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            if (Array.isArray(_data["journeys"])) {
                this.journeys = [] as any;
                for (let item of _data["journeys"])
                    this.journeys!.push(JourneyLifecycleStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LifecycleStatusSummaryFactor {
        data = typeof data === 'object' ? data : {};
        let result = new LifecycleStatusSummaryFactor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        if (Array.isArray(this.journeys)) {
            data["journeys"] = [];
            for (let item of this.journeys)
                data["journeys"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILifecycleStatusSummaryFactor {
    status?: LifecycleSummaryFactorStatus;
    journeys?: JourneyLifecycleStatus[] | undefined;
}

/** Service response data */
export class LifecycleStatusSummaryServiceResponse implements ILifecycleStatusSummaryServiceResponse {
    /** The service response DTO */
    data?: LifecycleStatusSummary | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ILifecycleStatusSummaryServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LifecycleStatusSummary.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LifecycleStatusSummaryServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LifecycleStatusSummaryServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface ILifecycleStatusSummaryServiceResponse {
    /** The service response DTO */
    data?: LifecycleStatusSummary | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export enum LifecycleSummaryFactorStatus {
    Done = "Done",
    InProgress = "InProgress",
    Cancelled = "Cancelled",
}

export class ManualTask extends Task implements IManualTask {

    constructor(data?: IManualTask) {
        super(data);
        this._discriminator = "ManualTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ManualTask {
        data = typeof data === 'object' ? data : {};
        let result = new ManualTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IManualTask extends ITask {
}

/** Service response data */
export class ObjectServiceResponse implements IObjectServiceResponse {
    /** The service response DTO */
    data?: any | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IObjectServiceResponse {
    /** The service response DTO */
    data?: any | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class ObjectServiceResult implements IObjectServiceResult {
    content?: string | undefined;
    contentType?: string | undefined;
    statusCode?: number | undefined;

    constructor(data?: IObjectServiceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.contentType = _data["contentType"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): ObjectServiceResult {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentType"] = this.contentType;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IObjectServiceResult {
    content?: string | undefined;
    contentType?: string | undefined;
    statusCode?: number | undefined;
}

export class PolicyTask extends Task implements IPolicyTask {
    policyTarget?: string | undefined;
    policyCategory?: string | undefined;
    policyRequirementType?: string | undefined;
    businessCategory?: string[] | undefined;
    businessSubCategory?: string | undefined;
    documentPersistence?: boolean | undefined;
    relatedPartyCategory?: string[] | undefined;

    constructor(data?: IPolicyTask) {
        super(data);
        this._discriminator = "PolicyTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.policyTarget = _data["policyTarget"];
            this.policyCategory = _data["policyCategory"];
            this.policyRequirementType = _data["policyRequirementType"];
            if (Array.isArray(_data["businessCategory"])) {
                this.businessCategory = [] as any;
                for (let item of _data["businessCategory"])
                    this.businessCategory!.push(item);
            }
            this.businessSubCategory = _data["businessSubCategory"];
            this.documentPersistence = _data["documentPersistence"];
            if (Array.isArray(_data["relatedPartyCategory"])) {
                this.relatedPartyCategory = [] as any;
                for (let item of _data["relatedPartyCategory"])
                    this.relatedPartyCategory!.push(item);
            }
        }
    }

    static fromJS(data: any): PolicyTask {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyTarget"] = this.policyTarget;
        data["policyCategory"] = this.policyCategory;
        data["policyRequirementType"] = this.policyRequirementType;
        if (Array.isArray(this.businessCategory)) {
            data["businessCategory"] = [];
            for (let item of this.businessCategory)
                data["businessCategory"].push(item);
        }
        data["businessSubCategory"] = this.businessSubCategory;
        data["documentPersistence"] = this.documentPersistence;
        if (Array.isArray(this.relatedPartyCategory)) {
            data["relatedPartyCategory"] = [];
            for (let item of this.relatedPartyCategory)
                data["relatedPartyCategory"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPolicyTask extends ITask {
    policyTarget?: string | undefined;
    policyCategory?: string | undefined;
    policyRequirementType?: string | undefined;
    businessCategory?: string[] | undefined;
    businessSubCategory?: string | undefined;
    documentPersistence?: boolean | undefined;
    relatedPartyCategory?: string[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class ProposedChangesTask extends Task implements IProposedChangesTask {

    constructor(data?: IProposedChangesTask) {
        super(data);
        this._discriminator = "ProposedChangesTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ProposedChangesTask {
        data = typeof data === 'object' ? data : {};
        let result = new ProposedChangesTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProposedChangesTask extends ITask {
}

export class RelatedPartyJourneyCheckpointTask extends Task implements IRelatedPartyJourneyCheckpointTask {

    constructor(data?: IRelatedPartyJourneyCheckpointTask) {
        super(data);
        this._discriminator = "RelatedPartyJourneyCheckpointTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): RelatedPartyJourneyCheckpointTask {
        data = typeof data === 'object' ? data : {};
        let result = new RelatedPartyJourneyCheckpointTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRelatedPartyJourneyCheckpointTask extends ITask {
}

export class ReviewSignedDocumentsTask extends Task implements IReviewSignedDocumentsTask {
    policyTarget?: string | undefined;
    policyCategory?: string | undefined;
    policyRequirementType?: string | undefined;
    businessCategory?: string[] | undefined;
    businessSubCategory?: string | undefined;
    documentPersistence?: boolean | undefined;
    relatedPartyCategory?: string[] | undefined;

    constructor(data?: IReviewSignedDocumentsTask) {
        super(data);
        this._discriminator = "eSignatureReviewSignedDocumentsTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.policyTarget = _data["policyTarget"];
            this.policyCategory = _data["policyCategory"];
            this.policyRequirementType = _data["policyRequirementType"];
            if (Array.isArray(_data["businessCategory"])) {
                this.businessCategory = [] as any;
                for (let item of _data["businessCategory"])
                    this.businessCategory!.push(item);
            }
            this.businessSubCategory = _data["businessSubCategory"];
            this.documentPersistence = _data["documentPersistence"];
            if (Array.isArray(_data["relatedPartyCategory"])) {
                this.relatedPartyCategory = [] as any;
                for (let item of _data["relatedPartyCategory"])
                    this.relatedPartyCategory!.push(item);
            }
        }
    }

    static fromJS(data: any): ReviewSignedDocumentsTask {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewSignedDocumentsTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyTarget"] = this.policyTarget;
        data["policyCategory"] = this.policyCategory;
        data["policyRequirementType"] = this.policyRequirementType;
        if (Array.isArray(this.businessCategory)) {
            data["businessCategory"] = [];
            for (let item of this.businessCategory)
                data["businessCategory"].push(item);
        }
        data["businessSubCategory"] = this.businessSubCategory;
        data["documentPersistence"] = this.documentPersistence;
        if (Array.isArray(this.relatedPartyCategory)) {
            data["relatedPartyCategory"] = [];
            for (let item of this.relatedPartyCategory)
                data["relatedPartyCategory"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IReviewSignedDocumentsTask extends ITask {
    policyTarget?: string | undefined;
    policyCategory?: string | undefined;
    policyRequirementType?: string | undefined;
    businessCategory?: string[] | undefined;
    businessSubCategory?: string | undefined;
    documentPersistence?: boolean | undefined;
    relatedPartyCategory?: string[] | undefined;
}

export class RiskAssessmentConditionPolicyTask extends TaskConditionalGateway implements IRiskAssessmentConditionPolicyTask {
    riskConditionField?: string | undefined;
    riskLevels?: string[] | undefined;

    constructor(data?: IRiskAssessmentConditionPolicyTask) {
        super(data);
        this._discriminator = "RiskAssessConditionPolicy";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.riskConditionField = _data["riskConditionField"];
            if (Array.isArray(_data["riskLevels"])) {
                this.riskLevels = [] as any;
                for (let item of _data["riskLevels"])
                    this.riskLevels!.push(item);
            }
        }
    }

    static fromJS(data: any): RiskAssessmentConditionPolicyTask {
        data = typeof data === 'object' ? data : {};
        let result = new RiskAssessmentConditionPolicyTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["riskConditionField"] = this.riskConditionField;
        if (Array.isArray(this.riskLevels)) {
            data["riskLevels"] = [];
            for (let item of this.riskLevels)
                data["riskLevels"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IRiskAssessmentConditionPolicyTask extends ITaskConditionalGateway {
    riskConditionField?: string | undefined;
    riskLevels?: string[] | undefined;
}

export class RiskAssessmentConditionTask extends TaskConditionalGateway implements IRiskAssessmentConditionTask {
    riskLevels?: string[] | undefined;

    constructor(data?: IRiskAssessmentConditionTask) {
        super(data);
        this._discriminator = "RiskAssessmentConditionTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["riskLevels"])) {
                this.riskLevels = [] as any;
                for (let item of _data["riskLevels"])
                    this.riskLevels!.push(item);
            }
        }
    }

    static fromJS(data: any): RiskAssessmentConditionTask {
        data = typeof data === 'object' ? data : {};
        let result = new RiskAssessmentConditionTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.riskLevels)) {
            data["riskLevels"] = [];
            for (let item of this.riskLevels)
                data["riskLevels"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IRiskAssessmentConditionTask extends ITaskConditionalGateway {
    riskLevels?: string[] | undefined;
}

export class ScreeningMatchResolutionTask extends Task implements IScreeningMatchResolutionTask {

    constructor(data?: IScreeningMatchResolutionTask) {
        super(data);
        this._discriminator = "ScreeningMatchResolutionTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ScreeningMatchResolutionTask {
        data = typeof data === 'object' ? data : {};
        let result = new ScreeningMatchResolutionTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IScreeningMatchResolutionTask extends ITask {
}

export class ScreeningMatchResolutionTaskOgs extends Task implements IScreeningMatchResolutionTaskOgs {

    constructor(data?: IScreeningMatchResolutionTaskOgs) {
        super(data);
        this._discriminator = "ScreeningMatchResolutionTaskOgs";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ScreeningMatchResolutionTaskOgs {
        data = typeof data === 'object' ? data : {};
        let result = new ScreeningMatchResolutionTaskOgs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IScreeningMatchResolutionTaskOgs extends ITask {
}

export class ScreeningMaterialityAssessmentConditionTask extends TaskConditionalGateway implements IScreeningMaterialityAssessmentConditionTask {

    constructor(data?: IScreeningMaterialityAssessmentConditionTask) {
        super(data);
        this._discriminator = "ScreeningMaterialityAssessmentConditionTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ScreeningMaterialityAssessmentConditionTask {
        data = typeof data === 'object' ? data : {};
        let result = new ScreeningMaterialityAssessmentConditionTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IScreeningMaterialityAssessmentConditionTask extends ITaskConditionalGateway {
}

export class ScreeningMaterialityAssessmentConditionTaskOgs extends TaskConditionalGateway implements IScreeningMaterialityAssessmentConditionTaskOgs {

    constructor(data?: IScreeningMaterialityAssessmentConditionTaskOgs) {
        super(data);
        this._discriminator = "ScreeningMaterialityAssessmentConditionTaskOgs";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ScreeningMaterialityAssessmentConditionTaskOgs {
        data = typeof data === 'object' ? data : {};
        let result = new ScreeningMaterialityAssessmentConditionTaskOgs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IScreeningMaterialityAssessmentConditionTaskOgs extends ITaskConditionalGateway {
}

export class ScreeningMaterialityAssessmentTask extends Task implements IScreeningMaterialityAssessmentTask {
    policyTarget?: string | undefined;
    policyCategory?: string | undefined;
    policyRequirementType?: string | undefined;
    businessCategory?: string[] | undefined;
    businessSubCategory?: string | undefined;

    constructor(data?: IScreeningMaterialityAssessmentTask) {
        super(data);
        this._discriminator = "ScreeningMaterialityAssessmentTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.policyTarget = _data["policyTarget"];
            this.policyCategory = _data["policyCategory"];
            this.policyRequirementType = _data["policyRequirementType"];
            if (Array.isArray(_data["businessCategory"])) {
                this.businessCategory = [] as any;
                for (let item of _data["businessCategory"])
                    this.businessCategory!.push(item);
            }
            this.businessSubCategory = _data["businessSubCategory"];
        }
    }

    static fromJS(data: any): ScreeningMaterialityAssessmentTask {
        data = typeof data === 'object' ? data : {};
        let result = new ScreeningMaterialityAssessmentTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyTarget"] = this.policyTarget;
        data["policyCategory"] = this.policyCategory;
        data["policyRequirementType"] = this.policyRequirementType;
        if (Array.isArray(this.businessCategory)) {
            data["businessCategory"] = [];
            for (let item of this.businessCategory)
                data["businessCategory"].push(item);
        }
        data["businessSubCategory"] = this.businessSubCategory;
        super.toJSON(data);
        return data;
    }
}

export interface IScreeningMaterialityAssessmentTask extends ITask {
    policyTarget?: string | undefined;
    policyCategory?: string | undefined;
    policyRequirementType?: string | undefined;
    businessCategory?: string[] | undefined;
    businessSubCategory?: string | undefined;
}

export class ScreeningMaterialityAssessmentTaskOgs extends Task implements IScreeningMaterialityAssessmentTaskOgs {
    policyTarget?: string | undefined;
    policyCategory?: string | undefined;
    policyRequirementType?: string | undefined;
    businessCategory?: string[] | undefined;
    businessSubCategory?: string | undefined;

    constructor(data?: IScreeningMaterialityAssessmentTaskOgs) {
        super(data);
        this._discriminator = "ScreeningMaterialityAssessmentTaskOgs";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.policyTarget = _data["policyTarget"];
            this.policyCategory = _data["policyCategory"];
            this.policyRequirementType = _data["policyRequirementType"];
            if (Array.isArray(_data["businessCategory"])) {
                this.businessCategory = [] as any;
                for (let item of _data["businessCategory"])
                    this.businessCategory!.push(item);
            }
            this.businessSubCategory = _data["businessSubCategory"];
        }
    }

    static fromJS(data: any): ScreeningMaterialityAssessmentTaskOgs {
        data = typeof data === 'object' ? data : {};
        let result = new ScreeningMaterialityAssessmentTaskOgs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyTarget"] = this.policyTarget;
        data["policyCategory"] = this.policyCategory;
        data["policyRequirementType"] = this.policyRequirementType;
        if (Array.isArray(this.businessCategory)) {
            data["businessCategory"] = [];
            for (let item of this.businessCategory)
                data["businessCategory"].push(item);
        }
        data["businessSubCategory"] = this.businessSubCategory;
        super.toJSON(data);
        return data;
    }
}

export interface IScreeningMaterialityAssessmentTaskOgs extends ITask {
    policyTarget?: string | undefined;
    policyCategory?: string | undefined;
    policyRequirementType?: string | undefined;
    businessCategory?: string[] | undefined;
    businessSubCategory?: string | undefined;
}

export class SealedTask extends Task implements ISealedTask {

    constructor(data?: ISealedTask) {
        super(data);
        this._discriminator = "SealedTask";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SealedTask {
        data = typeof data === 'object' ? data : {};
        let result = new SealedTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISealedTask extends ITask {
}

/** The message associated to the service response */
export class ServiceResponseMessage implements IServiceResponseMessage {
    /** The message */
    message?: string | undefined;
    /** Type of the message
One of Info, Warning, Error, Forbidden */
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

/** The message associated to the service response */
export interface IServiceResponseMessage {
    /** The message */
    message?: string | undefined;
    /** Type of the message
One of Info, Warning, Error, Forbidden */
    type?: string | undefined;
}

export class ServiceTask extends Task implements IServiceTask {
    serviceName?: string | undefined;
    properties?: { [key: string]: string; } | undefined;

    constructor(data?: IServiceTask) {
        super(data);
        this._discriminator = "ServiceTask";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.serviceName = _data["serviceName"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ServiceTask {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IServiceTask extends ITask {
    serviceName?: string | undefined;
    properties?: { [key: string]: string; } | undefined;
}

export class Signee implements ISignee {
    subject?: string | undefined;
    successor?: Approver | undefined;
    action?: ApproveAction | undefined;
    readonly hasProcessedRequest?: boolean;

    constructor(data?: ISignee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.successor = _data["successor"] ? Approver.fromJS(_data["successor"]) : <any>undefined;
            this.action = _data["action"] ? ApproveAction.fromJS(_data["action"]) : <any>undefined;
            (<any>this).hasProcessedRequest = _data["hasProcessedRequest"];
        }
    }

    static fromJS(data: any): Signee {
        data = typeof data === 'object' ? data : {};
        let result = new Signee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["successor"] = this.successor ? this.successor.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["hasProcessedRequest"] = this.hasProcessedRequest;
        return data;
    }
}

export interface ISignee {
    subject?: string | undefined;
    successor?: Approver | undefined;
    action?: ApproveAction | undefined;
    hasProcessedRequest?: boolean;
}

export class TaskDashboard implements ITaskDashboard {
    id?: string;
    name?: string | undefined;
    status?: string | undefined;
    teamId?: string | undefined;
    type?: string | undefined;
    started?: Date | undefined;
    cancelled?: Date | undefined;
    completed?: Date | undefined;

    constructor(data?: ITaskDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.teamId = _data["teamId"];
            this.type = _data["type"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.cancelled = _data["cancelled"] ? new Date(_data["cancelled"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TaskDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new TaskDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["status"] = this.status;
        data["teamId"] = this.teamId;
        data["type"] = this.type;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["cancelled"] = this.cancelled ? this.cancelled.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITaskDashboard {
    id?: string;
    name?: string | undefined;
    status?: string | undefined;
    teamId?: string | undefined;
    type?: string | undefined;
    started?: Date | undefined;
    cancelled?: Date | undefined;
    completed?: Date | undefined;
}

/** Service response data */
export class TaskServiceResponse implements ITaskServiceResponse {
    /** The service response DTO */
    data?: Task | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ITaskServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? Task.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaskServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface ITaskServiceResponse {
    /** The service response DTO */
    data?: Task | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Represents the details of validation error */
export class ValidationErrorModel implements IValidationErrorModel {
    /** Name of the property */
    propertyName?: string | undefined;
    /** User friendly error message */
    errorMessage?: string | undefined;
    /** Invalid value */
    attemptedValue?: any | undefined;
    /** Internal error code */
    errorCode?: string | undefined;

    constructor(data?: IValidationErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            this.attemptedValue = _data["attemptedValue"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ValidationErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

/** Represents the details of validation error */
export interface IValidationErrorModel {
    /** Name of the property */
    propertyName?: string | undefined;
    /** User friendly error message */
    errorMessage?: string | undefined;
    /** Invalid value */
    attemptedValue?: any | undefined;
    /** Internal error code */
    errorCode?: string | undefined;
}

/** Service response data */
export class ValidationErrorModelListServiceResponse implements IValidationErrorModelListServiceResponse {
    /** The service response DTO */
    data?: ValidationErrorModel[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IValidationErrorModelListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ValidationErrorModel.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationErrorModelListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModelListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IValidationErrorModelListServiceResponse {
    /** The service response DTO */
    data?: ValidationErrorModel[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export enum VersionStatus {
    Draft = "Draft",
    Pending = "Pending",
    Rejected = "Rejected",
    Published = "Published",
    Archived = "Archived",
    Deleted = "Deleted",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}