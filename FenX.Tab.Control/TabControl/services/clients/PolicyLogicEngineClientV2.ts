//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * Allows clearing the Logic Engine API cache.
    This is an maintenance endpoint and does not need to be used under normal circumstances.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param clearRequirementsCache (optional) If the Requirements cache should be flushed
     * @param clearRequirementSetsCache (optional) If the Requirement sets cache should be flushed
     * @param clearDataGroupsCache (optional) If the DataGroup cache should be flushed
     * @return Success. Cache was flushed successfully.
     */
    flush(x_TENANT_ID: string, clearRequirementsCache?: boolean | undefined, clearRequirementSetsCache?: boolean | undefined, clearDataGroupsCache?: boolean | undefined): Promise<ClearCacheResponseDtoServiceResponse>;
    /**
     * Evaluate requirement
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Service request with key-value data required for evaluation
     * @return Success. The list of evaluated requirements is returned
     */
    evaluateV2(x_TENANT_ID: string, body?: EvaluateRequirementsRequestV2DtoServiceRequest | undefined): Promise<RequirementListServiceResponse>;
    /**
     * Evaluate requirement set
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Service request with key-value data required for evaluation
     * @return Success. The list of evaluated requirement sets is returned
     */
    evaluateRequirementSets(x_TENANT_ID: string, body?: EvaluateRequirementSetsRequestDtoServiceRequest | undefined): Promise<EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse>;
    /**
     * Evaluate data group fields
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Service request with key-value data required for evaluation
     * @return Success. The list of evaluated data group fields is returned
     */
    evaluateDataGroupFields(x_TENANT_ID: string, body?: EvaluateDataGroupFieldsRequestDtoServiceRequest | undefined): Promise<DataGroupFieldDtoIEnumerableServiceResponse>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/policylogicengine";

    }

    /**
     * Allows clearing the Logic Engine API cache.
    This is an maintenance endpoint and does not need to be used under normal circumstances.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param clearRequirementsCache (optional) If the Requirements cache should be flushed
     * @param clearRequirementSetsCache (optional) If the Requirement sets cache should be flushed
     * @param clearDataGroupsCache (optional) If the DataGroup cache should be flushed
     * @return Success. Cache was flushed successfully.
     */
    flush(x_TENANT_ID: string, clearRequirementsCache?: boolean | undefined, clearRequirementSetsCache?: boolean | undefined, clearDataGroupsCache?: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ClearCacheResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/cache/flush?";
        if (clearRequirementsCache === null)
            throw new Error("The parameter 'clearRequirementsCache' cannot be null.");
        else if (clearRequirementsCache !== undefined)
            url_ += "clearRequirementsCache=" + encodeURIComponent("" + clearRequirementsCache) + "&";
        if (clearRequirementSetsCache === null)
            throw new Error("The parameter 'clearRequirementSetsCache' cannot be null.");
        else if (clearRequirementSetsCache !== undefined)
            url_ += "clearRequirementSetsCache=" + encodeURIComponent("" + clearRequirementSetsCache) + "&";
        if (clearDataGroupsCache === null)
            throw new Error("The parameter 'clearDataGroupsCache' cannot be null.");
        else if (clearDataGroupsCache !== undefined)
            url_ += "clearDataGroupsCache=" + encodeURIComponent("" + clearDataGroupsCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFlush(_response);
        });
    }

    protected processFlush(response: AxiosResponse): Promise<ClearCacheResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClearCacheResponseDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<ClearCacheResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClearCacheResponseDtoServiceResponse>(null as any);
    }

    /**
     * Evaluate requirement
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Service request with key-value data required for evaluation
     * @return Success. The list of evaluated requirements is returned
     */
    evaluateV2(x_TENANT_ID: string, body?: EvaluateRequirementsRequestV2DtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<RequirementListServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/engine/evaluate-requirements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvaluateV2(_response);
        });
    }

    protected processEvaluateV2(response: AxiosResponse): Promise<RequirementListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequirementListServiceResponse.fromJS(resultData200);
            return Promise.resolve<RequirementListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequirementListServiceResponse>(null as any);
    }

    /**
     * Evaluate requirement set
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Service request with key-value data required for evaluation
     * @return Success. The list of evaluated requirement sets is returned
     */
    evaluateRequirementSets(x_TENANT_ID: string, body?: EvaluateRequirementSetsRequestDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/engine/evaluate-requirement-sets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvaluateRequirementSets(_response);
        });
    }

    protected processEvaluateRequirementSets(response: AxiosResponse): Promise<EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Evaluate data group fields
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Service request with key-value data required for evaluation
     * @return Success. The list of evaluated data group fields is returned
     */
    evaluateDataGroupFields(x_TENANT_ID: string, body?: EvaluateDataGroupFieldsRequestDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<DataGroupFieldDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/engine/evaluate-data-group-fields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvaluateDataGroupFields(_response);
        });
    }

    protected processEvaluateDataGroupFields(response: AxiosResponse): Promise<DataGroupFieldDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataGroupFieldDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<DataGroupFieldDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataGroupFieldDtoIEnumerableServiceResponse>(null as any);
    }
}

export class AccessLayer implements IAccessLayer {
    businessRelated?: string[] | undefined;
    geographic?: string[] | undefined;

    constructor(data?: IAccessLayer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["businessRelated"])) {
                this.businessRelated = [] as any;
                for (let item of _data["businessRelated"])
                    this.businessRelated!.push(item);
            }
            if (Array.isArray(_data["geographic"])) {
                this.geographic = [] as any;
                for (let item of _data["geographic"])
                    this.geographic!.push(item);
            }
        }
    }

    static fromJS(data: any): AccessLayer {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.businessRelated)) {
            data["businessRelated"] = [];
            for (let item of this.businessRelated)
                data["businessRelated"].push(item);
        }
        if (Array.isArray(this.geographic)) {
            data["geographic"] = [];
            for (let item of this.geographic)
                data["geographic"].push(item);
        }
        return data;
    }
}

export interface IAccessLayer {
    businessRelated?: string[] | undefined;
    geographic?: string[] | undefined;
}

export class BasicRule implements IBasicRule {
    active?: boolean;
    message?: string | undefined;

    constructor(data?: IBasicRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): BasicRule {
        data = typeof data === 'object' ? data : {};
        let result = new BasicRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        return data;
    }
}

export interface IBasicRule {
    active?: boolean;
    message?: string | undefined;
}

/** Represents the clear cache response */
export class ClearCacheResponseDto implements IClearCacheResponseDto {
    /** If true, the Requirements rules cache was cleared
<example>true</example> */
    requirementsCacheCleared?: boolean;
    /** If true, the RequirementsSets rules cache was cleared
<example>true</example> */
    requirementSetsCacheCleared?: boolean;
    /** If true, the DataGroup rules cache was cleared
<example>true</example> */
    dataGroupsCacheCleared?: boolean;

    constructor(data?: IClearCacheResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requirementsCacheCleared = _data["requirementsCacheCleared"];
            this.requirementSetsCacheCleared = _data["requirementSetsCacheCleared"];
            this.dataGroupsCacheCleared = _data["dataGroupsCacheCleared"];
        }
    }

    static fromJS(data: any): ClearCacheResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClearCacheResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requirementsCacheCleared"] = this.requirementsCacheCleared;
        data["requirementSetsCacheCleared"] = this.requirementSetsCacheCleared;
        data["dataGroupsCacheCleared"] = this.dataGroupsCacheCleared;
        return data;
    }
}

/** Represents the clear cache response */
export interface IClearCacheResponseDto {
    /** If true, the Requirements rules cache was cleared
<example>true</example> */
    requirementsCacheCleared?: boolean;
    /** If true, the RequirementsSets rules cache was cleared
<example>true</example> */
    requirementSetsCacheCleared?: boolean;
    /** If true, the DataGroup rules cache was cleared
<example>true</example> */
    dataGroupsCacheCleared?: boolean;
}

export class ClearCacheResponseDtoServiceResponse implements IClearCacheResponseDtoServiceResponse {
    /** Represents the clear cache response */
    data?: ClearCacheResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IClearCacheResponseDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ClearCacheResponseDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClearCacheResponseDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClearCacheResponseDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClearCacheResponseDtoServiceResponse {
    /** Represents the clear cache response */
    data?: ClearCacheResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class CollectionDto implements ICollectionDto {
    isValid?: boolean;
    properties?: { [key: string]: string; } | undefined;

    constructor(data?: ICollectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface ICollectionDto {
    isValid?: boolean;
    properties?: { [key: string]: string; } | undefined;
}

export class CollectionMaximumCountRule implements ICollectionMaximumCountRule {
    active?: boolean;
    message?: string | undefined;
    requiredTypesMaxCount?: { [key: string]: number; } | undefined;
    overallMaximumCount?: number | undefined;

    constructor(data?: ICollectionMaximumCountRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            if (_data["requiredTypesMaxCount"]) {
                this.requiredTypesMaxCount = {} as any;
                for (let key in _data["requiredTypesMaxCount"]) {
                    if (_data["requiredTypesMaxCount"].hasOwnProperty(key))
                        (<any>this.requiredTypesMaxCount)![key] = _data["requiredTypesMaxCount"][key];
                }
            }
            this.overallMaximumCount = _data["overallMaximumCount"];
        }
    }

    static fromJS(data: any): CollectionMaximumCountRule {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionMaximumCountRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        if (this.requiredTypesMaxCount) {
            data["requiredTypesMaxCount"] = {};
            for (let key in this.requiredTypesMaxCount) {
                if (this.requiredTypesMaxCount.hasOwnProperty(key))
                    (<any>data["requiredTypesMaxCount"])[key] = (<any>this.requiredTypesMaxCount)[key];
            }
        }
        data["overallMaximumCount"] = this.overallMaximumCount;
        return data;
    }
}

export interface ICollectionMaximumCountRule {
    active?: boolean;
    message?: string | undefined;
    requiredTypesMaxCount?: { [key: string]: number; } | undefined;
    overallMaximumCount?: number | undefined;
}

export class CollectionMinimumCountRule implements ICollectionMinimumCountRule {
    active?: boolean;
    message?: string | undefined;
    requiredTypesMinCount?: { [key: string]: number; } | undefined;
    overallMinimumCount?: number;

    constructor(data?: ICollectionMinimumCountRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            if (_data["requiredTypesMinCount"]) {
                this.requiredTypesMinCount = {} as any;
                for (let key in _data["requiredTypesMinCount"]) {
                    if (_data["requiredTypesMinCount"].hasOwnProperty(key))
                        (<any>this.requiredTypesMinCount)![key] = _data["requiredTypesMinCount"][key];
                }
            }
            this.overallMinimumCount = _data["overallMinimumCount"];
        }
    }

    static fromJS(data: any): CollectionMinimumCountRule {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionMinimumCountRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        if (this.requiredTypesMinCount) {
            data["requiredTypesMinCount"] = {};
            for (let key in this.requiredTypesMinCount) {
                if (this.requiredTypesMinCount.hasOwnProperty(key))
                    (<any>data["requiredTypesMinCount"])[key] = (<any>this.requiredTypesMinCount)[key];
            }
        }
        data["overallMinimumCount"] = this.overallMinimumCount;
        return data;
    }
}

export interface ICollectionMinimumCountRule {
    active?: boolean;
    message?: string | undefined;
    requiredTypesMinCount?: { [key: string]: number; } | undefined;
    overallMinimumCount?: number;
}

export class PropertyDto implements IPropertyDto {
    isValid?: boolean | undefined;

    protected _discriminator: string;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "PropertyDto";
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "Collection") {
            let result = new CollectionPropertyDto();
            result.init(data);
            return result;
        }
        if (data["type"] === "Custom") {
            let result = new CustomPropertyDto();
            result.init(data);
            return result;
        }
        if (data["type"] === "Single") {
            let result = new SinglePropertyDto();
            result.init(data);
            return result;
        }
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator;
        data["isValid"] = this.isValid;
        return data;
    }
}

export interface IPropertyDto {
    isValid?: boolean | undefined;
}

export class CollectionPropertyDto extends PropertyDto implements ICollectionPropertyDto {
    dataGroupId?: string;
    dataGroupVersionNumber?: number | undefined;
    collections?: { [key: string]: CollectionDto; } | undefined;

    constructor(data?: ICollectionPropertyDto) {
        super(data);
        this._discriminator = "Collection";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dataGroupId = _data["dataGroupId"];
            this.dataGroupVersionNumber = _data["dataGroupVersionNumber"];
            if (_data["collections"]) {
                this.collections = {} as any;
                for (let key in _data["collections"]) {
                    if (_data["collections"].hasOwnProperty(key))
                        (<any>this.collections)![key] = _data["collections"][key] ? CollectionDto.fromJS(_data["collections"][key]) : new CollectionDto();
                }
            }
        }
    }

    static fromJS(data: any): CollectionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataGroupId"] = this.dataGroupId;
        data["dataGroupVersionNumber"] = this.dataGroupVersionNumber;
        if (this.collections) {
            data["collections"] = {};
            for (let key in this.collections) {
                if (this.collections.hasOwnProperty(key))
                    (<any>data["collections"])[key] = this.collections[key] ? this.collections[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICollectionPropertyDto extends IPropertyDto {
    dataGroupId?: string;
    dataGroupVersionNumber?: number | undefined;
    collections?: { [key: string]: CollectionDto; } | undefined;
}

export class Condition implements ICondition {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;

    constructor(data?: ICondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Condition {
        data = typeof data === 'object' ? data : {};
        let result = new Condition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICondition {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
}

export class ConditionDefinition implements IConditionDefinition {
    fieldName?: string | undefined;
    value?: string[] | undefined;
    valueType?: string | undefined;
    dataSource?: string | undefined;
    operation?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
    readonly isCondition?: boolean;

    constructor(data?: IConditionDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.valueType = _data["valueType"];
            this.dataSource = _data["dataSource"];
            this.operation = _data["operation"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinition.fromJS(item));
            }
            (<any>this).isCondition = _data["isCondition"];
        }
    }

    static fromJS(data: any): ConditionDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["valueType"] = this.valueType;
        data["dataSource"] = this.dataSource;
        data["operation"] = this.operation;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        data["isCondition"] = this.isCondition;
        return data;
    }
}

export interface IConditionDefinition {
    fieldName?: string | undefined;
    value?: string[] | undefined;
    valueType?: string | undefined;
    dataSource?: string | undefined;
    operation?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
    isCondition?: boolean;
}

export class ConditionDefinitionDto implements IConditionDefinitionDto {
    fieldName?: string | undefined;
    value?: string[] | undefined;
    valueType?: string | undefined;
    dataSource?: string | undefined;
    operation?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;

    constructor(data?: IConditionDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.valueType = _data["valueType"];
            this.dataSource = _data["dataSource"];
            this.operation = _data["operation"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["valueType"] = this.valueType;
        data["dataSource"] = this.dataSource;
        data["operation"] = this.operation;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConditionDefinitionDto {
    fieldName?: string | undefined;
    value?: string[] | undefined;
    valueType?: string | undefined;
    dataSource?: string | undefined;
    operation?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;
}

export class ConditionDto implements IConditionDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;

    constructor(data?: IConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConditionDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;
}

export class ConditionalValue implements IConditionalValue {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
    value?: string | undefined;
    priority?: number;

    constructor(data?: IConditionalValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinition.fromJS(item));
            }
            this.value = _data["value"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): ConditionalValue {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionalValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        data["value"] = this.value;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IConditionalValue {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
    value?: string | undefined;
    priority?: number;
}

export class ConditionalValueDto implements IConditionalValueDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;
    value?: string | undefined;
    priority?: number;

    constructor(data?: IConditionalValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
            this.value = _data["value"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): ConditionalValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionalValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        data["value"] = this.value;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IConditionalValueDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;
    value?: string | undefined;
    priority?: number;
}

export class CustomPropertyDto extends PropertyDto implements ICustomPropertyDto {
    customTypeId?: string;
    properties?: { [key: string]: PropertyDto; } | undefined;

    constructor(data?: ICustomPropertyDto) {
        super(data);
        this._discriminator = "Custom";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customTypeId = _data["customTypeId"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): CustomPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTypeId"] = this.customTypeId;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICustomPropertyDto extends IPropertyDto {
    customTypeId?: string;
    properties?: { [key: string]: PropertyDto; } | undefined;
}

export class DataField implements IDataField {
    propertyName?: string | undefined;
    propertyType?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVersion?: number | undefined;
    linkChildFieldPropertyName?: string | undefined;

    constructor(data?: IDataField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.propertyType = _data["propertyType"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.propertyTypeVersion = _data["propertyTypeVersion"];
            this.linkChildFieldPropertyName = _data["linkChildFieldPropertyName"];
        }
    }

    static fromJS(data: any): DataField {
        data = typeof data === 'object' ? data : {};
        let result = new DataField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["propertyType"] = this.propertyType;
        data["propertyTypeId"] = this.propertyTypeId;
        data["propertyTypeVersion"] = this.propertyTypeVersion;
        data["linkChildFieldPropertyName"] = this.linkChildFieldPropertyName;
        return data;
    }
}

export interface IDataField {
    propertyName?: string | undefined;
    propertyType?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVersion?: number | undefined;
    linkChildFieldPropertyName?: string | undefined;
}

/** Response DTO representing data field data */
export class DataFieldDto implements IDataFieldDto {
    /** Property name */
    propertyName?: string | undefined;
    /** Property type */
    propertyType?: string | undefined;
    /** Property type id */
    propertyTypeId?: string | undefined;
    /** Linked child field property name */
    linkChildFieldPropertyName?: string | undefined;

    constructor(data?: IDataFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.propertyType = _data["propertyType"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.linkChildFieldPropertyName = _data["linkChildFieldPropertyName"];
        }
    }

    static fromJS(data: any): DataFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["propertyType"] = this.propertyType;
        data["propertyTypeId"] = this.propertyTypeId;
        data["linkChildFieldPropertyName"] = this.linkChildFieldPropertyName;
        return data;
    }
}

/** Response DTO representing data field data */
export interface IDataFieldDto {
    /** Property name */
    propertyName?: string | undefined;
    /** Property type */
    propertyType?: string | undefined;
    /** Property type id */
    propertyTypeId?: string | undefined;
    /** Linked child field property name */
    linkChildFieldPropertyName?: string | undefined;
}

export class Requirement implements IRequirement {
    version?: number;
    isLocked?: boolean;
    rootVersionId?: string;
    versionNumber?: number;
    id?: string;
    tenant?: string | undefined;
    category?: string | undefined;
    description?: string | undefined;
    template?: string | undefined;
    entityType?: string | undefined;
    name?: string | undefined;
    isSensitiveData?: boolean;
    isMaterialData?: boolean;
    isCoreDefinition?: boolean;
    jurisdiction?: string | undefined;
    dataProtectionJurisdiction?: string | undefined;
    references?: Reference[] | undefined;
    targetEntity?: string | undefined;
    classification?: string | undefined;
    type?: string | undefined;
    conditions?: Condition[] | undefined;
    tags?: string[] | undefined;
    requirementSetId?: string;

    protected _discriminator: string;

    constructor(data?: IRequirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Requirement";
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.isLocked = _data["isLocked"];
            this.rootVersionId = _data["rootVersionId"];
            this.versionNumber = _data["versionNumber"];
            this.id = _data["id"];
            this.tenant = _data["tenant"];
            this.category = _data["category"];
            this.description = _data["description"];
            this.template = _data["template"];
            this.entityType = _data["entityType"];
            this.name = _data["name"];
            this.isSensitiveData = _data["isSensitiveData"];
            this.isMaterialData = _data["isMaterialData"];
            this.isCoreDefinition = _data["isCoreDefinition"];
            this.jurisdiction = _data["jurisdiction"];
            this.dataProtectionJurisdiction = _data["dataProtectionJurisdiction"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(Reference.fromJS(item));
            }
            this.targetEntity = _data["targetEntity"];
            this.classification = _data["classification"];
            this.type = _data["type"];
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(Condition.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.requirementSetId = _data["RequirementSetId"];
        }
    }

    static fromJS(data: any): Requirement {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "Data") {
            let result = new DataRequirement();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "Document") {
            let result = new DocumentRequirement();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "eSignature Document") {
            let result = new ESignatureDocumentRequirement();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "Ownership and Control") {
            let result = new OwnershipAndControlRequirement();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DataGroup") {
            let result = new DataGroupField();
            result.init(data);
            return result;
        }
        let result = new Requirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["version"] = this.version;
        data["isLocked"] = this.isLocked;
        data["rootVersionId"] = this.rootVersionId;
        data["versionNumber"] = this.versionNumber;
        data["id"] = this.id;
        data["tenant"] = this.tenant;
        data["category"] = this.category;
        data["description"] = this.description;
        data["template"] = this.template;
        data["entityType"] = this.entityType;
        data["name"] = this.name;
        data["isSensitiveData"] = this.isSensitiveData;
        data["isMaterialData"] = this.isMaterialData;
        data["isCoreDefinition"] = this.isCoreDefinition;
        data["jurisdiction"] = this.jurisdiction;
        data["dataProtectionJurisdiction"] = this.dataProtectionJurisdiction;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item.toJSON());
        }
        data["targetEntity"] = this.targetEntity;
        data["classification"] = this.classification;
        data["type"] = this.type;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["RequirementSetId"] = this.requirementSetId;
        return data;
    }
}

export interface IRequirement {
    version?: number;
    isLocked?: boolean;
    rootVersionId?: string;
    versionNumber?: number;
    id?: string;
    tenant?: string | undefined;
    category?: string | undefined;
    description?: string | undefined;
    template?: string | undefined;
    entityType?: string | undefined;
    name?: string | undefined;
    isSensitiveData?: boolean;
    isMaterialData?: boolean;
    isCoreDefinition?: boolean;
    jurisdiction?: string | undefined;
    dataProtectionJurisdiction?: string | undefined;
    references?: Reference[] | undefined;
    targetEntity?: string | undefined;
    classification?: string | undefined;
    type?: string | undefined;
    conditions?: Condition[] | undefined;
    tags?: string[] | undefined;
    requirementSetId?: string;
}

export class DataGroupField extends Requirement implements IDataGroupField {
    versionId?: string;
    dataField?: DataField | undefined;
    order?: number | undefined;
    validationRule?: ValidationRule | undefined;
    defaultValue?: string | undefined;
    isReadOnly?: boolean;
    conditionalValues?: ConditionalValue[] | undefined;

    constructor(data?: IDataGroupField) {
        super(data);
        this._discriminator = "DataGroup";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.versionId = _data["versionId"];
            this.dataField = _data["dataField"] ? DataField.fromJS(_data["dataField"]) : <any>undefined;
            this.order = _data["order"];
            this.validationRule = _data["validationRule"] ? ValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
            this.defaultValue = _data["defaultValue"];
            this.isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["conditionalValues"])) {
                this.conditionalValues = [] as any;
                for (let item of _data["conditionalValues"])
                    this.conditionalValues!.push(ConditionalValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataGroupField {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["versionId"] = this.versionId;
        data["dataField"] = this.dataField ? this.dataField.toJSON() : <any>undefined;
        data["order"] = this.order;
        data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
        data["defaultValue"] = this.defaultValue;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.conditionalValues)) {
            data["conditionalValues"] = [];
            for (let item of this.conditionalValues)
                data["conditionalValues"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDataGroupField extends IRequirement {
    versionId?: string;
    dataField?: DataField | undefined;
    order?: number | undefined;
    validationRule?: ValidationRule | undefined;
    defaultValue?: string | undefined;
    isReadOnly?: boolean;
    conditionalValues?: ConditionalValue[] | undefined;
}

/** Response DTO representing data group field data */
export class DataGroupFieldDto implements IDataGroupFieldDto {
    /** The UiD of the data group field */
    identifier?: string;
    /** Data group field name */
    name?: string | undefined;
    /** Data group field type */
    type?: string | undefined;
    /** Data group field order */
    order?: number | undefined;
    /** Data group field data field */
    dataField?: DataFieldDto | undefined;
    /** Data group field sensitive data flag */
    isSensitiveData?: boolean;
    /** Data group field core definition flag */
    isCoreDefinition?: boolean;
    /** Data group field validation data */
    validationRule?: ValidationRule | undefined;
    /** Data group field conditions list */
    conditions?: ConditionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
    /** Default value for this data field */
    defaultValue?: string | undefined;
    /** Is requirement readonly */
    isReadOnly?: boolean;
    /** List of conditional values */
    conditionalValues?: ConditionalValueDto[] | undefined;
    /** Does this field has evaluated conditional value? */
    hasEvaluatedConditionalValue?: boolean;
    /** Evaluated conditional value */
    evaluatedConditionalValue?: string | undefined;

    constructor(data?: IDataGroupFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identifier = _data["identifier"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.order = _data["order"];
            this.dataField = _data["dataField"] ? DataFieldDto.fromJS(_data["dataField"]) : <any>undefined;
            this.isSensitiveData = _data["isSensitiveData"];
            this.isCoreDefinition = _data["isCoreDefinition"];
            this.validationRule = _data["validationRule"] ? ValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            this.version = _data["version"];
            this.defaultValue = _data["defaultValue"];
            this.isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["conditionalValues"])) {
                this.conditionalValues = [] as any;
                for (let item of _data["conditionalValues"])
                    this.conditionalValues!.push(ConditionalValueDto.fromJS(item));
            }
            this.hasEvaluatedConditionalValue = _data["hasEvaluatedConditionalValue"];
            this.evaluatedConditionalValue = _data["evaluatedConditionalValue"];
        }
    }

    static fromJS(data: any): DataGroupFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        data["name"] = this.name;
        data["type"] = this.type;
        data["order"] = this.order;
        data["dataField"] = this.dataField ? this.dataField.toJSON() : <any>undefined;
        data["isSensitiveData"] = this.isSensitiveData;
        data["isCoreDefinition"] = this.isCoreDefinition;
        data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["version"] = this.version;
        data["defaultValue"] = this.defaultValue;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.conditionalValues)) {
            data["conditionalValues"] = [];
            for (let item of this.conditionalValues)
                data["conditionalValues"].push(item.toJSON());
        }
        data["hasEvaluatedConditionalValue"] = this.hasEvaluatedConditionalValue;
        data["evaluatedConditionalValue"] = this.evaluatedConditionalValue;
        return data;
    }
}

/** Response DTO representing data group field data */
export interface IDataGroupFieldDto {
    /** The UiD of the data group field */
    identifier?: string;
    /** Data group field name */
    name?: string | undefined;
    /** Data group field type */
    type?: string | undefined;
    /** Data group field order */
    order?: number | undefined;
    /** Data group field data field */
    dataField?: DataFieldDto | undefined;
    /** Data group field sensitive data flag */
    isSensitiveData?: boolean;
    /** Data group field core definition flag */
    isCoreDefinition?: boolean;
    /** Data group field validation data */
    validationRule?: ValidationRule | undefined;
    /** Data group field conditions list */
    conditions?: ConditionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
    /** Default value for this data field */
    defaultValue?: string | undefined;
    /** Is requirement readonly */
    isReadOnly?: boolean;
    /** List of conditional values */
    conditionalValues?: ConditionalValueDto[] | undefined;
    /** Does this field has evaluated conditional value? */
    hasEvaluatedConditionalValue?: boolean;
    /** Evaluated conditional value */
    evaluatedConditionalValue?: string | undefined;
}

export class DataGroupFieldDtoIEnumerableServiceResponse implements IDataGroupFieldDtoIEnumerableServiceResponse {
    data?: DataGroupFieldDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDataGroupFieldDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DataGroupFieldDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataGroupFieldDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupFieldDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDataGroupFieldDtoIEnumerableServiceResponse {
    data?: DataGroupFieldDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class DataRequirement extends Requirement implements IDataRequirement {
    dataField?: DataField | undefined;
    validationRule?: ValidationRule | undefined;
    order?: number | undefined;
    defaultValue?: string | undefined;
    isReadOnly?: boolean;
    isIndexable?: boolean;
    readonly isMandatoryIndexable?: boolean;
    conditionalValues?: ConditionalValue[] | undefined;

    constructor(data?: IDataRequirement) {
        super(data);
        this._discriminator = "Data";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dataField = _data["dataField"] ? DataField.fromJS(_data["dataField"]) : <any>undefined;
            this.validationRule = _data["validationRule"] ? ValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
            this.order = _data["order"];
            this.defaultValue = _data["defaultValue"];
            this.isReadOnly = _data["isReadOnly"];
            this.isIndexable = _data["isIndexable"];
            (<any>this).isMandatoryIndexable = _data["isMandatoryIndexable"];
            if (Array.isArray(_data["conditionalValues"])) {
                this.conditionalValues = [] as any;
                for (let item of _data["conditionalValues"])
                    this.conditionalValues!.push(ConditionalValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new DataRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataField"] = this.dataField ? this.dataField.toJSON() : <any>undefined;
        data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
        data["order"] = this.order;
        data["defaultValue"] = this.defaultValue;
        data["isReadOnly"] = this.isReadOnly;
        data["isIndexable"] = this.isIndexable;
        data["isMandatoryIndexable"] = this.isMandatoryIndexable;
        if (Array.isArray(this.conditionalValues)) {
            data["conditionalValues"] = [];
            for (let item of this.conditionalValues)
                data["conditionalValues"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDataRequirement extends IRequirement {
    dataField?: DataField | undefined;
    validationRule?: ValidationRule | undefined;
    order?: number | undefined;
    defaultValue?: string | undefined;
    isReadOnly?: boolean;
    isIndexable?: boolean;
    isMandatoryIndexable?: boolean;
    conditionalValues?: ConditionalValue[] | undefined;
}

export class DateLimitRule implements IDateLimitRule {
    active?: boolean;
    message?: string | undefined;
    minDate?: Date | undefined;
    maxDate?: Date | undefined;

    constructor(data?: IDateLimitRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            this.minDate = _data["minDate"] ? new Date(_data["minDate"].toString()) : <any>undefined;
            this.maxDate = _data["maxDate"] ? new Date(_data["maxDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateLimitRule {
        data = typeof data === 'object' ? data : {};
        let result = new DateLimitRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        data["minDate"] = this.minDate ? this.minDate.toISOString() : <any>undefined;
        data["maxDate"] = this.maxDate ? this.maxDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDateLimitRule {
    active?: boolean;
    message?: string | undefined;
    minDate?: Date | undefined;
    maxDate?: Date | undefined;
}

export class DocumentRequirement extends Requirement implements IDocumentRequirement {
    isMandatory?: boolean;
    documentDescription?: string | undefined;
    documentDataKey?: string | undefined;
    documentAccessLayers?: AccessLayer | undefined;

    constructor(data?: IDocumentRequirement) {
        super(data);
        this._discriminator = "Document";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isMandatory = _data["isMandatory"];
            this.documentDescription = _data["documentDescription"];
            this.documentDataKey = _data["documentDataKey"];
            this.documentAccessLayers = _data["documentAccessLayers"] ? AccessLayer.fromJS(_data["documentAccessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMandatory"] = this.isMandatory;
        data["documentDescription"] = this.documentDescription;
        data["documentDataKey"] = this.documentDataKey;
        data["documentAccessLayers"] = this.documentAccessLayers ? this.documentAccessLayers.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDocumentRequirement extends IRequirement {
    isMandatory?: boolean;
    documentDescription?: string | undefined;
    documentDataKey?: string | undefined;
    documentAccessLayers?: AccessLayer | undefined;
}

export class ESignatureDocumentRequirement extends Requirement implements IESignatureDocumentRequirement {
    isMandatory?: boolean;
    documentDescription?: string | undefined;
    documentDataKey?: string | undefined;
    documentAccessLayers?: AccessLayer | undefined;

    constructor(data?: IESignatureDocumentRequirement) {
        super(data);
        this._discriminator = "eSignature Document";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isMandatory = _data["isMandatory"];
            this.documentDescription = _data["documentDescription"];
            this.documentDataKey = _data["documentDataKey"];
            this.documentAccessLayers = _data["documentAccessLayers"] ? AccessLayer.fromJS(_data["documentAccessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ESignatureDocumentRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new ESignatureDocumentRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMandatory"] = this.isMandatory;
        data["documentDescription"] = this.documentDescription;
        data["documentDataKey"] = this.documentDataKey;
        data["documentAccessLayers"] = this.documentAccessLayers ? this.documentAccessLayers.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IESignatureDocumentRequirement extends IRequirement {
    isMandatory?: boolean;
    documentDescription?: string | undefined;
    documentDataKey?: string | undefined;
    documentAccessLayers?: AccessLayer | undefined;
}

/** Request DTO representing object used to evaluate the condition of data group fields */
export class EvaluateDataGroupFieldsRequestDto implements IEvaluateDataGroupFieldsRequestDto {
    /** The UiD of the data group */
    dataGroupId?: string | undefined;
    /** The version number of the data group */
    dataGroupVersionNumber?: number | undefined;
    /** Key-Value pair of data to evaluate */
    data?: { [key: string]: string; } | undefined;
    /** Entity data properties for condition evaluation */
    properties?: { [key: string]: PropertyDto; } | undefined;

    constructor(data?: IEvaluateDataGroupFieldsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataGroupId = _data["dataGroupId"];
            this.dataGroupVersionNumber = _data["dataGroupVersionNumber"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): EvaluateDataGroupFieldsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateDataGroupFieldsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataGroupId"] = this.dataGroupId;
        data["dataGroupVersionNumber"] = this.dataGroupVersionNumber;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Request DTO representing object used to evaluate the condition of data group fields */
export interface IEvaluateDataGroupFieldsRequestDto {
    /** The UiD of the data group */
    dataGroupId?: string | undefined;
    /** The version number of the data group */
    dataGroupVersionNumber?: number | undefined;
    /** Key-Value pair of data to evaluate */
    data?: { [key: string]: string; } | undefined;
    /** Entity data properties for condition evaluation */
    properties?: { [key: string]: PropertyDto; } | undefined;
}

export class EvaluateDataGroupFieldsRequestDtoServiceRequest implements IEvaluateDataGroupFieldsRequestDtoServiceRequest {
    /** Request DTO representing object used to evaluate the condition of data group fields */
    data?: EvaluateDataGroupFieldsRequestDto | undefined;

    constructor(data?: IEvaluateDataGroupFieldsRequestDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EvaluateDataGroupFieldsRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EvaluateDataGroupFieldsRequestDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateDataGroupFieldsRequestDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEvaluateDataGroupFieldsRequestDtoServiceRequest {
    /** Request DTO representing object used to evaluate the condition of data group fields */
    data?: EvaluateDataGroupFieldsRequestDto | undefined;
}

export class EvaluateRequirementSetsRequestDtoServiceRequest implements IEvaluateRequirementSetsRequestDtoServiceRequest {
    /** Request DTO representing key-value pairs used to evaluate the condition of requirement set */
    data?: { [key: string]: string; } | undefined;

    constructor(data?: IEvaluateRequirementSetsRequestDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
        }
    }

    static fromJS(data: any): EvaluateRequirementSetsRequestDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementSetsRequestDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        return data;
    }
}

export interface IEvaluateRequirementSetsRequestDtoServiceRequest {
    /** Request DTO representing key-value pairs used to evaluate the condition of requirement set */
    data?: { [key: string]: string; } | undefined;
}

/** Response DTO representing parameters of matched requirement set */
export class EvaluateRequirementSetsResponseDto implements IEvaluateRequirementSetsResponseDto {
    /** The UiD of matched requirement set */
    requirementSetId?: string;
    /** Name of matched requirement set */
    name?: string | undefined;
    /** Jurisdiction of matched requirement set */
    jurisdiction?: string | undefined;

    constructor(data?: IEvaluateRequirementSetsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requirementSetId = _data["requirementSetId"];
            this.name = _data["name"];
            this.jurisdiction = _data["jurisdiction"];
        }
    }

    static fromJS(data: any): EvaluateRequirementSetsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementSetsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requirementSetId"] = this.requirementSetId;
        data["name"] = this.name;
        data["jurisdiction"] = this.jurisdiction;
        return data;
    }
}

/** Response DTO representing parameters of matched requirement set */
export interface IEvaluateRequirementSetsResponseDto {
    /** The UiD of matched requirement set */
    requirementSetId?: string;
    /** Name of matched requirement set */
    name?: string | undefined;
    /** Jurisdiction of matched requirement set */
    jurisdiction?: string | undefined;
}

export class EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse implements IEvaluateRequirementSetsResponseDtoIEnumerableServiceResponse {
    data?: EvaluateRequirementSetsResponseDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEvaluateRequirementSetsResponseDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EvaluateRequirementSetsResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEvaluateRequirementSetsResponseDtoIEnumerableServiceResponse {
    data?: EvaluateRequirementSetsResponseDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Request DTO representing object used to evaluate the condition of requirement */
export class EvaluateRequirementsRequestV2Dto implements IEvaluateRequirementsRequestV2Dto {
    /** List of versioned jurisdiction */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of requirement types [Data, Document, OwnershipAndControl] */
    requirementTypes?: string[] | undefined;
    /** Key-Value pair of data to evaluate */
    data?: { [key: string]: string; } | undefined;
    /** Entity data properties for condition evaluation */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Target entity */
    targetEntity?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    categories?: string[] | undefined;

    constructor(data?: IEvaluateRequirementsRequestV2Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(VersionedJurisdictionDto.fromJS(item));
            }
            if (Array.isArray(_data["requirementTypes"])) {
                this.requirementTypes = [] as any;
                for (let item of _data["requirementTypes"])
                    this.requirementTypes!.push(item);
            }
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
            this.targetEntity = _data["targetEntity"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
        }
    }

    static fromJS(data: any): EvaluateRequirementsRequestV2Dto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementsRequestV2Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item.toJSON());
        }
        if (Array.isArray(this.requirementTypes)) {
            data["requirementTypes"] = [];
            for (let item of this.requirementTypes)
                data["requirementTypes"].push(item);
        }
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        data["targetEntity"] = this.targetEntity;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        return data;
    }
}

/** Request DTO representing object used to evaluate the condition of requirement */
export interface IEvaluateRequirementsRequestV2Dto {
    /** List of versioned jurisdiction */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of requirement types [Data, Document, OwnershipAndControl] */
    requirementTypes?: string[] | undefined;
    /** Key-Value pair of data to evaluate */
    data?: { [key: string]: string; } | undefined;
    /** Entity data properties for condition evaluation */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Target entity */
    targetEntity?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    categories?: string[] | undefined;
}

export class EvaluateRequirementsRequestV2DtoServiceRequest implements IEvaluateRequirementsRequestV2DtoServiceRequest {
    /** Request DTO representing object used to evaluate the condition of requirement */
    data?: EvaluateRequirementsRequestV2Dto | undefined;

    constructor(data?: IEvaluateRequirementsRequestV2DtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EvaluateRequirementsRequestV2Dto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EvaluateRequirementsRequestV2DtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementsRequestV2DtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEvaluateRequirementsRequestV2DtoServiceRequest {
    /** Request DTO representing object used to evaluate the condition of requirement */
    data?: EvaluateRequirementsRequestV2Dto | undefined;
}

export class ObjectServiceResponse implements IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class OwnershipAndControlRequirement extends Requirement implements IOwnershipAndControlRequirement {
    ownershipDataKey?: string | undefined;
    partyType?: string | undefined;
    partyTypes?: string[] | undefined;
    uboThreshold?: number | undefined;
    sourceEntityType?: string | undefined;
    relatedPartyEntityTypes?: string[] | undefined;
    directAssociationsOnly?: boolean;
    idvOn?: boolean;
    idvName?: string | undefined;
    idvTooltip?: string | undefined;
    isMandatory?: boolean;
    partyCount?: number | undefined;
    ownershipValidationRule?: OwnershipValidationRule | undefined;

    constructor(data?: IOwnershipAndControlRequirement) {
        super(data);
        this._discriminator = "Ownership and Control";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ownershipDataKey = _data["ownershipDataKey"];
            this.partyType = _data["partyType"];
            if (Array.isArray(_data["partyTypes"])) {
                this.partyTypes = [] as any;
                for (let item of _data["partyTypes"])
                    this.partyTypes!.push(item);
            }
            this.uboThreshold = _data["uboThreshold"];
            this.sourceEntityType = _data["sourceEntityType"];
            if (Array.isArray(_data["relatedPartyEntityTypes"])) {
                this.relatedPartyEntityTypes = [] as any;
                for (let item of _data["relatedPartyEntityTypes"])
                    this.relatedPartyEntityTypes!.push(item);
            }
            this.directAssociationsOnly = _data["directAssociationsOnly"];
            this.idvOn = _data["idvOn"];
            this.idvName = _data["idvName"];
            this.idvTooltip = _data["idvTooltip"];
            this.isMandatory = _data["isMandatory"];
            this.partyCount = _data["partyCount"];
            this.ownershipValidationRule = _data["ownershipValidationRule"] ? OwnershipValidationRule.fromJS(_data["ownershipValidationRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OwnershipAndControlRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new OwnershipAndControlRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownershipDataKey"] = this.ownershipDataKey;
        data["partyType"] = this.partyType;
        if (Array.isArray(this.partyTypes)) {
            data["partyTypes"] = [];
            for (let item of this.partyTypes)
                data["partyTypes"].push(item);
        }
        data["uboThreshold"] = this.uboThreshold;
        data["sourceEntityType"] = this.sourceEntityType;
        if (Array.isArray(this.relatedPartyEntityTypes)) {
            data["relatedPartyEntityTypes"] = [];
            for (let item of this.relatedPartyEntityTypes)
                data["relatedPartyEntityTypes"].push(item);
        }
        data["directAssociationsOnly"] = this.directAssociationsOnly;
        data["idvOn"] = this.idvOn;
        data["idvName"] = this.idvName;
        data["idvTooltip"] = this.idvTooltip;
        data["isMandatory"] = this.isMandatory;
        data["partyCount"] = this.partyCount;
        data["ownershipValidationRule"] = this.ownershipValidationRule ? this.ownershipValidationRule.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IOwnershipAndControlRequirement extends IRequirement {
    ownershipDataKey?: string | undefined;
    partyType?: string | undefined;
    partyTypes?: string[] | undefined;
    uboThreshold?: number | undefined;
    sourceEntityType?: string | undefined;
    relatedPartyEntityTypes?: string[] | undefined;
    directAssociationsOnly?: boolean;
    idvOn?: boolean;
    idvName?: string | undefined;
    idvTooltip?: string | undefined;
    isMandatory?: boolean;
    partyCount?: number | undefined;
    ownershipValidationRule?: OwnershipValidationRule | undefined;
}

export class OwnershipValidationData implements IOwnershipValidationData {
    isMandatory?: BasicRule | undefined;
    partyCount?: ValueLimitRule | undefined;
    addAllParties?: BasicRule | undefined;
    idvIsMandatory?: BasicRule | undefined;
    idvPartyCount?: ValueLimitRule | undefined;
    idvAllParties?: BasicRule | undefined;

    constructor(data?: IOwnershipValidationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isMandatory = _data["isMandatory"] ? BasicRule.fromJS(_data["isMandatory"]) : <any>undefined;
            this.partyCount = _data["partyCount"] ? ValueLimitRule.fromJS(_data["partyCount"]) : <any>undefined;
            this.addAllParties = _data["addAllParties"] ? BasicRule.fromJS(_data["addAllParties"]) : <any>undefined;
            this.idvIsMandatory = _data["idvIsMandatory"] ? BasicRule.fromJS(_data["idvIsMandatory"]) : <any>undefined;
            this.idvPartyCount = _data["idvPartyCount"] ? ValueLimitRule.fromJS(_data["idvPartyCount"]) : <any>undefined;
            this.idvAllParties = _data["idvAllParties"] ? BasicRule.fromJS(_data["idvAllParties"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OwnershipValidationData {
        data = typeof data === 'object' ? data : {};
        let result = new OwnershipValidationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMandatory"] = this.isMandatory ? this.isMandatory.toJSON() : <any>undefined;
        data["partyCount"] = this.partyCount ? this.partyCount.toJSON() : <any>undefined;
        data["addAllParties"] = this.addAllParties ? this.addAllParties.toJSON() : <any>undefined;
        data["idvIsMandatory"] = this.idvIsMandatory ? this.idvIsMandatory.toJSON() : <any>undefined;
        data["idvPartyCount"] = this.idvPartyCount ? this.idvPartyCount.toJSON() : <any>undefined;
        data["idvAllParties"] = this.idvAllParties ? this.idvAllParties.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOwnershipValidationData {
    isMandatory?: BasicRule | undefined;
    partyCount?: ValueLimitRule | undefined;
    addAllParties?: BasicRule | undefined;
    idvIsMandatory?: BasicRule | undefined;
    idvPartyCount?: ValueLimitRule | undefined;
    idvAllParties?: BasicRule | undefined;
}

export class OwnershipValidationRule implements IOwnershipValidationRule {
    id?: string;
    setId?: string;
    ownershipValidationData?: OwnershipValidationData | undefined;

    constructor(data?: IOwnershipValidationRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.setId = _data["setId"];
            this.ownershipValidationData = _data["ownershipValidationData"] ? OwnershipValidationData.fromJS(_data["ownershipValidationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OwnershipValidationRule {
        data = typeof data === 'object' ? data : {};
        let result = new OwnershipValidationRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["setId"] = this.setId;
        data["ownershipValidationData"] = this.ownershipValidationData ? this.ownershipValidationData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOwnershipValidationRule {
    id?: string;
    setId?: string;
    ownershipValidationData?: OwnershipValidationData | undefined;
}

export enum PropertyType {
    Single = "Single",
    Custom = "Custom",
    Collection = "Collection",
}

export class Reference implements IReference {
    type?: string | undefined;
    description?: string | undefined;
    url?: string | undefined;

    constructor(data?: IReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.description = _data["description"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Reference {
        data = typeof data === 'object' ? data : {};
        let result = new Reference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["url"] = this.url;
        return data;
    }
}

export interface IReference {
    type?: string | undefined;
    description?: string | undefined;
    url?: string | undefined;
}

export class RegexRule implements IRegexRule {
    active?: boolean;
    message?: string | undefined;
    isCaseSensitive?: boolean;
    regexValue?: string | undefined;

    constructor(data?: IRegexRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            this.isCaseSensitive = _data["isCaseSensitive"];
            this.regexValue = _data["regexValue"];
        }
    }

    static fromJS(data: any): RegexRule {
        data = typeof data === 'object' ? data : {};
        let result = new RegexRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        data["isCaseSensitive"] = this.isCaseSensitive;
        data["regexValue"] = this.regexValue;
        return data;
    }
}

export interface IRegexRule {
    active?: boolean;
    message?: string | undefined;
    isCaseSensitive?: boolean;
    regexValue?: string | undefined;
}

export class RequirementListServiceResponse implements IRequirementListServiceResponse {
    data?: Requirement[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IRequirementListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Requirement.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequirementListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRequirementListServiceResponse {
    data?: Requirement[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ServiceResponse implements IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ServiceResponseMessage implements IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

export interface IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;
}

export class SinglePropertyDto extends PropertyDto implements ISinglePropertyDto {
    value?: string | undefined;

    constructor(data?: ISinglePropertyDto) {
        super(data);
        this._discriminator = "Single";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SinglePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SinglePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface ISinglePropertyDto extends IPropertyDto {
    value?: string | undefined;
}

export class SpecialCharactersRule implements ISpecialCharactersRule {
    active?: boolean;
    message?: string | undefined;
    excludedCharacters?: string[] | undefined;

    constructor(data?: ISpecialCharactersRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            if (Array.isArray(_data["excludedCharacters"])) {
                this.excludedCharacters = [] as any;
                for (let item of _data["excludedCharacters"])
                    this.excludedCharacters!.push(item);
            }
        }
    }

    static fromJS(data: any): SpecialCharactersRule {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialCharactersRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        if (Array.isArray(this.excludedCharacters)) {
            data["excludedCharacters"] = [];
            for (let item of this.excludedCharacters)
                data["excludedCharacters"].push(item);
        }
        return data;
    }
}

export interface ISpecialCharactersRule {
    active?: boolean;
    message?: string | undefined;
    excludedCharacters?: string[] | undefined;
}

export class ValidationData implements IValidationData {
    isMandatory?: BasicRule | undefined;
    specialCharacters?: SpecialCharactersRule | undefined;
    noNumbers?: BasicRule | undefined;
    onlyInteger?: BasicRule | undefined;
    noNegative?: BasicRule | undefined;
    onlyDecimal?: BasicRule | undefined;
    regex?: RegexRule | undefined;
    characterLimit?: ValueLimitRule | undefined;
    numberLimit?: ValueLimitRule | undefined;
    noFutureDates?: BasicRule | undefined;
    noPastDates?: BasicRule | undefined;
    dateLimit?: DateLimitRule | undefined;
    multiSelectLimit?: ValueLimitRule | undefined;
    collectionMinimumCount?: CollectionMinimumCountRule | undefined;
    collectionMaximumCount?: CollectionMaximumCountRule | undefined;

    constructor(data?: IValidationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isMandatory = _data["isMandatory"] ? BasicRule.fromJS(_data["isMandatory"]) : <any>undefined;
            this.specialCharacters = _data["specialCharacters"] ? SpecialCharactersRule.fromJS(_data["specialCharacters"]) : <any>undefined;
            this.noNumbers = _data["noNumbers"] ? BasicRule.fromJS(_data["noNumbers"]) : <any>undefined;
            this.onlyInteger = _data["onlyInteger"] ? BasicRule.fromJS(_data["onlyInteger"]) : <any>undefined;
            this.noNegative = _data["noNegative"] ? BasicRule.fromJS(_data["noNegative"]) : <any>undefined;
            this.onlyDecimal = _data["onlyDecimal"] ? BasicRule.fromJS(_data["onlyDecimal"]) : <any>undefined;
            this.regex = _data["regex"] ? RegexRule.fromJS(_data["regex"]) : <any>undefined;
            this.characterLimit = _data["characterLimit"] ? ValueLimitRule.fromJS(_data["characterLimit"]) : <any>undefined;
            this.numberLimit = _data["numberLimit"] ? ValueLimitRule.fromJS(_data["numberLimit"]) : <any>undefined;
            this.noFutureDates = _data["noFutureDates"] ? BasicRule.fromJS(_data["noFutureDates"]) : <any>undefined;
            this.noPastDates = _data["noPastDates"] ? BasicRule.fromJS(_data["noPastDates"]) : <any>undefined;
            this.dateLimit = _data["dateLimit"] ? DateLimitRule.fromJS(_data["dateLimit"]) : <any>undefined;
            this.multiSelectLimit = _data["multiSelectLimit"] ? ValueLimitRule.fromJS(_data["multiSelectLimit"]) : <any>undefined;
            this.collectionMinimumCount = _data["collectionMinimumCount"] ? CollectionMinimumCountRule.fromJS(_data["collectionMinimumCount"]) : <any>undefined;
            this.collectionMaximumCount = _data["collectionMaximumCount"] ? CollectionMaximumCountRule.fromJS(_data["collectionMaximumCount"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidationData {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMandatory"] = this.isMandatory ? this.isMandatory.toJSON() : <any>undefined;
        data["specialCharacters"] = this.specialCharacters ? this.specialCharacters.toJSON() : <any>undefined;
        data["noNumbers"] = this.noNumbers ? this.noNumbers.toJSON() : <any>undefined;
        data["onlyInteger"] = this.onlyInteger ? this.onlyInteger.toJSON() : <any>undefined;
        data["noNegative"] = this.noNegative ? this.noNegative.toJSON() : <any>undefined;
        data["onlyDecimal"] = this.onlyDecimal ? this.onlyDecimal.toJSON() : <any>undefined;
        data["regex"] = this.regex ? this.regex.toJSON() : <any>undefined;
        data["characterLimit"] = this.characterLimit ? this.characterLimit.toJSON() : <any>undefined;
        data["numberLimit"] = this.numberLimit ? this.numberLimit.toJSON() : <any>undefined;
        data["noFutureDates"] = this.noFutureDates ? this.noFutureDates.toJSON() : <any>undefined;
        data["noPastDates"] = this.noPastDates ? this.noPastDates.toJSON() : <any>undefined;
        data["dateLimit"] = this.dateLimit ? this.dateLimit.toJSON() : <any>undefined;
        data["multiSelectLimit"] = this.multiSelectLimit ? this.multiSelectLimit.toJSON() : <any>undefined;
        data["collectionMinimumCount"] = this.collectionMinimumCount ? this.collectionMinimumCount.toJSON() : <any>undefined;
        data["collectionMaximumCount"] = this.collectionMaximumCount ? this.collectionMaximumCount.toJSON() : <any>undefined;
        return data;
    }
}

export interface IValidationData {
    isMandatory?: BasicRule | undefined;
    specialCharacters?: SpecialCharactersRule | undefined;
    noNumbers?: BasicRule | undefined;
    onlyInteger?: BasicRule | undefined;
    noNegative?: BasicRule | undefined;
    onlyDecimal?: BasicRule | undefined;
    regex?: RegexRule | undefined;
    characterLimit?: ValueLimitRule | undefined;
    numberLimit?: ValueLimitRule | undefined;
    noFutureDates?: BasicRule | undefined;
    noPastDates?: BasicRule | undefined;
    dateLimit?: DateLimitRule | undefined;
    multiSelectLimit?: ValueLimitRule | undefined;
    collectionMinimumCount?: CollectionMinimumCountRule | undefined;
    collectionMaximumCount?: CollectionMaximumCountRule | undefined;
}

export class ValidationRule implements IValidationRule {
    id?: string;
    setId?: string;
    propertyId?: string;
    propertyName?: string | undefined;
    friendlyName?: string | undefined;
    validationType?: string | undefined;
    isDataGroup?: boolean;
    dataGroupId?: string | undefined;
    validationData?: ValidationData | undefined;

    constructor(data?: IValidationRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.setId = _data["setId"];
            this.propertyId = _data["propertyId"];
            this.propertyName = _data["propertyName"];
            this.friendlyName = _data["friendlyName"];
            this.validationType = _data["validationType"];
            this.isDataGroup = _data["isDataGroup"];
            this.dataGroupId = _data["dataGroupId"];
            this.validationData = _data["validationData"] ? ValidationData.fromJS(_data["validationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidationRule {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["setId"] = this.setId;
        data["propertyId"] = this.propertyId;
        data["propertyName"] = this.propertyName;
        data["friendlyName"] = this.friendlyName;
        data["validationType"] = this.validationType;
        data["isDataGroup"] = this.isDataGroup;
        data["dataGroupId"] = this.dataGroupId;
        data["validationData"] = this.validationData ? this.validationData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IValidationRule {
    id?: string;
    setId?: string;
    propertyId?: string;
    propertyName?: string | undefined;
    friendlyName?: string | undefined;
    validationType?: string | undefined;
    isDataGroup?: boolean;
    dataGroupId?: string | undefined;
    validationData?: ValidationData | undefined;
}

export class ValueLimitRule implements IValueLimitRule {
    active?: boolean;
    message?: string | undefined;
    minValue?: number | undefined;
    maxValue?: number | undefined;

    constructor(data?: IValueLimitRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
        }
    }

    static fromJS(data: any): ValueLimitRule {
        data = typeof data === 'object' ? data : {};
        let result = new ValueLimitRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        return data;
    }
}

export interface IValueLimitRule {
    active?: boolean;
    message?: string | undefined;
    minValue?: number | undefined;
    maxValue?: number | undefined;
}

export class VersionedJurisdictionDto implements IVersionedJurisdictionDto {
    /** Jurisdiction of the requirement */
    jurisdiction?: string | undefined;
    /** Jurisdiction of the requirement */
    versionId?: string | undefined;

    constructor(data?: IVersionedJurisdictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jurisdiction = _data["jurisdiction"];
            this.versionId = _data["versionId"];
        }
    }

    static fromJS(data: any): VersionedJurisdictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new VersionedJurisdictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jurisdiction"] = this.jurisdiction;
        data["versionId"] = this.versionId;
        return data;
    }
}

export interface IVersionedJurisdictionDto {
    /** Jurisdiction of the requirement */
    jurisdiction?: string | undefined;
    /** Jurisdiction of the requirement */
    versionId?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}