//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * Get a document by id and tenant
     * @param id Id of an existing document
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return An instance of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentModelDto class representing the document metadata with the specified 
                id, if found; otherwise, `null`.
     */
    getDocumentModelById(id: string, x_TENANT_ID: string): Promise<DocumentModelDtoServiceResponse>;
    /**
     * Get all documents by journey id
     * @param journeyId Journey id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentModelDto class representing the document metadata with the specified 
                journeyId, if found; otherwise, `null`.
     */
    getAllDocumentsByJourneyId(journeyId: string, x_TENANT_ID: string): Promise<DocumentModelDtoIEnumerableServiceResponse>;
    /**
     * Get all documents by entity id
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentModelDto class representing the document metadata with the specified 
                entityId, if found; otherwise, `null`.
     */
    getAllDocumentsByEntityId(entityId: string, x_TENANT_ID: string): Promise<DocumentModelDtoIEnumerableServiceResponse>;
    /**
     * Gets all Document Models for an Entity Id and Journey Id.
     * @param entityId The entity identifier.
     * @param journeyId The journey identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentModelDto class representing the document models if found; 
                otherwise, `null`.
     */
    getAllModelsByEntityIdAndJourneyId(entityId: string, journeyId: string, x_TENANT_ID: string): Promise<DocumentModelDtoIEnumerableServiceResponse>;
    /**
     * Method to get a signed URL from S3
     * @param id Id of document
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return An url to access the file uploaded for the document with the specified 
                id, if found; otherwise, `null`.
     */
    getSignedUrl(id: string, x_TENANT_ID: string): Promise<StringServiceResponse>;
    /**
     * Get all supported mime types when uploading a file in the document requirements.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of string of mime types
     */
    mimeTypesAllowed(x_TENANT_ID: string): Promise<StringIEnumerableServiceResponse>;
    /**
     * Gets all requirements for a Journey Id.
     * @param journeyId The journey identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentRequirementModelDto class representing the document requirements if found; 
                otherwise, `null`.
     */
    getAllRequirementModelsByJourneyId(journeyId: string, x_TENANT_ID: string): Promise<DocumentRequirementModelDtoIEnumerableServiceResponse>;
    /**
     * Gets a DocumentRequirementModel by Journey Id and Requirement Id
     * @param journeyId The journey identifier.
     * @param requirementId The requirement identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentRequirementModelDto class representing the document requirement if found; 
                otherwise, `null`.
     */
    getDocumentRequirementModelById(journeyId: string, requirementId: string, x_TENANT_ID: string): Promise<DocumentRequirementModelDtoServiceResponse>;
    /**
     * Gets all Document Requirement Statuses for an Entity Id and Journey Id.
     * @param entityId The entity identifier.
     * @param journeyId The journey identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentRequirementModelDto class representing the document requirement statuses if found; 
                otherwise, `null`.
     */
    getAllRequirementModelsByEntityIdAndJourneyId(entityId: string, journeyId: string, x_TENANT_ID: string): Promise<DocumentRequirementModelDtoIEnumerableServiceResponse>;
    /**
     * Gets all Document Requirement Statuses for an Entity Id.
     * @param entityId The entity identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentRequirementModelDto class representing the document requirement statuses if found; 
                otherwise, `null`.
     */
    getAllRequirementModelsByEntityId(entityId: string, x_TENANT_ID: string): Promise<DocumentRequirementModelDtoIEnumerableServiceResponse>;
    /**
     * Gets a DocumentRequirementModel by Journey Id and DocumentDataKey
     * @param journeyId The journey identifier.
     * @param documentDataKey The requirement identifier defined in policy configuration.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentRequirementModelDto class representing the document requirement if found; 
                otherwise, `null`.
     */
    getDocumentRequirementModelByJourneyIdandDocumentDataKey(journeyId: string, documentDataKey: string, x_TENANT_ID: string): Promise<DocumentRequirementModelDtoServiceResponse>;
    /**
     * Get Configuration
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Instance of Fenergo.Nebula.DocumentManagement.Query.Application.Dto.eSignatureConfiguration.ConfigurationDto class containing configuration information.
     */
    getConfiguration(x_TENANT_ID: string): Promise<ConfigurationDtoServiceResponse>;
    /**
     * Get provider configuration
     * @param providerId The ID of provider
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Instance of Fenergo.Nebula.DocumentManagement.Query.Application.Dto.eSignatureConfiguration.ProviderConfigurationDto class containing provider configuration information.
     */
    getProviderConfiguration(providerId: string, x_TENANT_ID: string): Promise<ProviderConfigurationDtoServiceResponse>;
    /**
     * Gets all requirements for a Journey Id.
     * @param journeyId The journey identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.ESignatureDocumentRequirementModelDto class representing the document requirements if found; 
                otherwise, `null`.
     */
    getAllESignatureRequirementModelsByJourneyId(journeyId: string, x_TENANT_ID: string): Promise<ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse>;
    /**
     * Gets a eSignatureDocumentRequirementModel by Journey Id and Requirement Id
     * @param journeyId The journey identifier.
     * @param requirementId The requirement identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A Fenergo.Nebula.DocumentManagement.Query.Application.Dto.ESignatureDocumentRequirementModelDto class representing the document requirement if found; 
                otherwise, `null`.
     */
    getESignatureDocumentRequirementModelById(journeyId: string, requirementId: string, x_TENANT_ID: string): Promise<ESignatureDocumentRequirementModelDtoServiceResponse>;
    /**
     * Gets all eSignature Document Requirement Statuses for an Entity Id and Journey Id.
     * @param entityId The entity identifier.
     * @param journeyId The journey identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.ESignatureDocumentRequirementModelDto class representing the document requirement statuses if found; 
                otherwise, `null`.
     */
    getAllESignatureRequirementModelsByEntityIdAndJourneyId(entityId: string, journeyId: string, x_TENANT_ID: string): Promise<ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse>;
    /**
     * Gets a eSignatureDocumentRequirementModel by Journey Id and DocumentDataKey
     * @param journeyId The journey identifier.
     * @param documentDataKey The requirement identifier defined in policy configuration.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A Fenergo.Nebula.DocumentManagement.Query.Application.Dto.ESignatureDocumentRequirementModelDto class representing the document requirement if found; 
                otherwise, `null`.
     */
    getESignatureDocumentRequirementModelByJourneyIdandDocumentDataKey(journeyId: string, documentDataKey: string, x_TENANT_ID: string): Promise<ESignatureDocumentRequirementModelDtoServiceResponse>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/documentmanagementquery";

    }

    /**
     * Get a document by id and tenant
     * @param id Id of an existing document
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return An instance of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentModelDto class representing the document metadata with the specified 
                id, if found; otherwise, `null`.
     */
    getDocumentModelById(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DocumentModelDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/documentmanagement/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDocumentModelById(_response);
        });
    }

    protected processGetDocumentModelById(response: AxiosResponse): Promise<DocumentModelDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentModelDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<DocumentModelDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentModelDtoServiceResponse>(null as any);
    }

    /**
     * Get all documents by journey id
     * @param journeyId Journey id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentModelDto class representing the document metadata with the specified 
                journeyId, if found; otherwise, `null`.
     */
    getAllDocumentsByJourneyId(journeyId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DocumentModelDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/documentmanagement/journey/{journeyId}";
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllDocumentsByJourneyId(_response);
        });
    }

    protected processGetAllDocumentsByJourneyId(response: AxiosResponse): Promise<DocumentModelDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentModelDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<DocumentModelDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentModelDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get all documents by entity id
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentModelDto class representing the document metadata with the specified 
                entityId, if found; otherwise, `null`.
     */
    getAllDocumentsByEntityId(entityId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DocumentModelDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/documentmanagement/entity/{entityId}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllDocumentsByEntityId(_response);
        });
    }

    protected processGetAllDocumentsByEntityId(response: AxiosResponse): Promise<DocumentModelDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentModelDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<DocumentModelDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentModelDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets all Document Models for an Entity Id and Journey Id.
     * @param entityId The entity identifier.
     * @param journeyId The journey identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentModelDto class representing the document models if found; 
                otherwise, `null`.
     */
    getAllModelsByEntityIdAndJourneyId(entityId: string, journeyId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DocumentModelDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/documentmanagement/entity/{entityId}/journey/{journeyId}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllModelsByEntityIdAndJourneyId(_response);
        });
    }

    protected processGetAllModelsByEntityIdAndJourneyId(response: AxiosResponse): Promise<DocumentModelDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentModelDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<DocumentModelDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentModelDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Method to get a signed URL from S3
     * @param id Id of document
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return An url to access the file uploaded for the document with the specified 
                id, if found; otherwise, `null`.
     */
    getSignedUrl(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<StringServiceResponse> {
        let url_ = this.baseUrl + "/api/documentmanagement/signedurl/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSignedUrl(_response);
        });
    }

    protected processGetSignedUrl(response: AxiosResponse): Promise<StringServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringServiceResponse.fromJS(resultData200);
            return Promise.resolve<StringServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringServiceResponse>(null as any);
    }

    /**
     * Get all supported mime types when uploading a file in the document requirements.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of string of mime types
     */
    mimeTypesAllowed(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<StringIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/documentmanagement/mimeTypesAllowed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMimeTypesAllowed(_response);
        });
    }

    protected processMimeTypesAllowed(response: AxiosResponse): Promise<StringIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<StringIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets all requirements for a Journey Id.
     * @param journeyId The journey identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentRequirementModelDto class representing the document requirements if found; 
                otherwise, `null`.
     */
    getAllRequirementModelsByJourneyId(journeyId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DocumentRequirementModelDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/documentrequirement/{journeyId}";
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRequirementModelsByJourneyId(_response);
        });
    }

    protected processGetAllRequirementModelsByJourneyId(response: AxiosResponse): Promise<DocumentRequirementModelDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentRequirementModelDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<DocumentRequirementModelDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentRequirementModelDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets a DocumentRequirementModel by Journey Id and Requirement Id
     * @param journeyId The journey identifier.
     * @param requirementId The requirement identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentRequirementModelDto class representing the document requirement if found; 
                otherwise, `null`.
     */
    getDocumentRequirementModelById(journeyId: string, requirementId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DocumentRequirementModelDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/documentrequirement/{journeyId}/{requirementId}";
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        if (requirementId === undefined || requirementId === null)
            throw new Error("The parameter 'requirementId' must be defined.");
        url_ = url_.replace("{requirementId}", encodeURIComponent("" + requirementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDocumentRequirementModelById(_response);
        });
    }

    protected processGetDocumentRequirementModelById(response: AxiosResponse): Promise<DocumentRequirementModelDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentRequirementModelDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<DocumentRequirementModelDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentRequirementModelDtoServiceResponse>(null as any);
    }

    /**
     * Gets all Document Requirement Statuses for an Entity Id and Journey Id.
     * @param entityId The entity identifier.
     * @param journeyId The journey identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentRequirementModelDto class representing the document requirement statuses if found; 
                otherwise, `null`.
     */
    getAllRequirementModelsByEntityIdAndJourneyId(entityId: string, journeyId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DocumentRequirementModelDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/documentrequirement/entity/{entityId}/journey/{journeyId}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRequirementModelsByEntityIdAndJourneyId(_response);
        });
    }

    protected processGetAllRequirementModelsByEntityIdAndJourneyId(response: AxiosResponse): Promise<DocumentRequirementModelDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentRequirementModelDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<DocumentRequirementModelDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentRequirementModelDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets all Document Requirement Statuses for an Entity Id.
     * @param entityId The entity identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentRequirementModelDto class representing the document requirement statuses if found; 
                otherwise, `null`.
     */
    getAllRequirementModelsByEntityId(entityId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DocumentRequirementModelDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/documentrequirement/entity/{entityId}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRequirementModelsByEntityId(_response);
        });
    }

    protected processGetAllRequirementModelsByEntityId(response: AxiosResponse): Promise<DocumentRequirementModelDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentRequirementModelDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<DocumentRequirementModelDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentRequirementModelDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets a DocumentRequirementModel by Journey Id and DocumentDataKey
     * @param journeyId The journey identifier.
     * @param documentDataKey The requirement identifier defined in policy configuration.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A Fenergo.Nebula.DocumentManagement.Query.Application.Dto.DocumentRequirementModelDto class representing the document requirement if found; 
                otherwise, `null`.
     */
    getDocumentRequirementModelByJourneyIdandDocumentDataKey(journeyId: string, documentDataKey: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DocumentRequirementModelDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/documentrequirement/journey/{journeyId}/dataKey/{documentDataKey}";
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        if (documentDataKey === undefined || documentDataKey === null)
            throw new Error("The parameter 'documentDataKey' must be defined.");
        url_ = url_.replace("{documentDataKey}", encodeURIComponent("" + documentDataKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDocumentRequirementModelByJourneyIdandDocumentDataKey(_response);
        });
    }

    protected processGetDocumentRequirementModelByJourneyIdandDocumentDataKey(response: AxiosResponse): Promise<DocumentRequirementModelDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentRequirementModelDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<DocumentRequirementModelDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentRequirementModelDtoServiceResponse>(null as any);
    }

    /**
     * Get Configuration
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Instance of Fenergo.Nebula.DocumentManagement.Query.Application.Dto.eSignatureConfiguration.ConfigurationDto class containing configuration information.
     */
    getConfiguration(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<ConfigurationDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/esignatureconfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConfiguration(_response);
        });
    }

    protected processGetConfiguration(response: AxiosResponse): Promise<ConfigurationDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ConfigurationDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<ConfigurationDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Invalid request.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConfigurationDtoServiceResponse>(null as any);
    }

    /**
     * Get provider configuration
     * @param providerId The ID of provider
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Instance of Fenergo.Nebula.DocumentManagement.Query.Application.Dto.eSignatureConfiguration.ProviderConfigurationDto class containing provider configuration information.
     */
    getProviderConfiguration(providerId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<ProviderConfigurationDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/esignatureconfiguration/provider/{providerId}";
        if (providerId === undefined || providerId === null)
            throw new Error("The parameter 'providerId' must be defined.");
        url_ = url_.replace("{providerId}", encodeURIComponent("" + providerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProviderConfiguration(_response);
        });
    }

    protected processGetProviderConfiguration(response: AxiosResponse): Promise<ProviderConfigurationDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProviderConfigurationDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<ProviderConfigurationDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Invalid request.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProviderConfigurationDtoServiceResponse>(null as any);
    }

    /**
     * Gets all requirements for a Journey Id.
     * @param journeyId The journey identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.ESignatureDocumentRequirementModelDto class representing the document requirements if found; 
                otherwise, `null`.
     */
    getAllESignatureRequirementModelsByJourneyId(journeyId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/esignaturedocumentrequirement/{journeyId}";
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllESignatureRequirementModelsByJourneyId(_response);
        });
    }

    protected processGetAllESignatureRequirementModelsByJourneyId(response: AxiosResponse): Promise<ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets a eSignatureDocumentRequirementModel by Journey Id and Requirement Id
     * @param journeyId The journey identifier.
     * @param requirementId The requirement identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A Fenergo.Nebula.DocumentManagement.Query.Application.Dto.ESignatureDocumentRequirementModelDto class representing the document requirement if found; 
                otherwise, `null`.
     */
    getESignatureDocumentRequirementModelById(journeyId: string, requirementId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<ESignatureDocumentRequirementModelDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/esignaturedocumentrequirement/{journeyId}/{requirementId}";
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        if (requirementId === undefined || requirementId === null)
            throw new Error("The parameter 'requirementId' must be defined.");
        url_ = url_.replace("{requirementId}", encodeURIComponent("" + requirementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetESignatureDocumentRequirementModelById(_response);
        });
    }

    protected processGetESignatureDocumentRequirementModelById(response: AxiosResponse): Promise<ESignatureDocumentRequirementModelDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ESignatureDocumentRequirementModelDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<ESignatureDocumentRequirementModelDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ESignatureDocumentRequirementModelDtoServiceResponse>(null as any);
    }

    /**
     * Gets all eSignature Document Requirement Statuses for an Entity Id and Journey Id.
     * @param entityId The entity identifier.
     * @param journeyId The journey identifier.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A list of the Fenergo.Nebula.DocumentManagement.Query.Application.Dto.ESignatureDocumentRequirementModelDto class representing the document requirement statuses if found; 
                otherwise, `null`.
     */
    getAllESignatureRequirementModelsByEntityIdAndJourneyId(entityId: string, journeyId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/esignaturedocumentrequirement/entity/{entityId}/journey/{journeyId}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllESignatureRequirementModelsByEntityIdAndJourneyId(_response);
        });
    }

    protected processGetAllESignatureRequirementModelsByEntityIdAndJourneyId(response: AxiosResponse): Promise<ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets a eSignatureDocumentRequirementModel by Journey Id and DocumentDataKey
     * @param journeyId The journey identifier.
     * @param documentDataKey The requirement identifier defined in policy configuration.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return A Fenergo.Nebula.DocumentManagement.Query.Application.Dto.ESignatureDocumentRequirementModelDto class representing the document requirement if found; 
                otherwise, `null`.
     */
    getESignatureDocumentRequirementModelByJourneyIdandDocumentDataKey(journeyId: string, documentDataKey: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<ESignatureDocumentRequirementModelDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/esignaturedocumentrequirement/journey/{journeyId}/dataKey/{documentDataKey}";
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        if (documentDataKey === undefined || documentDataKey === null)
            throw new Error("The parameter 'documentDataKey' must be defined.");
        url_ = url_.replace("{documentDataKey}", encodeURIComponent("" + documentDataKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetESignatureDocumentRequirementModelByJourneyIdandDocumentDataKey(_response);
        });
    }

    protected processGetESignatureDocumentRequirementModelByJourneyIdandDocumentDataKey(response: AxiosResponse): Promise<ESignatureDocumentRequirementModelDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ESignatureDocumentRequirementModelDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<ESignatureDocumentRequirementModelDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ESignatureDocumentRequirementModelDtoServiceResponse>(null as any);
    }
}

/** DTO representing access layers attached */
export class AccessLayerDto implements IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;

    constructor(data?: IAccessLayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["geographic"])) {
                this.geographic = [] as any;
                for (let item of _data["geographic"])
                    this.geographic!.push(item);
            }
            if (Array.isArray(_data["businessRelated"])) {
                this.businessRelated = [] as any;
                for (let item of _data["businessRelated"])
                    this.businessRelated!.push(item);
            }
        }
    }

    static fromJS(data: any): AccessLayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.geographic)) {
            data["geographic"] = [];
            for (let item of this.geographic)
                data["geographic"].push(item);
        }
        if (Array.isArray(this.businessRelated)) {
            data["businessRelated"] = [];
            for (let item of this.businessRelated)
                data["businessRelated"].push(item);
        }
        return data;
    }
}

/** DTO representing access layers attached */
export interface IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;
}

/** Class which representing configuration providers */
export class ConfigurationDto implements IConfigurationDto {
    /** Collection of configured providers */
    providersConfiguration?: ProviderConfigurationDto[] | undefined;

    constructor(data?: IConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["providersConfiguration"])) {
                this.providersConfiguration = [] as any;
                for (let item of _data["providersConfiguration"])
                    this.providersConfiguration!.push(ProviderConfigurationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.providersConfiguration)) {
            data["providersConfiguration"] = [];
            for (let item of this.providersConfiguration)
                data["providersConfiguration"].push(item.toJSON());
        }
        return data;
    }
}

/** Class which representing configuration providers */
export interface IConfigurationDto {
    /** Collection of configured providers */
    providersConfiguration?: ProviderConfigurationDto[] | undefined;
}

export class ConfigurationDtoServiceResponse implements IConfigurationDtoServiceResponse {
    /** Class which representing configuration providers */
    data?: ConfigurationDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IConfigurationDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ConfigurationDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConfigurationDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConfigurationDtoServiceResponse {
    /** Class which representing configuration providers */
    data?: ConfigurationDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Document metadata */
export class DocumentModelDto implements IDocumentModelDto {
    /** The unique identifier of the document */
    id?: string;
    /** File name */
    fileName?: string | undefined;
    /** List of Document Requirement Ids that the document is linked to */
    documentRequirementIds?: string[] | undefined;
    /** The unique identifier of the document requirement that the document is linked to */
    documentDataKey?: string | undefined;
    /** Document type */
    documentType?: string | undefined;
    /** The Reference key for the physical File */
    documentKey?: string | undefined;
    /** The status of the uploaded document */
    status?: string | undefined;
    /** The Id of the journey the Document is uploaded against */
    journeyId?: string | undefined;
    /** Custom document properties. */
    properties?: { [key: string]: Property; } | undefined;
    /** Document access layers. Can be only additive in relation to the PolicyEnforcedAccessLayers */
    accessLayers?: AccessLayerDto | undefined;
    /** Access layers enforced by policy. The minimal set of access layers. The property is immutable */
    policyEnforcedAccessLayers?: AccessLayerDto | undefined;
    /** Flag indicating if current user has required access layers to access document model
If false, the sensitive properties with be masked by replacing with null or empty values */
    hasRequiredAccessLayers?: boolean;

    constructor(data?: IDocumentModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            if (Array.isArray(_data["documentRequirementIds"])) {
                this.documentRequirementIds = [] as any;
                for (let item of _data["documentRequirementIds"])
                    this.documentRequirementIds!.push(item);
            }
            this.documentDataKey = _data["documentDataKey"];
            this.documentType = _data["documentType"];
            this.documentKey = _data["documentKey"];
            this.status = _data["status"];
            this.journeyId = _data["journeyId"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? Property.fromJS(_data["properties"][key]) : new Property();
                }
            }
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.policyEnforcedAccessLayers = _data["policyEnforcedAccessLayers"] ? AccessLayerDto.fromJS(_data["policyEnforcedAccessLayers"]) : <any>undefined;
            this.hasRequiredAccessLayers = _data["hasRequiredAccessLayers"];
        }
    }

    static fromJS(data: any): DocumentModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        if (Array.isArray(this.documentRequirementIds)) {
            data["documentRequirementIds"] = [];
            for (let item of this.documentRequirementIds)
                data["documentRequirementIds"].push(item);
        }
        data["documentDataKey"] = this.documentDataKey;
        data["documentType"] = this.documentType;
        data["documentKey"] = this.documentKey;
        data["status"] = this.status;
        data["journeyId"] = this.journeyId;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["policyEnforcedAccessLayers"] = this.policyEnforcedAccessLayers ? this.policyEnforcedAccessLayers.toJSON() : <any>undefined;
        data["hasRequiredAccessLayers"] = this.hasRequiredAccessLayers;
        return data;
    }
}

/** Document metadata */
export interface IDocumentModelDto {
    /** The unique identifier of the document */
    id?: string;
    /** File name */
    fileName?: string | undefined;
    /** List of Document Requirement Ids that the document is linked to */
    documentRequirementIds?: string[] | undefined;
    /** The unique identifier of the document requirement that the document is linked to */
    documentDataKey?: string | undefined;
    /** Document type */
    documentType?: string | undefined;
    /** The Reference key for the physical File */
    documentKey?: string | undefined;
    /** The status of the uploaded document */
    status?: string | undefined;
    /** The Id of the journey the Document is uploaded against */
    journeyId?: string | undefined;
    /** Custom document properties. */
    properties?: { [key: string]: Property; } | undefined;
    /** Document access layers. Can be only additive in relation to the PolicyEnforcedAccessLayers */
    accessLayers?: AccessLayerDto | undefined;
    /** Access layers enforced by policy. The minimal set of access layers. The property is immutable */
    policyEnforcedAccessLayers?: AccessLayerDto | undefined;
    /** Flag indicating if current user has required access layers to access document model
If false, the sensitive properties with be masked by replacing with null or empty values */
    hasRequiredAccessLayers?: boolean;
}

export class DocumentModelDtoIEnumerableServiceResponse implements IDocumentModelDtoIEnumerableServiceResponse {
    data?: DocumentModelDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDocumentModelDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DocumentModelDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentModelDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentModelDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDocumentModelDtoIEnumerableServiceResponse {
    data?: DocumentModelDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class DocumentModelDtoServiceResponse implements IDocumentModelDtoServiceResponse {
    /** Document metadata */
    data?: DocumentModelDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDocumentModelDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DocumentModelDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentModelDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentModelDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDocumentModelDtoServiceResponse {
    /** Document metadata */
    data?: DocumentModelDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Document Requirement History */
export class DocumentRequirementHistoryDto implements IDocumentRequirementHistoryDto {
    /** The Status of the Document Requirement */
    status?: string | undefined;
    /** The date that the Document Requirement was last updated */
    lastUpdated?: Date;
    /** A comment relating to the Document Requirement Status change */
    comment?: string | undefined;
    /** The deferral date of the requirement. This is only set if Status is "Defer Requested" */
    deferUntil?: Date | undefined;

    constructor(data?: IDocumentRequirementHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.deferUntil = _data["deferUntil"] ? new Date(_data["deferUntil"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentRequirementHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["deferUntil"] = this.deferUntil ? this.deferUntil.toISOString() : <any>undefined;
        return data;
    }
}

/** Document Requirement History */
export interface IDocumentRequirementHistoryDto {
    /** The Status of the Document Requirement */
    status?: string | undefined;
    /** The date that the Document Requirement was last updated */
    lastUpdated?: Date;
    /** A comment relating to the Document Requirement Status change */
    comment?: string | undefined;
    /** The deferral date of the requirement. This is only set if Status is "Defer Requested" */
    deferUntil?: Date | undefined;
}

/** Document Requirement data */
export class DocumentRequirementModelDto implements IDocumentRequirementModelDto {
    /** The unique identifier of the document requirement status */
    id?: string;
    /** The Id of the requirement the document requirement status belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status belongs to */
    entityId?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The history of the requirement containing all updates to the status */
    history?: DocumentRequirementHistoryDto[] | undefined;
    /** Document requirement access layers */
    accessLayers?: AccessLayerDto | undefined;
    /** Flag indicating if current user has required access layers to access document requirement model
If false, the sensitive properties with be masked by replacing with null or empty values */
    hasRequiredAccessLayers?: boolean;

    constructor(data?: IDocumentRequirementModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requirementId = _data["requirementId"];
            this.requirementName = _data["requirementName"];
            this.documentDataKey = _data["documentDataKey"];
            this.journeyId = _data["journeyId"];
            this.entityId = _data["entityId"];
            this.isMandatory = _data["isMandatory"];
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(DocumentRequirementHistoryDto.fromJS(item));
            }
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.hasRequiredAccessLayers = _data["hasRequiredAccessLayers"];
        }
    }

    static fromJS(data: any): DocumentRequirementModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requirementId"] = this.requirementId;
        data["requirementName"] = this.requirementName;
        data["documentDataKey"] = this.documentDataKey;
        data["journeyId"] = this.journeyId;
        data["entityId"] = this.entityId;
        data["isMandatory"] = this.isMandatory;
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["hasRequiredAccessLayers"] = this.hasRequiredAccessLayers;
        return data;
    }
}

/** Document Requirement data */
export interface IDocumentRequirementModelDto {
    /** The unique identifier of the document requirement status */
    id?: string;
    /** The Id of the requirement the document requirement status belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status belongs to */
    entityId?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The history of the requirement containing all updates to the status */
    history?: DocumentRequirementHistoryDto[] | undefined;
    /** Document requirement access layers */
    accessLayers?: AccessLayerDto | undefined;
    /** Flag indicating if current user has required access layers to access document requirement model
If false, the sensitive properties with be masked by replacing with null or empty values */
    hasRequiredAccessLayers?: boolean;
}

export class DocumentRequirementModelDtoIEnumerableServiceResponse implements IDocumentRequirementModelDtoIEnumerableServiceResponse {
    data?: DocumentRequirementModelDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDocumentRequirementModelDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DocumentRequirementModelDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentRequirementModelDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementModelDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDocumentRequirementModelDtoIEnumerableServiceResponse {
    data?: DocumentRequirementModelDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class DocumentRequirementModelDtoServiceResponse implements IDocumentRequirementModelDtoServiceResponse {
    /** Document Requirement data */
    data?: DocumentRequirementModelDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDocumentRequirementModelDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DocumentRequirementModelDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentRequirementModelDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementModelDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDocumentRequirementModelDtoServiceResponse {
    /** Document Requirement data */
    data?: DocumentRequirementModelDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Document Requirement data for ESignature */
export class ESignatureDocumentRequirementModelDto implements IESignatureDocumentRequirementModelDto {
    /** The unique identifier of the document requirement status */
    id?: string;
    /** The Id of the requirement the document requirement status belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status belongs to */
    entityId?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The history of the requirement containing all updates to the status */
    history?: DocumentRequirementHistoryDto[] | undefined;
    /** Document requirement access layers */
    accessLayers?: AccessLayerDto | undefined;
    /** Flag indicating if current user has required access layers to access document requirement model
If false, the sensitive properties with be masked by replacing with null or empty values */
    hasRequiredAccessLayers?: boolean;
    /** The ID of request from external eSignature service */
    envelopeId?: string | undefined;
    /** The sent date to external eSignature service */
    dateSent?: Date | undefined;
    /** The last notification date from external eSignature service */
    lastNotificationDate?: Date | undefined;
    /** List of persons needed to sign off */
    signers?: SignerDto[] | undefined;

    constructor(data?: IESignatureDocumentRequirementModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requirementId = _data["requirementId"];
            this.requirementName = _data["requirementName"];
            this.documentDataKey = _data["documentDataKey"];
            this.journeyId = _data["journeyId"];
            this.entityId = _data["entityId"];
            this.isMandatory = _data["isMandatory"];
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(DocumentRequirementHistoryDto.fromJS(item));
            }
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.hasRequiredAccessLayers = _data["hasRequiredAccessLayers"];
            this.envelopeId = _data["envelopeId"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.lastNotificationDate = _data["lastNotificationDate"] ? new Date(_data["lastNotificationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["signers"])) {
                this.signers = [] as any;
                for (let item of _data["signers"])
                    this.signers!.push(SignerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ESignatureDocumentRequirementModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ESignatureDocumentRequirementModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requirementId"] = this.requirementId;
        data["requirementName"] = this.requirementName;
        data["documentDataKey"] = this.documentDataKey;
        data["journeyId"] = this.journeyId;
        data["entityId"] = this.entityId;
        data["isMandatory"] = this.isMandatory;
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["hasRequiredAccessLayers"] = this.hasRequiredAccessLayers;
        data["envelopeId"] = this.envelopeId;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["lastNotificationDate"] = this.lastNotificationDate ? this.lastNotificationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.signers)) {
            data["signers"] = [];
            for (let item of this.signers)
                data["signers"].push(item.toJSON());
        }
        return data;
    }
}

/** Document Requirement data for ESignature */
export interface IESignatureDocumentRequirementModelDto {
    /** The unique identifier of the document requirement status */
    id?: string;
    /** The Id of the requirement the document requirement status belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status belongs to */
    entityId?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The history of the requirement containing all updates to the status */
    history?: DocumentRequirementHistoryDto[] | undefined;
    /** Document requirement access layers */
    accessLayers?: AccessLayerDto | undefined;
    /** Flag indicating if current user has required access layers to access document requirement model
If false, the sensitive properties with be masked by replacing with null or empty values */
    hasRequiredAccessLayers?: boolean;
    /** The ID of request from external eSignature service */
    envelopeId?: string | undefined;
    /** The sent date to external eSignature service */
    dateSent?: Date | undefined;
    /** The last notification date from external eSignature service */
    lastNotificationDate?: Date | undefined;
    /** List of persons needed to sign off */
    signers?: SignerDto[] | undefined;
}

export class ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse implements IESignatureDocumentRequirementModelDtoIEnumerableServiceResponse {
    data?: ESignatureDocumentRequirementModelDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IESignatureDocumentRequirementModelDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ESignatureDocumentRequirementModelDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ESignatureDocumentRequirementModelDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IESignatureDocumentRequirementModelDtoIEnumerableServiceResponse {
    data?: ESignatureDocumentRequirementModelDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ESignatureDocumentRequirementModelDtoServiceResponse implements IESignatureDocumentRequirementModelDtoServiceResponse {
    /** Document Requirement data for ESignature */
    data?: ESignatureDocumentRequirementModelDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IESignatureDocumentRequirementModelDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ESignatureDocumentRequirementModelDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ESignatureDocumentRequirementModelDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ESignatureDocumentRequirementModelDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IESignatureDocumentRequirementModelDtoServiceResponse {
    /** Document Requirement data for ESignature */
    data?: ESignatureDocumentRequirementModelDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ObjectServiceResponse implements IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class Property implements IProperty {
    value?: string | undefined;
    type?: string | undefined;
    customTypeId?: string;
    properties?: { [key: string]: Property; } | undefined;

    constructor(data?: IProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.customTypeId = _data["customTypeId"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? Property.fromJS(_data["properties"][key]) : new Property();
                }
            }
        }
    }

    static fromJS(data: any): Property {
        data = typeof data === 'object' ? data : {};
        let result = new Property();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["customTypeId"] = this.customTypeId;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IProperty {
    value?: string | undefined;
    type?: string | undefined;
    customTypeId?: string;
    properties?: { [key: string]: Property; } | undefined;
}

/** DTO representing provider configuration */
export class ProviderConfigurationDto implements IProviderConfigurationDto {
    /** The unique identifier of the provider */
    id?: string;
    /** The name of the provider */
    name?: string | undefined;
    /** The status of the provider */
    status?: string | undefined;
    /** The flag which indicates if provider has been enabled */
    enabled?: boolean;
    /** Collection of local configuration parameters */
    localConfiguration?: SchemaEntry[] | undefined;
    /** Collection of global configuration parameters */
    globalConfiguration?: { [key: string]: any; } | undefined;

    constructor(data?: IProviderConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["localConfiguration"])) {
                this.localConfiguration = [] as any;
                for (let item of _data["localConfiguration"])
                    this.localConfiguration!.push(SchemaEntry.fromJS(item));
            }
            if (_data["globalConfiguration"]) {
                this.globalConfiguration = {} as any;
                for (let key in _data["globalConfiguration"]) {
                    if (_data["globalConfiguration"].hasOwnProperty(key))
                        (<any>this.globalConfiguration)![key] = _data["globalConfiguration"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProviderConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["status"] = this.status;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.localConfiguration)) {
            data["localConfiguration"] = [];
            for (let item of this.localConfiguration)
                data["localConfiguration"].push(item.toJSON());
        }
        if (this.globalConfiguration) {
            data["globalConfiguration"] = {};
            for (let key in this.globalConfiguration) {
                if (this.globalConfiguration.hasOwnProperty(key))
                    (<any>data["globalConfiguration"])[key] = (<any>this.globalConfiguration)[key];
            }
        }
        return data;
    }
}

/** DTO representing provider configuration */
export interface IProviderConfigurationDto {
    /** The unique identifier of the provider */
    id?: string;
    /** The name of the provider */
    name?: string | undefined;
    /** The status of the provider */
    status?: string | undefined;
    /** The flag which indicates if provider has been enabled */
    enabled?: boolean;
    /** Collection of local configuration parameters */
    localConfiguration?: SchemaEntry[] | undefined;
    /** Collection of global configuration parameters */
    globalConfiguration?: { [key: string]: any; } | undefined;
}

export class ProviderConfigurationDtoServiceResponse implements IProviderConfigurationDtoServiceResponse {
    /** DTO representing provider configuration */
    data?: ProviderConfigurationDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IProviderConfigurationDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ProviderConfigurationDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProviderConfigurationDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderConfigurationDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProviderConfigurationDtoServiceResponse {
    /** DTO representing provider configuration */
    data?: ProviderConfigurationDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class SchemaEntry implements ISchemaEntry {
    name?: string | undefined;
    friendlyName?: string | undefined;
    value?: any | undefined;
    type?: ValueType;
    masked?: boolean;
    nullable?: boolean;
    mandatory?: boolean;

    constructor(data?: ISchemaEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.friendlyName = _data["friendlyName"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.masked = _data["masked"];
            this.nullable = _data["nullable"];
            this.mandatory = _data["mandatory"];
        }
    }

    static fromJS(data: any): SchemaEntry {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["friendlyName"] = this.friendlyName;
        data["value"] = this.value;
        data["type"] = this.type;
        data["masked"] = this.masked;
        data["nullable"] = this.nullable;
        data["mandatory"] = this.mandatory;
        return data;
    }
}

export interface ISchemaEntry {
    name?: string | undefined;
    friendlyName?: string | undefined;
    value?: any | undefined;
    type?: ValueType;
    masked?: boolean;
    nullable?: boolean;
    mandatory?: boolean;
}

export class ServiceResponse implements IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ServiceResponseMessage implements IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

export interface IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;
}

export class SignerDto implements ISignerDto {
    signerType?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    relationship?: string | undefined;
    hasSigned?: boolean | undefined;
    order?: number;

    constructor(data?: ISignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signerType = _data["signerType"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.relationship = _data["relationship"];
            this.hasSigned = _data["hasSigned"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): SignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signerType"] = this.signerType;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["relationship"] = this.relationship;
        data["hasSigned"] = this.hasSigned;
        data["order"] = this.order;
        return data;
    }
}

export interface ISignerDto {
    signerType?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    relationship?: string | undefined;
    hasSigned?: boolean | undefined;
    order?: number;
}

export class StringIEnumerableServiceResponse implements IStringIEnumerableServiceResponse {
    data?: string[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IStringIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StringIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStringIEnumerableServiceResponse {
    data?: string[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class StringServiceResponse implements IStringServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IStringServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StringServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStringServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ValidationErrorModel implements IValidationErrorModel {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    errorCode?: string | undefined;

    constructor(data?: IValidationErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            this.attemptedValue = _data["attemptedValue"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ValidationErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

export interface IValidationErrorModel {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    errorCode?: string | undefined;
}

export class ValidationErrorModelListServiceResponse implements IValidationErrorModelListServiceResponse {
    data?: ValidationErrorModel[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IValidationErrorModelListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ValidationErrorModel.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationErrorModelListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModelListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IValidationErrorModelListServiceResponse {
    data?: ValidationErrorModel[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export enum ValueType {
    StringMultiline = "StringMultiline",
    String = "String",
    Number = "Number",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}