//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * Get entities by attributes
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Query entities request
     * @return Success. The list of entities is returned
     */
    getEntitiesList(x_TENANT_ID: string, body: EntityQueryDtoServiceRequest | undefined): Promise<EntityDtoListServiceResponse>;
    /**
     * Get paged list of entities
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Query entities request
     * @return Success. The list of entities is returned
     */
    getEntitiesPagedList(x_TENANT_ID: string, body: EntityQueryPagedDtoServiceRequest | undefined): Promise<EntityDtoListServiceResponse>;
    /**
     * Get entity by id
     * @param id Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. An instance of entity is returned
     */
    getEntityById(id: string, x_TENANT_ID: string): Promise<EntityDtoServiceResponse>;
    /**
     * Search for entity duplicates
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Search for duplicates request
     * @return Success. The list of entities is returned
     */
    searchForDuplicates(x_TENANT_ID: string, body: SearchForDuplicatesDtoServiceRequest | undefined): Promise<EntityDtoListServiceResponse>;
    /**
     * Advanced search for entities
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Search for entities request
     * @return Success. The list of entities is returned
     */
    entityAdvancedSearch(x_TENANT_ID: string, body: EntityAdvancedSearchDtoServiceRequest | undefined): Promise<AdvancedSearchResultDtoServiceResponse>;
    /**
     * Entity advanced search results file
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Search for entities file request
     * @return Success. Response represents file search result
     */
    entityAdvancedSearchFile(x_TENANT_ID: string, body: EntityAdvancedSearchFileDtoServiceRequest | undefined): Promise<AdvancedSearchFileResultDtoServiceResponse>;
    /**
     * Multi-search for entity duplicates
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Multi-search for duplicates request
     * @return Success. Set of possible duplicated entities returned
     */
    multiSearchForDuplicates(x_TENANT_ID: string, body: MultiSearchForDuplicatesDtoServiceRequest | undefined): Promise<StringEntityDtoListDictionaryServiceResponse>;
    /**
     * Search entities by name
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Search entities by name request
     * @return Success. The list of entities is returned
     */
    searchByName(x_TENANT_ID: string, body: EntitySearchByNameDtoServiceRequest | undefined): Promise<EntityDtoListServiceResponse>;
    /**
     * Get entities snapshot by Journey Id and Task Id
     * @param journeyId Journey Id id
     * @param taskId Task Id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of entities is returned
     */
    getEntitiesSnapshotByTaskId(journeyId: string, taskId: string, x_TENANT_ID: string): Promise<EntitySnapshotDtoIEnumerableServiceResponse>;
    /**
     * Get entity in specified version
     * @param entityId Entity id
     * @param entityVersion Version
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success
     */
    getEntityVersion(entityId: string, entityVersion: number, x_TENANT_ID: string): Promise<EntityDtoServiceResponse>;
    /**
     * Get entity drafts
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of entity drafts is returned
     */
    getEntityDrafts(entityId: string, x_TENANT_ID: string): Promise<EntityDraftDtoIEnumerableServiceResponse>;
    /**
     * Get entity draft by id
     * @param id Entity draft id
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Entity draft is returned
     */
    getEntityDraftById(id: string, entityId: string, x_TENANT_ID: string): Promise<EntityDraftDtoServiceResponse>;
    /**
     * Search entity drafts
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Request with search criteria
     * @return Success. The list of entity draft is returned
     */
    searchEntityDrafts(x_TENANT_ID: string, body: SearchEntityDraftsDtoServiceRequest | undefined): Promise<EntityDraftDtoIEnumerableServiceResponse>;
    /**
     * Get indexed entity properties
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of indexed entity properties is returned
     */
    getIndexedEntityProperties(x_TENANT_ID: string): Promise<EntityIndexConfigurationDtoIEnumerableServiceResponse>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/entitydataquery";

    }

    /**
     * Get entities by attributes
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Query entities request
     * @return Success. The list of entities is returned
     */
    getEntitiesList(x_TENANT_ID: string, body: EntityQueryDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<EntityDtoListServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/getentitieslist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEntitiesList(_response);
        });
    }

    protected processGetEntitiesList(response: AxiosResponse): Promise<EntityDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityDtoListServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntityDtoListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDtoListServiceResponse>(null as any);
    }

    /**
     * Get paged list of entities
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Query entities request
     * @return Success. The list of entities is returned
     */
    getEntitiesPagedList(x_TENANT_ID: string, body: EntityQueryPagedDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<EntityDtoListServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/getentitiespagedlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEntitiesPagedList(_response);
        });
    }

    protected processGetEntitiesPagedList(response: AxiosResponse): Promise<EntityDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityDtoListServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntityDtoListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDtoListServiceResponse>(null as any);
    }

    /**
     * Get entity by id
     * @param id Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. An instance of entity is returned
     */
    getEntityById(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<EntityDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEntityById(_response);
        });
    }

    protected processGetEntityById(response: AxiosResponse): Promise<EntityDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntityDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDtoServiceResponse>(null as any);
    }

    /**
     * Search for entity duplicates
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Search for duplicates request
     * @return Success. The list of entities is returned
     */
    searchForDuplicates(x_TENANT_ID: string, body: SearchForDuplicatesDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<EntityDtoListServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/searchforduplicates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchForDuplicates(_response);
        });
    }

    protected processSearchForDuplicates(response: AxiosResponse): Promise<EntityDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityDtoListServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntityDtoListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDtoListServiceResponse>(null as any);
    }

    /**
     * Advanced search for entities
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Search for entities request
     * @return Success. The list of entities is returned
     */
    entityAdvancedSearch(x_TENANT_ID: string, body: EntityAdvancedSearchDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<AdvancedSearchResultDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/entityadvancedsearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityAdvancedSearch(_response);
        });
    }

    protected processEntityAdvancedSearch(response: AxiosResponse): Promise<AdvancedSearchResultDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdvancedSearchResultDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<AdvancedSearchResultDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AdvancedSearchResultDtoServiceResponse>(null as any);
    }

    /**
     * Entity advanced search results file
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Search for entities file request
     * @return Success. Response represents file search result
     */
    entityAdvancedSearchFile(x_TENANT_ID: string, body: EntityAdvancedSearchFileDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<AdvancedSearchFileResultDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/entityadvancedsearch/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityAdvancedSearchFile(_response);
        });
    }

    protected processEntityAdvancedSearchFile(response: AxiosResponse): Promise<AdvancedSearchFileResultDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdvancedSearchFileResultDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<AdvancedSearchFileResultDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AdvancedSearchFileResultDtoServiceResponse>(null as any);
    }

    /**
     * Multi-search for entity duplicates
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Multi-search for duplicates request
     * @return Success. Set of possible duplicated entities returned
     */
    multiSearchForDuplicates(x_TENANT_ID: string, body: MultiSearchForDuplicatesDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<StringEntityDtoListDictionaryServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/multisearchforduplicates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMultiSearchForDuplicates(_response);
        });
    }

    protected processMultiSearchForDuplicates(response: AxiosResponse): Promise<StringEntityDtoListDictionaryServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringEntityDtoListDictionaryServiceResponse.fromJS(resultData200);
            return Promise.resolve<StringEntityDtoListDictionaryServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringEntityDtoListDictionaryServiceResponse>(null as any);
    }

    /**
     * Search entities by name
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Search entities by name request
     * @return Success. The list of entities is returned
     */
    searchByName(x_TENANT_ID: string, body: EntitySearchByNameDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<EntityDtoListServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/searchbyname";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchByName(_response);
        });
    }

    protected processSearchByName(response: AxiosResponse): Promise<EntityDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityDtoListServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntityDtoListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDtoListServiceResponse>(null as any);
    }

    /**
     * Get entities snapshot by Journey Id and Task Id
     * @param journeyId Journey Id id
     * @param taskId Task Id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of entities is returned
     */
    getEntitiesSnapshotByTaskId(journeyId: string, taskId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<EntitySnapshotDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/journey/{journeyId}/task/{taskId}";
        if (journeyId === undefined || journeyId === null)
            throw new Error("The parameter 'journeyId' must be defined.");
        url_ = url_.replace("{journeyId}", encodeURIComponent("" + journeyId));
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEntitiesSnapshotByTaskId(_response);
        });
    }

    protected processGetEntitiesSnapshotByTaskId(response: AxiosResponse): Promise<EntitySnapshotDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntitySnapshotDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntitySnapshotDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntitySnapshotDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get entity in specified version
     * @param entityId Entity id
     * @param entityVersion Version
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success
     */
    getEntityVersion(entityId: string, entityVersion: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<EntityDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/{entityId}/version/{entityVersion}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (entityVersion === undefined || entityVersion === null)
            throw new Error("The parameter 'entityVersion' must be defined.");
        url_ = url_.replace("{entityVersion}", encodeURIComponent("" + entityVersion));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEntityVersion(_response);
        });
    }

    protected processGetEntityVersion(response: AxiosResponse): Promise<EntityDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntityDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 202) {
            const _responseText = response.data;
            return throwException("Success. Entity version retrieved", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDtoServiceResponse>(null as any);
    }

    /**
     * Get entity drafts
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of entity drafts is returned
     */
    getEntityDrafts(entityId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<EntityDraftDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/{entityId}/draft";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEntityDrafts(_response);
        });
    }

    protected processGetEntityDrafts(response: AxiosResponse): Promise<EntityDraftDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityDraftDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntityDraftDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDraftDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get entity draft by id
     * @param id Entity draft id
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Entity draft is returned
     */
    getEntityDraftById(id: string, entityId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<EntityDraftDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/entity/{entityId}/draft/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEntityDraftById(_response);
        });
    }

    protected processGetEntityDraftById(response: AxiosResponse): Promise<EntityDraftDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityDraftDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntityDraftDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDraftDtoServiceResponse>(null as any);
    }

    /**
     * Search entity drafts
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Request with search criteria
     * @return Success. The list of entity draft is returned
     */
    searchEntityDrafts(x_TENANT_ID: string, body: SearchEntityDraftsDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<EntityDraftDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/drafts-in-scope/searchentitydrafts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchEntityDrafts(_response);
        });
    }

    protected processSearchEntityDrafts(response: AxiosResponse): Promise<EntityDraftDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityDraftDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntityDraftDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDraftDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get indexed entity properties
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of indexed entity properties is returned
     */
    getIndexedEntityProperties(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<EntityIndexConfigurationDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/entity-index-configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIndexedEntityProperties(_response);
        });
    }

    protected processGetIndexedEntityProperties(response: AxiosResponse): Promise<EntityIndexConfigurationDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityIndexConfigurationDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<EntityIndexConfigurationDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityIndexConfigurationDtoIEnumerableServiceResponse>(null as any);
    }
}

/** Response DTO representing associated access layers */
export class AccessLayerDto implements IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;

    constructor(data?: IAccessLayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["geographic"])) {
                this.geographic = [] as any;
                for (let item of _data["geographic"])
                    this.geographic!.push(item);
            }
            if (Array.isArray(_data["businessRelated"])) {
                this.businessRelated = [] as any;
                for (let item of _data["businessRelated"])
                    this.businessRelated!.push(item);
            }
        }
    }

    static fromJS(data: any): AccessLayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.geographic)) {
            data["geographic"] = [];
            for (let item of this.geographic)
                data["geographic"].push(item);
        }
        if (Array.isArray(this.businessRelated)) {
            data["businessRelated"] = [];
            for (let item of this.businessRelated)
                data["businessRelated"].push(item);
        }
        return data;
    }
}

/** Response DTO representing associated access layers */
export interface IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;
}

/** Response representing file search result */
export class AdvancedSearchFileResultDto implements IAdvancedSearchFileResultDto {
    /** Search result file URL */
    searchResultFileUrl?: string | undefined;
    /** Items count */
    count?: number;

    constructor(data?: IAdvancedSearchFileResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchResultFileUrl = _data["searchResultFileUrl"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): AdvancedSearchFileResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvancedSearchFileResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchResultFileUrl"] = this.searchResultFileUrl;
        data["count"] = this.count;
        return data;
    }
}

/** Response representing file search result */
export interface IAdvancedSearchFileResultDto {
    /** Search result file URL */
    searchResultFileUrl?: string | undefined;
    /** Items count */
    count?: number;
}

/** Service response data */
export class AdvancedSearchFileResultDtoServiceResponse implements IAdvancedSearchFileResultDtoServiceResponse {
    /** The service response DTO */
    data?: AdvancedSearchFileResultDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IAdvancedSearchFileResultDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AdvancedSearchFileResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdvancedSearchFileResultDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdvancedSearchFileResultDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IAdvancedSearchFileResultDtoServiceResponse {
    /** The service response DTO */
    data?: AdvancedSearchFileResultDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class AdvancedSearchPropertyDto implements IAdvancedSearchPropertyDto {
    /** Property type. */
    propertyType?: string | undefined;
    /** The value. */
    value?: string | undefined;
    /** Elastic Search Boost */
    boost?: number | undefined;
    /** Nested properties to search by. */
    properties?: { [key: string]: AdvancedSearchPropertyDto; } | undefined;

    constructor(data?: IAdvancedSearchPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyType = _data["propertyType"];
            this.value = _data["value"];
            this.boost = _data["boost"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? AdvancedSearchPropertyDto.fromJS(_data["properties"][key]) : new AdvancedSearchPropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): AdvancedSearchPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvancedSearchPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyType"] = this.propertyType;
        data["value"] = this.value;
        data["boost"] = this.boost;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IAdvancedSearchPropertyDto {
    /** Property type. */
    propertyType?: string | undefined;
    /** The value. */
    value?: string | undefined;
    /** Elastic Search Boost */
    boost?: number | undefined;
    /** Nested properties to search by. */
    properties?: { [key: string]: AdvancedSearchPropertyDto; } | undefined;
}

/** Response DTO representing advanced search result */
export class AdvancedSearchResultDto implements IAdvancedSearchResultDto {
    /** Items for the current page. */
    items?: EntityDto[] | undefined;
    /** Total count of items. */
    totalItems?: number;

    constructor(data?: IAdvancedSearchResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityDto.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): AdvancedSearchResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvancedSearchResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

/** Response DTO representing advanced search result */
export interface IAdvancedSearchResultDto {
    /** Items for the current page. */
    items?: EntityDto[] | undefined;
    /** Total count of items. */
    totalItems?: number;
}

/** Service response data */
export class AdvancedSearchResultDtoServiceResponse implements IAdvancedSearchResultDtoServiceResponse {
    /** The service response DTO */
    data?: AdvancedSearchResultDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IAdvancedSearchResultDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AdvancedSearchResultDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdvancedSearchResultDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdvancedSearchResultDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IAdvancedSearchResultDtoServiceResponse {
    /** The service response DTO */
    data?: AdvancedSearchResultDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Contains Data Group object which have specified properties */
export class CollectionDto implements ICollectionDto {
    /** Data Group properties */
    properties?: { [key: string]: string; } | undefined;

    constructor(data?: ICollectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

/** Contains Data Group object which have specified properties */
export interface ICollectionDto {
    /** Data Group properties */
    properties?: { [key: string]: string; } | undefined;
}

/** Abstraction that represents properties */
export class PropertyDto implements IPropertyDto {
    /** Type of properties. */
    readonly type?: PropertyType;

    protected _discriminator: string;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "PropertyDto";
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "Collection") {
            let result = new CollectionPropertyDto();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "Custom") {
            let result = new CustomPropertyDto();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "Single") {
            let result = new SinglePropertyDto();
            result.init(data);
            return result;
        }
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["type"] = this.type;
        return data;
    }
}

/** Abstraction that represents properties */
export interface IPropertyDto {
    /** Type of properties. */
    type?: PropertyType;
}

/** Contains Data Group objects which are a collection of specific type */
export class CollectionPropertyDto extends PropertyDto implements ICollectionPropertyDto {
    /** Data Group Id */
    dataGroupId?: string;
    /** Data Group version number. */
    dataGroupVersionNumber?: number | undefined;
    /** The collections of Data Groups */
    collections?: { [key: string]: CollectionDto; } | undefined;

    constructor(data?: ICollectionPropertyDto) {
        super(data);
        this._discriminator = "Collection";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dataGroupId = _data["dataGroupId"];
            this.dataGroupVersionNumber = _data["dataGroupVersionNumber"];
            if (_data["collections"]) {
                this.collections = {} as any;
                for (let key in _data["collections"]) {
                    if (_data["collections"].hasOwnProperty(key))
                        (<any>this.collections)![key] = _data["collections"][key] ? CollectionDto.fromJS(_data["collections"][key]) : new CollectionDto();
                }
            }
        }
    }

    static fromJS(data: any): CollectionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataGroupId"] = this.dataGroupId;
        data["dataGroupVersionNumber"] = this.dataGroupVersionNumber;
        if (this.collections) {
            data["collections"] = {};
            for (let key in this.collections) {
                if (this.collections.hasOwnProperty(key))
                    (<any>data["collections"])[key] = this.collections[key] ? this.collections[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

/** Contains Data Group objects which are a collection of specific type */
export interface ICollectionPropertyDto extends IPropertyDto {
    /** Data Group Id */
    dataGroupId?: string;
    /** Data Group version number. */
    dataGroupVersionNumber?: number | undefined;
    /** The collections of Data Groups */
    collections?: { [key: string]: CollectionDto; } | undefined;
}

export class CustomPropertyDto extends PropertyDto implements ICustomPropertyDto {
    customTypeId?: string;
    value?: string | undefined;
    properties?: { [key: string]: PropertyDto; } | undefined;

    constructor(data?: ICustomPropertyDto) {
        super(data);
        this._discriminator = "Custom";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customTypeId = _data["customTypeId"];
            this.value = _data["value"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): CustomPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTypeId"] = this.customTypeId;
        data["value"] = this.value;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICustomPropertyDto extends IPropertyDto {
    customTypeId?: string;
    value?: string | undefined;
    properties?: { [key: string]: PropertyDto; } | undefined;
}

/** Request DTO to query for entity duplicates */
export class EntityAdvancedSearchDto implements IEntityAdvancedSearchDto {
    /** Elastic Search Min score to match */
    minScore?: number | undefined;
    /** Entity type */
    type!: string;
    /** Specification of search result page */
    pager!: PagerDto;
    /** Entity properties to check for duplicates */
    properties!: { [key: string]: AdvancedSearchPropertyDto; };

    constructor(data?: IEntityAdvancedSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.pager = new PagerDto();
            this.properties = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minScore = _data["minScore"];
            this.type = _data["type"];
            this.pager = _data["pager"] ? PagerDto.fromJS(_data["pager"]) : new PagerDto();
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? AdvancedSearchPropertyDto.fromJS(_data["properties"][key]) : new AdvancedSearchPropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): EntityAdvancedSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityAdvancedSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minScore"] = this.minScore;
        data["type"] = this.type;
        data["pager"] = this.pager ? this.pager.toJSON() : <any>undefined;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Request DTO to query for entity duplicates */
export interface IEntityAdvancedSearchDto {
    /** Elastic Search Min score to match */
    minScore?: number | undefined;
    /** Entity type */
    type: string;
    /** Specification of search result page */
    pager: PagerDto;
    /** Entity properties to check for duplicates */
    properties: { [key: string]: AdvancedSearchPropertyDto; };
}

/** Service request data */
export class EntityAdvancedSearchDtoServiceRequest implements IEntityAdvancedSearchDtoServiceRequest {
    /** The service request DTO */
    data?: EntityAdvancedSearchDto | undefined;

    constructor(data?: IEntityAdvancedSearchDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityAdvancedSearchDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityAdvancedSearchDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntityAdvancedSearchDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IEntityAdvancedSearchDtoServiceRequest {
    /** The service request DTO */
    data?: EntityAdvancedSearchDto | undefined;
}

/** Request DTO to query for entity duplicates */
export class EntityAdvancedSearchFileDto implements IEntityAdvancedSearchFileDto {
    /** Elastic Search Min score to match */
    minScore?: number | undefined;
    /** Entity type */
    type?: string | undefined;
    /** Total items to get */
    totalItems?: number;
    /** Headers visible in the file */
    headers?: { [key: string]: string; } | undefined;
    /** Filters based on property values */
    properties?: { [key: string]: AdvancedSearchPropertyDto; } | undefined;

    constructor(data?: IEntityAdvancedSearchFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minScore = _data["minScore"];
            this.type = _data["type"];
            this.totalItems = _data["totalItems"];
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key];
                }
            }
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? AdvancedSearchPropertyDto.fromJS(_data["properties"][key]) : new AdvancedSearchPropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): EntityAdvancedSearchFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityAdvancedSearchFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minScore"] = this.minScore;
        data["type"] = this.type;
        data["totalItems"] = this.totalItems;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Request DTO to query for entity duplicates */
export interface IEntityAdvancedSearchFileDto {
    /** Elastic Search Min score to match */
    minScore?: number | undefined;
    /** Entity type */
    type?: string | undefined;
    /** Total items to get */
    totalItems?: number;
    /** Headers visible in the file */
    headers?: { [key: string]: string; } | undefined;
    /** Filters based on property values */
    properties?: { [key: string]: AdvancedSearchPropertyDto; } | undefined;
}

/** Service request data */
export class EntityAdvancedSearchFileDtoServiceRequest implements IEntityAdvancedSearchFileDtoServiceRequest {
    /** The service request DTO */
    data?: EntityAdvancedSearchFileDto | undefined;

    constructor(data?: IEntityAdvancedSearchFileDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityAdvancedSearchFileDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityAdvancedSearchFileDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntityAdvancedSearchFileDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IEntityAdvancedSearchFileDtoServiceRequest {
    /** The service request DTO */
    data?: EntityAdvancedSearchFileDto | undefined;
}

/** Response DTO representing entity draft data */
export class EntityDraftDto implements IEntityDraftDto {
    /** Entity draft id */
    id?: string;
    /** Source entity id */
    sourceEntityId?: string;
    /** Source entity version */
    sourceEntityVersion?: number;
    /** Journey id */
    journeyId?: string;
    /** Entity draft type */
    type?: string | undefined;
    /** Entity draft properties */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Entity draft risk */
    risk?: EntityRiskDto | undefined;
    /** Entity draft role */
    role?: EntityRoleDto | undefined;
    /** Status */
    status?: string | undefined;
    /** Created date */
    created?: Date | undefined;
    /** List of Jurisdictions associated with EntityDraft */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of Risk Configurations associated with EntityDraft */
    riskVersion?: RiskConfigurationVersionDto | undefined;
    /** Entity access layers determining the access to the entity Draft */
    accessLayers?: AccessLayerDto | undefined;
    /** Version number for given EntityDraft */
    version?: number;

    constructor(data?: IEntityDraftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sourceEntityId = _data["sourceEntityId"];
            this.sourceEntityVersion = _data["sourceEntityVersion"];
            this.journeyId = _data["journeyId"];
            this.type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
            this.risk = _data["risk"] ? EntityRiskDto.fromJS(_data["risk"]) : <any>undefined;
            this.role = _data["role"] ? EntityRoleDto.fromJS(_data["role"]) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(VersionedJurisdictionDto.fromJS(item));
            }
            this.riskVersion = _data["riskVersion"] ? RiskConfigurationVersionDto.fromJS(_data["riskVersion"]) : <any>undefined;
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): EntityDraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceEntityId"] = this.sourceEntityId;
        data["sourceEntityVersion"] = this.sourceEntityVersion;
        data["journeyId"] = this.journeyId;
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        data["risk"] = this.risk ? this.risk.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item.toJSON());
        }
        data["riskVersion"] = this.riskVersion ? this.riskVersion.toJSON() : <any>undefined;
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing entity draft data */
export interface IEntityDraftDto {
    /** Entity draft id */
    id?: string;
    /** Source entity id */
    sourceEntityId?: string;
    /** Source entity version */
    sourceEntityVersion?: number;
    /** Journey id */
    journeyId?: string;
    /** Entity draft type */
    type?: string | undefined;
    /** Entity draft properties */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Entity draft risk */
    risk?: EntityRiskDto | undefined;
    /** Entity draft role */
    role?: EntityRoleDto | undefined;
    /** Status */
    status?: string | undefined;
    /** Created date */
    created?: Date | undefined;
    /** List of Jurisdictions associated with EntityDraft */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of Risk Configurations associated with EntityDraft */
    riskVersion?: RiskConfigurationVersionDto | undefined;
    /** Entity access layers determining the access to the entity Draft */
    accessLayers?: AccessLayerDto | undefined;
    /** Version number for given EntityDraft */
    version?: number;
}

/** Service response data */
export class EntityDraftDtoIEnumerableServiceResponse implements IEntityDraftDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: EntityDraftDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEntityDraftDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EntityDraftDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityDraftDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDraftDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IEntityDraftDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: EntityDraftDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Service response data */
export class EntityDraftDtoServiceResponse implements IEntityDraftDtoServiceResponse {
    /** The service response DTO */
    data?: EntityDraftDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEntityDraftDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityDraftDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityDraftDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDraftDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IEntityDraftDtoServiceResponse {
    /** The service response DTO */
    data?: EntityDraftDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing entity data */
export class EntityDto implements IEntityDto {
    /** Entity id */
    id?: string;
    /** Entity type */
    type?: string | undefined;
    /** Entity properties */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Entity risk */
    risk?: EntityRiskDto | undefined;
    /** Entity role */
    role?: EntityRoleDto | undefined;
    /** Entity status */
    status?: EntityStatus;
    /** User id
Deprecated - not to use in new code */
    userId?: string | undefined;
    /** Created date */
    created?: Date | undefined;
    /** Id from external system to migrate data */
    alternateId?: string | undefined;
    /** List of Journeys for given entity */
    journeys?: EntityJourneyDto[] | undefined;
    /** Entity access layers determining the access to the entity */
    accessLayers?: AccessLayerDto | undefined;
    /** List of jurisdictions entity is in scope for */
    inScopeJurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of offboarded jurisdictions */
    offboardedJurisdictions?: OffboardedJurisdictionDto[] | undefined;
    /** Version number for given Entity */
    version?: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
            this.risk = _data["risk"] ? EntityRiskDto.fromJS(_data["risk"]) : <any>undefined;
            this.role = _data["role"] ? EntityRoleDto.fromJS(_data["role"]) : <any>undefined;
            this.status = _data["status"];
            this.userId = _data["userId"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.alternateId = _data["alternateId"];
            if (Array.isArray(_data["journeys"])) {
                this.journeys = [] as any;
                for (let item of _data["journeys"])
                    this.journeys!.push(EntityJourneyDto.fromJS(item));
            }
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            if (Array.isArray(_data["inScopeJurisdictions"])) {
                this.inScopeJurisdictions = [] as any;
                for (let item of _data["inScopeJurisdictions"])
                    this.inScopeJurisdictions!.push(VersionedJurisdictionDto.fromJS(item));
            }
            if (Array.isArray(_data["offboardedJurisdictions"])) {
                this.offboardedJurisdictions = [] as any;
                for (let item of _data["offboardedJurisdictions"])
                    this.offboardedJurisdictions!.push(OffboardedJurisdictionDto.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        data["risk"] = this.risk ? this.risk.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["userId"] = this.userId;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["alternateId"] = this.alternateId;
        if (Array.isArray(this.journeys)) {
            data["journeys"] = [];
            for (let item of this.journeys)
                data["journeys"].push(item.toJSON());
        }
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        if (Array.isArray(this.inScopeJurisdictions)) {
            data["inScopeJurisdictions"] = [];
            for (let item of this.inScopeJurisdictions)
                data["inScopeJurisdictions"].push(item.toJSON());
        }
        if (Array.isArray(this.offboardedJurisdictions)) {
            data["offboardedJurisdictions"] = [];
            for (let item of this.offboardedJurisdictions)
                data["offboardedJurisdictions"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing entity data */
export interface IEntityDto {
    /** Entity id */
    id?: string;
    /** Entity type */
    type?: string | undefined;
    /** Entity properties */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Entity risk */
    risk?: EntityRiskDto | undefined;
    /** Entity role */
    role?: EntityRoleDto | undefined;
    /** Entity status */
    status?: EntityStatus;
    /** User id
Deprecated - not to use in new code */
    userId?: string | undefined;
    /** Created date */
    created?: Date | undefined;
    /** Id from external system to migrate data */
    alternateId?: string | undefined;
    /** List of Journeys for given entity */
    journeys?: EntityJourneyDto[] | undefined;
    /** Entity access layers determining the access to the entity */
    accessLayers?: AccessLayerDto | undefined;
    /** List of jurisdictions entity is in scope for */
    inScopeJurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of offboarded jurisdictions */
    offboardedJurisdictions?: OffboardedJurisdictionDto[] | undefined;
    /** Version number for given Entity */
    version?: number;
}

/** Service response data */
export class EntityDtoListServiceResponse implements IEntityDtoListServiceResponse {
    /** The service response DTO */
    data?: EntityDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEntityDtoListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EntityDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityDtoListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IEntityDtoListServiceResponse {
    /** The service response DTO */
    data?: EntityDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Service response data */
export class EntityDtoServiceResponse implements IEntityDtoServiceResponse {
    /** The service response DTO */
    data?: EntityDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEntityDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IEntityDtoServiceResponse {
    /** The service response DTO */
    data?: EntityDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing entity index configuration */
export class EntityIndexConfigurationDto implements IEntityIndexConfigurationDto {
    /** Indexed Entity Property id */
    id?: string;
    /** Entity type */
    entityType?: string | undefined;
    /** Indexed Entity Property name */
    propertyName?: string | undefined;
    /** Indexed Entity Property operation status (InProgress, Complete) */
    reindexingStatus?: PropertyReindexingStatus;
    /** Jurisdiction name */
    jurisdiction?: string | undefined;

    constructor(data?: IEntityIndexConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityType = _data["entityType"];
            this.propertyName = _data["propertyName"];
            this.reindexingStatus = _data["reindexingStatus"];
            this.jurisdiction = _data["jurisdiction"];
        }
    }

    static fromJS(data: any): EntityIndexConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityIndexConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityType"] = this.entityType;
        data["propertyName"] = this.propertyName;
        data["reindexingStatus"] = this.reindexingStatus;
        data["jurisdiction"] = this.jurisdiction;
        return data;
    }
}

/** Response DTO representing entity index configuration */
export interface IEntityIndexConfigurationDto {
    /** Indexed Entity Property id */
    id?: string;
    /** Entity type */
    entityType?: string | undefined;
    /** Indexed Entity Property name */
    propertyName?: string | undefined;
    /** Indexed Entity Property operation status (InProgress, Complete) */
    reindexingStatus?: PropertyReindexingStatus;
    /** Jurisdiction name */
    jurisdiction?: string | undefined;
}

/** Service response data */
export class EntityIndexConfigurationDtoIEnumerableServiceResponse implements IEntityIndexConfigurationDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: EntityIndexConfigurationDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEntityIndexConfigurationDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EntityIndexConfigurationDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityIndexConfigurationDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntityIndexConfigurationDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IEntityIndexConfigurationDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: EntityIndexConfigurationDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing entity journey data */
export class EntityJourneyDto implements IEntityJourneyDto {
    /** Type of Journey */
    journeyType?: string | undefined;
    /** Journey id */
    journeyId?: string;
    /** Entity status */
    journeyStatus?: string | undefined;

    constructor(data?: IEntityJourneyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeyType = _data["journeyType"];
            this.journeyId = _data["journeyId"];
            this.journeyStatus = _data["journeyStatus"];
        }
    }

    static fromJS(data: any): EntityJourneyDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityJourneyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeyType"] = this.journeyType;
        data["journeyId"] = this.journeyId;
        data["journeyStatus"] = this.journeyStatus;
        return data;
    }
}

/** Response DTO representing entity journey data */
export interface IEntityJourneyDto {
    /** Type of Journey */
    journeyType?: string | undefined;
    /** Journey id */
    journeyId?: string;
    /** Entity status */
    journeyStatus?: string | undefined;
}

/** Request DTO to query for a list of entities based on the criteria */
export class EntityQueryCriteriaDto implements IEntityQueryCriteriaDto {
    /** List of entity criteria to fetch the data for */
    criteria?: { [key: string]: any; } | undefined;
    /** List of Range values used to determine the Entities */
    ranges?: RangeDto[] | undefined;

    constructor(data?: IEntityQueryCriteriaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["criteria"]) {
                this.criteria = {} as any;
                for (let key in _data["criteria"]) {
                    if (_data["criteria"].hasOwnProperty(key))
                        (<any>this.criteria)![key] = _data["criteria"][key];
                }
            }
            if (Array.isArray(_data["ranges"])) {
                this.ranges = [] as any;
                for (let item of _data["ranges"])
                    this.ranges!.push(RangeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityQueryCriteriaDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityQueryCriteriaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.criteria) {
            data["criteria"] = {};
            for (let key in this.criteria) {
                if (this.criteria.hasOwnProperty(key))
                    (<any>data["criteria"])[key] = (<any>this.criteria)[key];
            }
        }
        if (Array.isArray(this.ranges)) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        return data;
    }
}

/** Request DTO to query for a list of entities based on the criteria */
export interface IEntityQueryCriteriaDto {
    /** List of entity criteria to fetch the data for */
    criteria?: { [key: string]: any; } | undefined;
    /** List of Range values used to determine the Entities */
    ranges?: RangeDto[] | undefined;
}

/** Service request data */
export class EntityQueryCriteriaDtoServiceRequest implements IEntityQueryCriteriaDtoServiceRequest {
    /** The service request DTO */
    data!: EntityQueryCriteriaDto;

    constructor(data?: IEntityQueryCriteriaDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new EntityQueryCriteriaDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityQueryCriteriaDto.fromJS(_data["data"]) : new EntityQueryCriteriaDto();
        }
    }

    static fromJS(data: any): EntityQueryCriteriaDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntityQueryCriteriaDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IEntityQueryCriteriaDtoServiceRequest {
    /** The service request DTO */
    data: EntityQueryCriteriaDto;
}

/** Request DTO to query for a list of entities */
export class EntityQueryDto implements IEntityQueryDto {
    /** List of entity ids to fetch */
    ids?: string[] | undefined;
    /** List of entity attributes to fetch the data for */
    attributes?: string[] | undefined;

    constructor(data?: IEntityQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(item);
            }
        }
    }

    static fromJS(data: any): EntityQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item);
        }
        return data;
    }
}

/** Request DTO to query for a list of entities */
export interface IEntityQueryDto {
    /** List of entity ids to fetch */
    ids?: string[] | undefined;
    /** List of entity attributes to fetch the data for */
    attributes?: string[] | undefined;
}

/** Service request data */
export class EntityQueryDtoServiceRequest implements IEntityQueryDtoServiceRequest {
    /** The service request DTO */
    data?: EntityQueryDto | undefined;

    constructor(data?: IEntityQueryDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityQueryDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityQueryDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntityQueryDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IEntityQueryDtoServiceRequest {
    /** The service request DTO */
    data?: EntityQueryDto | undefined;
}

/** Request DTO to query for a paged list of entities */
export class EntityQueryPagedDto implements IEntityQueryPagedDto {
    /** Specification of search result page */
    pager?: PagerDto | undefined;
    /** List of entity attributes to fetch the data for */
    attributes?: string[] | undefined;

    constructor(data?: IEntityQueryPagedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pager = _data["pager"] ? PagerDto.fromJS(_data["pager"]) : <any>undefined;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(item);
            }
        }
    }

    static fromJS(data: any): EntityQueryPagedDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityQueryPagedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pager"] = this.pager ? this.pager.toJSON() : <any>undefined;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item);
        }
        return data;
    }
}

/** Request DTO to query for a paged list of entities */
export interface IEntityQueryPagedDto {
    /** Specification of search result page */
    pager?: PagerDto | undefined;
    /** List of entity attributes to fetch the data for */
    attributes?: string[] | undefined;
}

/** Service request data */
export class EntityQueryPagedDtoServiceRequest implements IEntityQueryPagedDtoServiceRequest {
    /** The service request DTO */
    data?: EntityQueryPagedDto | undefined;

    constructor(data?: IEntityQueryPagedDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityQueryPagedDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityQueryPagedDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntityQueryPagedDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IEntityQueryPagedDtoServiceRequest {
    /** The service request DTO */
    data?: EntityQueryPagedDto | undefined;
}

/** Response DTO representing the entity risk data */
export class EntityRiskDto implements IEntityRiskDto {
    /** Risk category */
    riskCategory?: string | undefined;
    /** Risk level */
    riskLevel?: number | undefined;

    constructor(data?: IEntityRiskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.riskCategory = _data["riskCategory"];
            this.riskLevel = _data["riskLevel"];
        }
    }

    static fromJS(data: any): EntityRiskDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityRiskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["riskCategory"] = this.riskCategory;
        data["riskLevel"] = this.riskLevel;
        return data;
    }
}

/** Response DTO representing the entity risk data */
export interface IEntityRiskDto {
    /** Risk category */
    riskCategory?: string | undefined;
    /** Risk level */
    riskLevel?: number | undefined;
}

/** Response DTO representing the entity role data */
export class EntityRoleDto implements IEntityRoleDto {
    /** Role of the entity */
    name?: string | undefined;

    constructor(data?: IEntityRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EntityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

/** Response DTO representing the entity role data */
export interface IEntityRoleDto {
    /** Role of the entity */
    name?: string | undefined;
}

/** Request DTO to query for a list of entities by name */
export class EntitySearchByNameDto implements IEntitySearchByNameDto {
    /** Entity name for search */
    name?: string | undefined;
    /** Specification of search result page */
    pager?: PagerDto | undefined;

    constructor(data?: IEntitySearchByNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.pager = _data["pager"] ? PagerDto.fromJS(_data["pager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntitySearchByNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntitySearchByNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["pager"] = this.pager ? this.pager.toJSON() : <any>undefined;
        return data;
    }
}

/** Request DTO to query for a list of entities by name */
export interface IEntitySearchByNameDto {
    /** Entity name for search */
    name?: string | undefined;
    /** Specification of search result page */
    pager?: PagerDto | undefined;
}

/** Service request data */
export class EntitySearchByNameDtoServiceRequest implements IEntitySearchByNameDtoServiceRequest {
    /** The service request DTO */
    data?: EntitySearchByNameDto | undefined;

    constructor(data?: IEntitySearchByNameDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntitySearchByNameDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntitySearchByNameDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntitySearchByNameDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IEntitySearchByNameDtoServiceRequest {
    /** The service request DTO */
    data?: EntitySearchByNameDto | undefined;
}

/** Response DTO representing core entity data at a specific time */
export class EntitySnapshotDto implements IEntitySnapshotDto {
    /** Entity id */
    id?: string;
    /** Entity type */
    type?: string | undefined;
    /** Entity properties */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Entity role */
    role?: EntityRoleDto | undefined;
    /** Created date */
    created?: Date | undefined;
    /** Entity access layers determining the access to the entity */
    accessLayers?: AccessLayerDto | undefined;

    constructor(data?: IEntitySnapshotDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
            this.role = _data["role"] ? EntityRoleDto.fromJS(_data["role"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntitySnapshotDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntitySnapshotDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        return data;
    }
}

/** Response DTO representing core entity data at a specific time */
export interface IEntitySnapshotDto {
    /** Entity id */
    id?: string;
    /** Entity type */
    type?: string | undefined;
    /** Entity properties */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Entity role */
    role?: EntityRoleDto | undefined;
    /** Created date */
    created?: Date | undefined;
    /** Entity access layers determining the access to the entity */
    accessLayers?: AccessLayerDto | undefined;
}

/** Service response data */
export class EntitySnapshotDtoIEnumerableServiceResponse implements IEntitySnapshotDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: EntitySnapshotDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEntitySnapshotDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EntitySnapshotDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntitySnapshotDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntitySnapshotDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IEntitySnapshotDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: EntitySnapshotDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Service response data */
export class EntitySnapshotDtoServiceResponse implements IEntitySnapshotDtoServiceResponse {
    /** The service response DTO */
    data?: EntitySnapshotDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEntitySnapshotDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntitySnapshotDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntitySnapshotDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntitySnapshotDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IEntitySnapshotDtoServiceResponse {
    /** The service response DTO */
    data?: EntitySnapshotDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export enum EntityStatus {
    _0 = 0,
    _1 = 1,
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ProblemDetails";
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "HttpValidationProblemDetails") {
            let result = new HttpValidationProblemDetails();
            result.init(data);
            return result;
        }
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    readonly errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
        this._discriminator = "HttpValidationProblemDetails";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                (<any>this).errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>(<any>this).errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

/** Request DTO to multi-search for entity duplicates */
export class MultiSearchForDuplicatesDto implements IMultiSearchForDuplicatesDto {
    /** Dictionary of search of entity duplicates criteria */
    searchForDuplicatesDict?: { [key: string]: SearchForDuplicatesDto; } | undefined;

    constructor(data?: IMultiSearchForDuplicatesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["searchForDuplicatesDict"]) {
                this.searchForDuplicatesDict = {} as any;
                for (let key in _data["searchForDuplicatesDict"]) {
                    if (_data["searchForDuplicatesDict"].hasOwnProperty(key))
                        (<any>this.searchForDuplicatesDict)![key] = _data["searchForDuplicatesDict"][key] ? SearchForDuplicatesDto.fromJS(_data["searchForDuplicatesDict"][key]) : new SearchForDuplicatesDto();
                }
            }
        }
    }

    static fromJS(data: any): MultiSearchForDuplicatesDto {
        data = typeof data === 'object' ? data : {};
        let result = new MultiSearchForDuplicatesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.searchForDuplicatesDict) {
            data["searchForDuplicatesDict"] = {};
            for (let key in this.searchForDuplicatesDict) {
                if (this.searchForDuplicatesDict.hasOwnProperty(key))
                    (<any>data["searchForDuplicatesDict"])[key] = this.searchForDuplicatesDict[key] ? this.searchForDuplicatesDict[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Request DTO to multi-search for entity duplicates */
export interface IMultiSearchForDuplicatesDto {
    /** Dictionary of search of entity duplicates criteria */
    searchForDuplicatesDict?: { [key: string]: SearchForDuplicatesDto; } | undefined;
}

/** Service request data */
export class MultiSearchForDuplicatesDtoServiceRequest implements IMultiSearchForDuplicatesDtoServiceRequest {
    /** The service request DTO */
    data?: MultiSearchForDuplicatesDto | undefined;

    constructor(data?: IMultiSearchForDuplicatesDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? MultiSearchForDuplicatesDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MultiSearchForDuplicatesDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MultiSearchForDuplicatesDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IMultiSearchForDuplicatesDtoServiceRequest {
    /** The service request DTO */
    data?: MultiSearchForDuplicatesDto | undefined;
}

/** Service response data */
export class ObjectServiceResponse implements IObjectServiceResponse {
    /** The service response DTO */
    data?: any | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IObjectServiceResponse {
    /** The service response DTO */
    data?: any | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing offboarded jurisdiction */
export class OffboardedJurisdictionDto implements IOffboardedJurisdictionDto {
    /** Offboarded jurisdiction */
    jurisdiction?: string | undefined;
    /** Date when jurisdiction was offboarded */
    offboardedOn?: Date;

    constructor(data?: IOffboardedJurisdictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jurisdiction = _data["jurisdiction"];
            this.offboardedOn = _data["offboardedOn"] ? new Date(_data["offboardedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OffboardedJurisdictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OffboardedJurisdictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jurisdiction"] = this.jurisdiction;
        data["offboardedOn"] = this.offboardedOn ? this.offboardedOn.toISOString() : <any>undefined;
        return data;
    }
}

/** Response DTO representing offboarded jurisdiction */
export interface IOffboardedJurisdictionDto {
    /** Offboarded jurisdiction */
    jurisdiction?: string | undefined;
    /** Date when jurisdiction was offboarded */
    offboardedOn?: Date;
}

/** Specification of search result page */
export class PagerDto implements IPagerDto {
    /** Size of the page (result set) */
    size?: number;
    /** Position for the search results to start */
    from?: number;
    /** Column to sort by */
    sortBy?: string | undefined;
    /** Sort Order (Ascending or Descending) */
    sortOrder?: SortOrder;

    constructor(data?: IPagerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.size = _data["size"];
            this.from = _data["from"];
            this.sortBy = _data["sortBy"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): PagerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size;
        data["from"] = this.from;
        data["sortBy"] = this.sortBy;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

/** Specification of search result page */
export interface IPagerDto {
    /** Size of the page (result set) */
    size?: number;
    /** Position for the search results to start */
    from?: number;
    /** Column to sort by */
    sortBy?: string | undefined;
    /** Sort Order (Ascending or Descending) */
    sortOrder?: SortOrder;
}

export enum PropertyReindexingStatus {
    InProgress = "InProgress",
    Complete = "Complete",
}

export enum PropertyType {
    Single = "Single",
    Custom = "Custom",
    Collection = "Collection",
}

/** Request DTO to search for a value within a range */
export class RangeDto implements IRangeDto {
    /** The lower value used in the range criteria */
    from?: string | undefined;
    /** The upper value used in the range criteria */
    to?: string | undefined;
    /** The datakey of the field that is being searched against */
    datekey?: string | undefined;

    constructor(data?: IRangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.to = _data["to"];
            this.datekey = _data["datekey"];
        }
    }

    static fromJS(data: any): RangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["to"] = this.to;
        data["datekey"] = this.datekey;
        return data;
    }
}

/** Request DTO to search for a value within a range */
export interface IRangeDto {
    /** The lower value used in the range criteria */
    from?: string | undefined;
    /** The upper value used in the range criteria */
    to?: string | undefined;
    /** The datakey of the field that is being searched against */
    datekey?: string | undefined;
}

/** Dto to store the risk configuration models and versions used in the Entity Draft */
export class RiskConfigurationVersionDto implements IRiskConfigurationVersionDto {
    /** The list of Risk Models and their versions used in the Entity Draft */
    riskModel?: RiskVersionDto[] | undefined;
    /** The list of Risk Configuration Models and their versions used in the Entity Draft */
    riskConfigurationModel?: RiskVersionDto[] | undefined;
    /** The list of Threshold Models and their versions used in the Entity Draft */
    thresholdModel?: RiskVersionDto[] | undefined;

    constructor(data?: IRiskConfigurationVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["riskModel"])) {
                this.riskModel = [] as any;
                for (let item of _data["riskModel"])
                    this.riskModel!.push(RiskVersionDto.fromJS(item));
            }
            if (Array.isArray(_data["riskConfigurationModel"])) {
                this.riskConfigurationModel = [] as any;
                for (let item of _data["riskConfigurationModel"])
                    this.riskConfigurationModel!.push(RiskVersionDto.fromJS(item));
            }
            if (Array.isArray(_data["thresholdModel"])) {
                this.thresholdModel = [] as any;
                for (let item of _data["thresholdModel"])
                    this.thresholdModel!.push(RiskVersionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RiskConfigurationVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RiskConfigurationVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.riskModel)) {
            data["riskModel"] = [];
            for (let item of this.riskModel)
                data["riskModel"].push(item.toJSON());
        }
        if (Array.isArray(this.riskConfigurationModel)) {
            data["riskConfigurationModel"] = [];
            for (let item of this.riskConfigurationModel)
                data["riskConfigurationModel"].push(item.toJSON());
        }
        if (Array.isArray(this.thresholdModel)) {
            data["thresholdModel"] = [];
            for (let item of this.thresholdModel)
                data["thresholdModel"].push(item.toJSON());
        }
        return data;
    }
}

/** Dto to store the risk configuration models and versions used in the Entity Draft */
export interface IRiskConfigurationVersionDto {
    /** The list of Risk Models and their versions used in the Entity Draft */
    riskModel?: RiskVersionDto[] | undefined;
    /** The list of Risk Configuration Models and their versions used in the Entity Draft */
    riskConfigurationModel?: RiskVersionDto[] | undefined;
    /** The list of Threshold Models and their versions used in the Entity Draft */
    thresholdModel?: RiskVersionDto[] | undefined;
}

/** Stores the Id and the Version of a Risk Configuration Model */
export class RiskVersionDto implements IRiskVersionDto {
    /** The Id of the risk model */
    id?: string;
    /** The version of the model */
    version?: number;

    constructor(data?: IRiskVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): RiskVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RiskVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        return data;
    }
}

/** Stores the Id and the Version of a Risk Configuration Model */
export interface IRiskVersionDto {
    /** The Id of the risk model */
    id?: string;
    /** The version of the model */
    version?: number;
}

/** Request DTO representing entity drafts search criteria */
export class SearchEntityDraftsDto implements ISearchEntityDraftsDto {
    /** Journey id */
    journeyId?: string;
    /** Entity id */
    entityId?: string | undefined;
    /** Entity ids */
    entityIds?: string[] | undefined;

    constructor(data?: ISearchEntityDraftsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeyId = _data["journeyId"];
            this.entityId = _data["entityId"];
            if (Array.isArray(_data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of _data["entityIds"])
                    this.entityIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchEntityDraftsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchEntityDraftsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeyId"] = this.journeyId;
        data["entityId"] = this.entityId;
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        return data;
    }
}

/** Request DTO representing entity drafts search criteria */
export interface ISearchEntityDraftsDto {
    /** Journey id */
    journeyId?: string;
    /** Entity id */
    entityId?: string | undefined;
    /** Entity ids */
    entityIds?: string[] | undefined;
}

/** Service request data */
export class SearchEntityDraftsDtoServiceRequest implements ISearchEntityDraftsDtoServiceRequest {
    /** The service request DTO */
    data?: SearchEntityDraftsDto | undefined;

    constructor(data?: ISearchEntityDraftsDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SearchEntityDraftsDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchEntityDraftsDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchEntityDraftsDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface ISearchEntityDraftsDtoServiceRequest {
    /** The service request DTO */
    data?: SearchEntityDraftsDto | undefined;
}

/** Request DTO to query for entity duplicates */
export class SearchForDuplicatesDto implements ISearchForDuplicatesDto {
    /** Entity type */
    type!: string;
    /** Entity properties to check for duplicates */
    properties!: { [key: string]: string; };

    constructor(data?: ISearchForDuplicatesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SearchForDuplicatesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchForDuplicatesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

/** Request DTO to query for entity duplicates */
export interface ISearchForDuplicatesDto {
    /** Entity type */
    type: string;
    /** Entity properties to check for duplicates */
    properties: { [key: string]: string; };
}

/** Service request data */
export class SearchForDuplicatesDtoServiceRequest implements ISearchForDuplicatesDtoServiceRequest {
    /** The service request DTO */
    data?: SearchForDuplicatesDto | undefined;

    constructor(data?: ISearchForDuplicatesDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SearchForDuplicatesDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchForDuplicatesDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchForDuplicatesDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface ISearchForDuplicatesDtoServiceRequest {
    /** The service request DTO */
    data?: SearchForDuplicatesDto | undefined;
}

/** Service response data */
export class ServiceResponse implements IServiceResponse {
    /** The service response DTO */
    data?: string | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IServiceResponse {
    /** The service response DTO */
    data?: string | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** The message associated to the service response */
export class ServiceResponseMessage implements IServiceResponseMessage {
    /** The message */
    message?: string | undefined;
    /** Type of the message
One of Info, Warning, Error, Forbidden */
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

/** The message associated to the service response */
export interface IServiceResponseMessage {
    /** The message */
    message?: string | undefined;
    /** Type of the message
One of Info, Warning, Error, Forbidden */
    type?: string | undefined;
}

export class SinglePropertyDto extends PropertyDto implements ISinglePropertyDto {
    value?: string | undefined;

    constructor(data?: ISinglePropertyDto) {
        super(data);
        this._discriminator = "Single";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SinglePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SinglePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface ISinglePropertyDto extends IPropertyDto {
    value?: string | undefined;
}

/** Sort Order (Ascending or Descending) */
export enum SortOrder {
    _0 = 0,
    _1 = 1,
}

/** Service response data */
export class StringEntityDtoListDictionaryServiceResponse implements IStringEntityDtoListDictionaryServiceResponse {
    /** The service response DTO */
    data?: { [key: string]: EntityDto[]; } | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IStringEntityDtoListDictionaryServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key] ? _data["data"][key].map((i: any) => EntityDto.fromJS(i)) : <any>undefined;
                }
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StringEntityDtoListDictionaryServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringEntityDtoListDictionaryServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IStringEntityDtoListDictionaryServiceResponse {
    /** The service response DTO */
    data?: { [key: string]: EntityDto[]; } | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Represents the details of validation error */
export class ValidationErrorModel implements IValidationErrorModel {
    /** Name of the property */
    propertyName?: string | undefined;
    /** User friendly error message */
    errorMessage?: string | undefined;
    /** Invalid value */
    attemptedValue?: any | undefined;
    /** Internal error code */
    errorCode?: string | undefined;

    constructor(data?: IValidationErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            this.attemptedValue = _data["attemptedValue"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ValidationErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

/** Represents the details of validation error */
export interface IValidationErrorModel {
    /** Name of the property */
    propertyName?: string | undefined;
    /** User friendly error message */
    errorMessage?: string | undefined;
    /** Invalid value */
    attemptedValue?: any | undefined;
    /** Internal error code */
    errorCode?: string | undefined;
}

/** Service response data */
export class ValidationErrorModelListServiceResponse implements IValidationErrorModelListServiceResponse {
    /** The service response DTO */
    data?: ValidationErrorModel[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IValidationErrorModelListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ValidationErrorModel.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationErrorModelListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModelListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IValidationErrorModelListServiceResponse {
    /** The service response DTO */
    data?: ValidationErrorModel[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class VersionedJurisdictionDto implements IVersionedJurisdictionDto {
    /** Jurisdiction Name */
    jurisdiction?: string | undefined;
    /** Jurisdiction Version Id */
    versionId?: string;

    constructor(data?: IVersionedJurisdictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jurisdiction = _data["jurisdiction"];
            this.versionId = _data["versionId"];
        }
    }

    static fromJS(data: any): VersionedJurisdictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new VersionedJurisdictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jurisdiction"] = this.jurisdiction;
        data["versionId"] = this.versionId;
        return data;
    }
}

export interface IVersionedJurisdictionDto {
    /** Jurisdiction Name */
    jurisdiction?: string | undefined;
    /** Jurisdiction Version Id */
    versionId?: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}