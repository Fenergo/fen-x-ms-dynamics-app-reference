//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * Gets all Lookups for the client tenant.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Lookups is returned
     */
    getAllLookups(x_TENANT_ID: string): Promise<LookupDtoIEnumerableServiceResponse>;
    /**
     * Gets all Lookups active version for the client tenant.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Lookups is returned
     */
    getAllActiveLookups(x_TENANT_ID: string): Promise<LookupDtoIEnumerableServiceResponse>;
    /**
     * Gets all Lookups (lite)
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Lookups is returned
     */
    getAllLookupsLite(x_TENANT_ID: string): Promise<LookupLiteDtoIEnumerableServiceResponse>;
    /**
     * Get the active version of an existing Lookup by ID
     * @param lookupId The id of the lookup to retrieve
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. A Lookup is returned
     */
    getLookupById(lookupId: string, x_TENANT_ID: string): Promise<LookupVersionDtoServiceResponse>;
    /**
     * Get a specific version of an existing Lookup
     * @param lookupId The Id of the existing model
     * @param versionNumber The version number to retrieve
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. A Lookup is returned
     */
    getLookupVersionById(lookupId: string, versionNumber: number, x_TENANT_ID: string): Promise<LookupVersionDtoServiceResponse>;
    /**
     * Get all lookups and their parent child relationship.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Linked Lookup is returned
     */
    getAllLinkLookups(x_TENANT_ID: string): Promise<LookupLinkDtoIEnumerableServiceResponse>;
    /**
     * Gets all Link Lookups active version for the client tenant.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Linked Lookup is returned
     */
    getAllActiveLinkLookups(x_TENANT_ID: string): Promise<LookupLinkDtoIEnumerableServiceResponse>;
    /**
     * Gets all Link Lookups (lite)
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Link Lookups is returned
     */
    getAllLinkLookupsLite(x_TENANT_ID: string): Promise<LookupLinkLiteDtoIEnumerableServiceResponse>;
    /**
     * Get the current active version of an existing Link Lookup along with its relationships.
     * @param id The id of the Linked Lookup to retrieve
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Linked Lookup is returned
     */
    getLinkLookupById(id: string, x_TENANT_ID: string): Promise<LookupLinkVersionDtoServiceResponse>;
    /**
     * Get the specified version of an existing Linked Lookup
     * @param id The Id of the existing Linked Lookup
     * @param versionNumber The version number to retrieve
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Linked Lookup is returned
     */
    getLinkLookupVersionById(id: string, versionNumber: number, x_TENANT_ID: string): Promise<LookupLinkVersionDtoServiceResponse>;
    /**
     * Get all Linked Lookup version of a existing Lookup
     * @param lookupid The id of the Lookup
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Linked Lookups is returned
     */
    getLinkLookupByLookup(lookupid: string, x_TENANT_ID: string): Promise<LookupLinkVersionIEnumerableServiceResponse>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/lookupquery";

    }

    /**
     * Gets all Lookups for the client tenant.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Lookups is returned
     */
    getAllLookups(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/lookup";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllLookups(_response);
        });
    }

    protected processGetAllLookups(response: AxiosResponse): Promise<LookupDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupDtoIEnumerableServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets all Lookups active version for the client tenant.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Lookups is returned
     */
    getAllActiveLookups(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/lookup/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllActiveLookups(_response);
        });
    }

    protected processGetAllActiveLookups(response: AxiosResponse): Promise<LookupDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets all Lookups (lite)
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Lookups is returned
     */
    getAllLookupsLite(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupLiteDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/lookup/lite";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllLookupsLite(_response);
        });
    }

    protected processGetAllLookupsLite(response: AxiosResponse): Promise<LookupLiteDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupLiteDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupLiteDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupLiteDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get the active version of an existing Lookup by ID
     * @param lookupId The id of the lookup to retrieve
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. A Lookup is returned
     */
    getLookupById(lookupId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/lookup/{lookupId}";
        if (lookupId === undefined || lookupId === null)
            throw new Error("The parameter 'lookupId' must be defined.");
        url_ = url_.replace("{lookupId}", encodeURIComponent("" + lookupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookupById(_response);
        });
    }

    protected processGetLookupById(response: AxiosResponse): Promise<LookupVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupVersionDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupVersionDtoServiceResponse>(null as any);
    }

    /**
     * Get a specific version of an existing Lookup
     * @param lookupId The Id of the existing model
     * @param versionNumber The version number to retrieve
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. A Lookup is returned
     */
    getLookupVersionById(lookupId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/lookup/{lookupId}/version/{versionNumber}";
        if (lookupId === undefined || lookupId === null)
            throw new Error("The parameter 'lookupId' must be defined.");
        url_ = url_.replace("{lookupId}", encodeURIComponent("" + lookupId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookupVersionById(_response);
        });
    }

    protected processGetLookupVersionById(response: AxiosResponse): Promise<LookupVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupVersionDtoServiceResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupVersionDtoServiceResponse>(null as any);
    }

    /**
     * Get all lookups and their parent child relationship.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Linked Lookup is returned
     */
    getAllLinkLookups(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupLinkDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/lookuplink";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllLinkLookups(_response);
        });
    }

    protected processGetAllLinkLookups(response: AxiosResponse): Promise<LookupLinkDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupLinkDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupLinkDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupLinkDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets all Link Lookups active version for the client tenant.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Linked Lookup is returned
     */
    getAllActiveLinkLookups(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupLinkDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/lookuplink/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllActiveLinkLookups(_response);
        });
    }

    protected processGetAllActiveLinkLookups(response: AxiosResponse): Promise<LookupLinkDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupLinkDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupLinkDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupLinkDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets all Link Lookups (lite)
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Link Lookups is returned
     */
    getAllLinkLookupsLite(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupLinkLiteDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/lookuplink/lite";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllLinkLookupsLite(_response);
        });
    }

    protected processGetAllLinkLookupsLite(response: AxiosResponse): Promise<LookupLinkLiteDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupLinkLiteDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupLinkLiteDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupLinkLiteDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get the current active version of an existing Link Lookup along with its relationships.
     * @param id The id of the Linked Lookup to retrieve
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Linked Lookup is returned
     */
    getLinkLookupById(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupLinkVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/lookuplink/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLinkLookupById(_response);
        });
    }

    protected processGetLinkLookupById(response: AxiosResponse): Promise<LookupLinkVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupLinkVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupLinkVersionDtoServiceResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupLinkVersionDtoServiceResponse>(null as any);
    }

    /**
     * Get the specified version of an existing Linked Lookup
     * @param id The Id of the existing Linked Lookup
     * @param versionNumber The version number to retrieve
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Linked Lookup is returned
     */
    getLinkLookupVersionById(id: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupLinkVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/lookuplink/{id}/version/{versionNumber}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLinkLookupVersionById(_response);
        });
    }

    protected processGetLinkLookupVersionById(response: AxiosResponse): Promise<LookupLinkVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupLinkVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupLinkVersionDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupLinkVersionDtoServiceResponse>(null as any);
    }

    /**
     * Get all Linked Lookup version of a existing Lookup
     * @param lookupid The id of the Lookup
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of Linked Lookups is returned
     */
    getLinkLookupByLookup(lookupid: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<LookupLinkVersionIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/lookuplink/lookup/{lookupid}";
        if (lookupid === undefined || lookupid === null)
            throw new Error("The parameter 'lookupid' must be defined.");
        url_ = url_.replace("{lookupid}", encodeURIComponent("" + lookupid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLinkLookupByLookup(_response);
        });
    }

    protected processGetLinkLookupByLookup(response: AxiosResponse): Promise<LookupLinkVersionIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LookupLinkVersionIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<LookupLinkVersionIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Server Error", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupLinkVersionIEnumerableServiceResponse>(null as any);
    }
}

export class ApproveAction implements IApproveAction {
    comment?: string | undefined;
    decision?: Decision;
    created?: Date;

    constructor(data?: IApproveAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
            this.decision = _data["decision"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApproveAction {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["decision"] = this.decision;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IApproveAction {
    comment?: string | undefined;
    decision?: Decision;
    created?: Date;
}

export class Approver implements IApprover {
    subject?: string | undefined;
    successor?: Approver | undefined;
    action?: ApproveAction | undefined;
    readonly hasProcessedRequest?: boolean;

    constructor(data?: IApprover) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.successor = data.successor && !(<any>data.successor).toJSON ? new Approver(data.successor) : <Approver>this.successor;
            this.action = data.action && !(<any>data.action).toJSON ? new ApproveAction(data.action) : <ApproveAction>this.action;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.successor = _data["successor"] ? Approver.fromJS(_data["successor"]) : <any>undefined;
            this.action = _data["action"] ? ApproveAction.fromJS(_data["action"]) : <any>undefined;
            (<any>this).hasProcessedRequest = _data["hasProcessedRequest"];
        }
    }

    static fromJS(data: any): Approver {
        data = typeof data === 'object' ? data : {};
        let result = new Approver();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["successor"] = this.successor ? this.successor.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["hasProcessedRequest"] = this.hasProcessedRequest;
        return data;
    }
}

export interface IApprover {
    subject?: string | undefined;
    successor?: IApprover | undefined;
    action?: IApproveAction | undefined;
    hasProcessedRequest?: boolean;
}

export enum Decision {
    Approve = "Approve",
    Reject = "Reject",
}

export interface IIApprover {
    subject?: string | undefined;
    hasProcessedRequest?: boolean;
}

export class LinkLookupProperty implements ILinkLookupProperty {
    childValues?: string[] | undefined;

    constructor(data?: ILinkLookupProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["childValues"])) {
                this.childValues = [] as any;
                for (let item of _data["childValues"])
                    this.childValues!.push(item);
            }
        }
    }

    static fromJS(data: any): LinkLookupProperty {
        data = typeof data === 'object' ? data : {};
        let result = new LinkLookupProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.childValues)) {
            data["childValues"] = [];
            for (let item of this.childValues)
                data["childValues"].push(item);
        }
        return data;
    }
}

export interface ILinkLookupProperty {
    childValues?: string[] | undefined;
}

export class LinkLookupPropertyDto implements ILinkLookupPropertyDto {
    childValues?: string[] | undefined;

    constructor(data?: ILinkLookupPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["childValues"])) {
                this.childValues = [] as any;
                for (let item of _data["childValues"])
                    this.childValues!.push(item);
            }
        }
    }

    static fromJS(data: any): LinkLookupPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkLookupPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.childValues)) {
            data["childValues"] = [];
            for (let item of this.childValues)
                data["childValues"].push(item);
        }
        return data;
    }
}

export interface ILinkLookupPropertyDto {
    childValues?: string[] | undefined;
}

/** Lookup Data */
export class LookupDto implements ILookupDto {
    /** Lookup Id */
    id?: string;
    /** Flag to display if this is a System Lookup */
    isSystemLookup?: boolean;
    /** List of available lookup versions */
    versions?: LookupVersionDto[] | undefined;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.versions) {
                this.versions = [];
                for (let i = 0; i < data.versions.length; i++) {
                    let item = data.versions[i];
                    this.versions[i] = item && !(<any>item).toJSON ? new LookupVersionDto(item) : <LookupVersionDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isSystemLookup = _data["isSystemLookup"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(LookupVersionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isSystemLookup"] = this.isSystemLookup;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        return data;
    }
}

/** Lookup Data */
export interface ILookupDto {
    /** Lookup Id */
    id?: string;
    /** Flag to display if this is a System Lookup */
    isSystemLookup?: boolean;
    /** List of available lookup versions */
    versions?: ILookupVersionDto[] | undefined;
}

export class LookupDtoIEnumerableServiceResponse implements ILookupDtoIEnumerableServiceResponse {
    data?: LookupDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ILookupDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new LookupDto(item) : <LookupDto>item;
                }
            }
            if (data.messages) {
                this.messages = [];
                for (let i = 0; i < data.messages.length; i++) {
                    let item = data.messages[i];
                    this.messages[i] = item && !(<any>item).toJSON ? new ServiceResponseMessage(item) : <ServiceResponseMessage>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(LookupDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupDtoIEnumerableServiceResponse {
    data?: ILookupDto[] | undefined;
    messages?: IServiceResponseMessage[] | undefined;
}

export class LookupLinkDto implements ILookupLinkDto {
    /** Lookup Link Id */
    id?: string;
    /** List of available lookup links versions */
    versions?: LookupLinkVersionDto[] | undefined;

    constructor(data?: ILookupLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.versions) {
                this.versions = [];
                for (let i = 0; i < data.versions.length; i++) {
                    let item = data.versions[i];
                    this.versions[i] = item && !(<any>item).toJSON ? new LookupLinkVersionDto(item) : <LookupLinkVersionDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(LookupLinkVersionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupLinkDto {
    /** Lookup Link Id */
    id?: string;
    /** List of available lookup links versions */
    versions?: ILookupLinkVersionDto[] | undefined;
}

export class LookupLinkDtoIEnumerableServiceResponse implements ILookupLinkDtoIEnumerableServiceResponse {
    data?: LookupLinkDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ILookupLinkDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new LookupLinkDto(item) : <LookupLinkDto>item;
                }
            }
            if (data.messages) {
                this.messages = [];
                for (let i = 0; i < data.messages.length; i++) {
                    let item = data.messages[i];
                    this.messages[i] = item && !(<any>item).toJSON ? new ServiceResponseMessage(item) : <ServiceResponseMessage>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(LookupLinkDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupLinkDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLinkDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupLinkDtoIEnumerableServiceResponse {
    data?: ILookupLinkDto[] | undefined;
    messages?: IServiceResponseMessage[] | undefined;
}

export class LookupLinkLiteDto implements ILookupLinkLiteDto {
    /** Lookup Link Id */
    id?: string;
    /** List of available lookup links versions with basic details */
    versions?: LookupLinkVersionBaseDto[] | undefined;

    constructor(data?: ILookupLinkLiteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.versions) {
                this.versions = [];
                for (let i = 0; i < data.versions.length; i++) {
                    let item = data.versions[i];
                    this.versions[i] = item && !(<any>item).toJSON ? new LookupLinkVersionBaseDto(item) : <LookupLinkVersionBaseDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(LookupLinkVersionBaseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupLinkLiteDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLinkLiteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupLinkLiteDto {
    /** Lookup Link Id */
    id?: string;
    /** List of available lookup links versions with basic details */
    versions?: ILookupLinkVersionBaseDto[] | undefined;
}

export class LookupLinkLiteDtoIEnumerableServiceResponse implements ILookupLinkLiteDtoIEnumerableServiceResponse {
    data?: LookupLinkLiteDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ILookupLinkLiteDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new LookupLinkLiteDto(item) : <LookupLinkLiteDto>item;
                }
            }
            if (data.messages) {
                this.messages = [];
                for (let i = 0; i < data.messages.length; i++) {
                    let item = data.messages[i];
                    this.messages[i] = item && !(<any>item).toJSON ? new ServiceResponseMessage(item) : <ServiceResponseMessage>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(LookupLinkLiteDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupLinkLiteDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLinkLiteDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupLinkLiteDtoIEnumerableServiceResponse {
    data?: ILookupLinkLiteDto[] | undefined;
    messages?: IServiceResponseMessage[] | undefined;
}

export class LookupLinkVersion implements ILookupLinkVersion {
    versionNumber?: number;
    effectiveFrom?: Date;
    status?: VersionStatus;
    readonly nextApprover?: Approver | undefined;
    created?: Date;
    id?: string;
    lookupLinkId?: string;
    name?: string | undefined;
    parentLookupId?: string;
    parentLookupVersion?: number;
    childLookupId?: string;
    childLookupVersion?: number;
    properties?: { [key: string]: LinkLookupProperty; } | undefined;
    signees?: Signee[] | undefined;
    readonly approvers?: Approver[] | undefined;

    constructor(data?: ILookupLinkVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.nextApprover = data.nextApprover && !(<any>data.nextApprover).toJSON ? new Approver(data.nextApprover) : <Approver>this.nextApprover;
            if (data.properties) {
                this.properties = {};
                for (let key in data.properties) {
                    if (data.properties.hasOwnProperty(key)) {
                        let item = data.properties[key];
                        this.properties[key] = item && !(<any>item).toJSON ? new LinkLookupProperty(item) : <LinkLookupProperty>item;
                    }
                }
            }
            if (data.signees) {
                this.signees = [];
                for (let i = 0; i < data.signees.length; i++) {
                    let item = data.signees[i];
                    this.signees[i] = item && !(<any>item).toJSON ? new Signee(item) : <Signee>item;
                }
            }
            if (data.approvers) {
                this.approvers = [];
                for (let i = 0; i < data.approvers.length; i++) {
                    let item = data.approvers[i];
                    this.approvers[i] = item && !(<any>item).toJSON ? new Approver(item) : <Approver>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.status = _data["status"];
            (<any>this).nextApprover = _data["nextApprover"] ? Approver.fromJS(_data["nextApprover"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.lookupLinkId = _data["lookupLinkId"];
            this.name = _data["name"];
            this.parentLookupId = _data["parentLookupId"];
            this.parentLookupVersion = _data["parentLookupVersion"];
            this.childLookupId = _data["childLookupId"];
            this.childLookupVersion = _data["childLookupVersion"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? LinkLookupProperty.fromJS(_data["properties"][key]) : new LinkLookupProperty();
                }
            }
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            if (Array.isArray(_data["approvers"])) {
                (<any>this).approvers = [] as any;
                for (let item of _data["approvers"])
                    (<any>this).approvers!.push(Approver.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupLinkVersion {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLinkVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["nextApprover"] = this.nextApprover ? this.nextApprover.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["lookupLinkId"] = this.lookupLinkId;
        data["name"] = this.name;
        data["parentLookupId"] = this.parentLookupId;
        data["parentLookupVersion"] = this.parentLookupVersion;
        data["childLookupId"] = this.childLookupId;
        data["childLookupVersion"] = this.childLookupVersion;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        if (Array.isArray(this.approvers)) {
            data["approvers"] = [];
            for (let item of this.approvers)
                data["approvers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupLinkVersion {
    versionNumber?: number;
    effectiveFrom?: Date;
    status?: VersionStatus;
    nextApprover?: Approver | undefined;
    created?: Date;
    id?: string;
    lookupLinkId?: string;
    name?: string | undefined;
    parentLookupId?: string;
    parentLookupVersion?: number;
    childLookupId?: string;
    childLookupVersion?: number;
    properties?: { [key: string]: ILinkLookupProperty; } | undefined;
    signees?: ISignee[] | undefined;
    approvers?: IIApprover[] | undefined;
}

export class LookupLinkVersionBaseDto implements ILookupLinkVersionBaseDto {
    /** The UiD of the version */
    id?: string;
    /** The UiD of the Lookup Link that the version belongs to */
    lookupLinkId?: string;
    /** Display name of the Lookup Link */
    name?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** Parent Lookup Id Linked */
    parentLookupId?: string;
    /** Parent Lookup Version Linked */
    parentLookupVersion?: number;
    /** Child Lookup Id Linked */
    childLookupId?: string;
    /** Child Lookup Version Linked */
    childLookupVersion?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's active version
at the time of the query */
    isActive?: boolean;

    constructor(data?: ILookupLinkVersionBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lookupLinkId = _data["lookupLinkId"];
            this.name = _data["name"];
            this.versionNumber = _data["versionNumber"];
            this.parentLookupId = _data["parentLookupId"];
            this.parentLookupVersion = _data["parentLookupVersion"];
            this.childLookupId = _data["childLookupId"];
            this.childLookupVersion = _data["childLookupVersion"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): LookupLinkVersionBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLinkVersionBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lookupLinkId"] = this.lookupLinkId;
        data["name"] = this.name;
        data["versionNumber"] = this.versionNumber;
        data["parentLookupId"] = this.parentLookupId;
        data["parentLookupVersion"] = this.parentLookupVersion;
        data["childLookupId"] = this.childLookupId;
        data["childLookupVersion"] = this.childLookupVersion;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ILookupLinkVersionBaseDto {
    /** The UiD of the version */
    id?: string;
    /** The UiD of the Lookup Link that the version belongs to */
    lookupLinkId?: string;
    /** Display name of the Lookup Link */
    name?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** Parent Lookup Id Linked */
    parentLookupId?: string;
    /** Parent Lookup Version Linked */
    parentLookupVersion?: number;
    /** Child Lookup Id Linked */
    childLookupId?: string;
    /** Child Lookup Version Linked */
    childLookupVersion?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's active version
at the time of the query */
    isActive?: boolean;
}

export class LookupLinkVersionDto implements ILookupLinkVersionDto {
    /** The UiD of the version */
    id?: string;
    /** The UiD of the Lookup Link that the version belongs to */
    lookupLinkId?: string;
    /** Display name of the Lookup Link */
    name?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** Parent Lookup Id Linked */
    parentLookupId?: string;
    /** Parent Lookup Version Linked */
    parentLookupVersion?: number;
    /** Child Lookup Id Linked */
    childLookupId?: string;
    /** Child Lookup Version Linked */
    childLookupVersion?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's active version
at the time of the query */
    isActive?: boolean;
    /** Dictionary of linked values parents to children */
    properties?: { [key: string]: LinkLookupPropertyDto; } | undefined;
    /** List of ordered parent lookup values */
    propertiesOrder?: string[] | undefined;
    /** List of ordered child lookup values */
    childValuesOrder?: string[] | undefined;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;

    constructor(data?: ILookupLinkVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.properties) {
                this.properties = {};
                for (let key in data.properties) {
                    if (data.properties.hasOwnProperty(key)) {
                        let item = data.properties[key];
                        this.properties[key] = item && !(<any>item).toJSON ? new LinkLookupPropertyDto(item) : <LinkLookupPropertyDto>item;
                    }
                }
            }
            if (data.signees) {
                this.signees = [];
                for (let i = 0; i < data.signees.length; i++) {
                    let item = data.signees[i];
                    this.signees[i] = item && !(<any>item).toJSON ? new Signee(item) : <Signee>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lookupLinkId = _data["lookupLinkId"];
            this.name = _data["name"];
            this.versionNumber = _data["versionNumber"];
            this.parentLookupId = _data["parentLookupId"];
            this.parentLookupVersion = _data["parentLookupVersion"];
            this.childLookupId = _data["childLookupId"];
            this.childLookupVersion = _data["childLookupVersion"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? LinkLookupPropertyDto.fromJS(_data["properties"][key]) : new LinkLookupPropertyDto();
                }
            }
            if (Array.isArray(_data["propertiesOrder"])) {
                this.propertiesOrder = [] as any;
                for (let item of _data["propertiesOrder"])
                    this.propertiesOrder!.push(item);
            }
            if (Array.isArray(_data["childValuesOrder"])) {
                this.childValuesOrder = [] as any;
                for (let item of _data["childValuesOrder"])
                    this.childValuesOrder!.push(item);
            }
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupLinkVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLinkVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lookupLinkId"] = this.lookupLinkId;
        data["name"] = this.name;
        data["versionNumber"] = this.versionNumber;
        data["parentLookupId"] = this.parentLookupId;
        data["parentLookupVersion"] = this.parentLookupVersion;
        data["childLookupId"] = this.childLookupId;
        data["childLookupVersion"] = this.childLookupVersion;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.propertiesOrder)) {
            data["propertiesOrder"] = [];
            for (let item of this.propertiesOrder)
                data["propertiesOrder"].push(item);
        }
        if (Array.isArray(this.childValuesOrder)) {
            data["childValuesOrder"] = [];
            for (let item of this.childValuesOrder)
                data["childValuesOrder"].push(item);
        }
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupLinkVersionDto {
    /** The UiD of the version */
    id?: string;
    /** The UiD of the Lookup Link that the version belongs to */
    lookupLinkId?: string;
    /** Display name of the Lookup Link */
    name?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** Parent Lookup Id Linked */
    parentLookupId?: string;
    /** Parent Lookup Version Linked */
    parentLookupVersion?: number;
    /** Child Lookup Id Linked */
    childLookupId?: string;
    /** Child Lookup Version Linked */
    childLookupVersion?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's active version
at the time of the query */
    isActive?: boolean;
    /** Dictionary of linked values parents to children */
    properties?: { [key: string]: ILinkLookupPropertyDto; } | undefined;
    /** List of ordered parent lookup values */
    propertiesOrder?: string[] | undefined;
    /** List of ordered child lookup values */
    childValuesOrder?: string[] | undefined;
    /** The defined list of signees for the version */
    signees?: ISignee[] | undefined;
}

export class LookupLinkVersionDtoServiceResponse implements ILookupLinkVersionDtoServiceResponse {
    data?: LookupLinkVersionDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ILookupLinkVersionDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new LookupLinkVersionDto(data.data) : <LookupLinkVersionDto>this.data;
            if (data.messages) {
                this.messages = [];
                for (let i = 0; i < data.messages.length; i++) {
                    let item = data.messages[i];
                    this.messages[i] = item && !(<any>item).toJSON ? new ServiceResponseMessage(item) : <ServiceResponseMessage>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LookupLinkVersionDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupLinkVersionDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLinkVersionDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupLinkVersionDtoServiceResponse {
    data?: ILookupLinkVersionDto | undefined;
    messages?: IServiceResponseMessage[] | undefined;
}

export class LookupLinkVersionIEnumerableServiceResponse implements ILookupLinkVersionIEnumerableServiceResponse {
    data?: LookupLinkVersion[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ILookupLinkVersionIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new LookupLinkVersion(item) : <LookupLinkVersion>item;
                }
            }
            if (data.messages) {
                this.messages = [];
                for (let i = 0; i < data.messages.length; i++) {
                    let item = data.messages[i];
                    this.messages[i] = item && !(<any>item).toJSON ? new ServiceResponseMessage(item) : <ServiceResponseMessage>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(LookupLinkVersion.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupLinkVersionIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLinkVersionIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupLinkVersionIEnumerableServiceResponse {
    data?: ILookupLinkVersion[] | undefined;
    messages?: IServiceResponseMessage[] | undefined;
}

/** Lookup Data */
export class LookupLiteDto implements ILookupLiteDto {
    /** The UiD of the lookup */
    id?: string;
    /** Flag to display if this is a System Lookup */
    isSystemLookup?: boolean;
    /** List of available lookup versions */
    versions?: LookupLiteVersionDto[] | undefined;

    constructor(data?: ILookupLiteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.versions) {
                this.versions = [];
                for (let i = 0; i < data.versions.length; i++) {
                    let item = data.versions[i];
                    this.versions[i] = item && !(<any>item).toJSON ? new LookupLiteVersionDto(item) : <LookupLiteVersionDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isSystemLookup = _data["isSystemLookup"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(LookupLiteVersionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupLiteDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLiteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isSystemLookup"] = this.isSystemLookup;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        return data;
    }
}

/** Lookup Data */
export interface ILookupLiteDto {
    /** The UiD of the lookup */
    id?: string;
    /** Flag to display if this is a System Lookup */
    isSystemLookup?: boolean;
    /** List of available lookup versions */
    versions?: ILookupLiteVersionDto[] | undefined;
}

export class LookupLiteDtoIEnumerableServiceResponse implements ILookupLiteDtoIEnumerableServiceResponse {
    data?: LookupLiteDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ILookupLiteDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new LookupLiteDto(item) : <LookupLiteDto>item;
                }
            }
            if (data.messages) {
                this.messages = [];
                for (let i = 0; i < data.messages.length; i++) {
                    let item = data.messages[i];
                    this.messages[i] = item && !(<any>item).toJSON ? new ServiceResponseMessage(item) : <ServiceResponseMessage>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(LookupLiteDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupLiteDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLiteDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupLiteDtoIEnumerableServiceResponse {
    data?: ILookupLiteDto[] | undefined;
    messages?: IServiceResponseMessage[] | undefined;
}

/** Instance of a Lookup Version. */
export class LookupLiteVersionDto implements ILookupLiteVersionDto {
    /** The UiD of the version */
    id?: string;
    /** The UiD of the Lookup that the version belongs to */
    lookupId?: string;
    /** Display name of the model */
    lookupName?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's active version
at the time of the query */
    isActive?: boolean;
    /** Flag to display if is a System Lookup and is protect  to be deleted or updated LookupName */
    isSystemLookup?: boolean;

    constructor(data?: ILookupLiteVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lookupId = _data["lookupId"];
            this.lookupName = _data["lookupName"];
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isSystemLookup = _data["isSystemLookup"];
        }
    }

    static fromJS(data: any): LookupLiteVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupLiteVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lookupId"] = this.lookupId;
        data["lookupName"] = this.lookupName;
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isSystemLookup"] = this.isSystemLookup;
        return data;
    }
}

/** Instance of a Lookup Version. */
export interface ILookupLiteVersionDto {
    /** The UiD of the version */
    id?: string;
    /** The UiD of the Lookup that the version belongs to */
    lookupId?: string;
    /** Display name of the model */
    lookupName?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's active version
at the time of the query */
    isActive?: boolean;
    /** Flag to display if is a System Lookup and is protect  to be deleted or updated LookupName */
    isSystemLookup?: boolean;
}

/** Instance of a Lookup Version. */
export class LookupVersionDto implements ILookupVersionDto {
    /** The UiD of the version */
    id?: string;
    /** The UiD of the Lookup that the version belongs to */
    lookupId?: string;
    /** Display name of the model */
    lookupName?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's active version
at the time of the query */
    isActive?: boolean;
    /** Flag to display if is a System Lookup and is protect  to be deleted or updated LookupName */
    isSystemLookup?: boolean;
    /** List of values for lookup */
    values?: string[] | undefined;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Lookup metadata column collection */
    columns?: MetadataColumnDto[] | undefined;

    constructor(data?: ILookupVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.signees) {
                this.signees = [];
                for (let i = 0; i < data.signees.length; i++) {
                    let item = data.signees[i];
                    this.signees[i] = item && !(<any>item).toJSON ? new Signee(item) : <Signee>item;
                }
            }
            if (data.columns) {
                this.columns = [];
                for (let i = 0; i < data.columns.length; i++) {
                    let item = data.columns[i];
                    this.columns[i] = item && !(<any>item).toJSON ? new MetadataColumnDto(item) : <MetadataColumnDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lookupId = _data["lookupId"];
            this.lookupName = _data["lookupName"];
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isSystemLookup = _data["isSystemLookup"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(MetadataColumnDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lookupId"] = this.lookupId;
        data["lookupName"] = this.lookupName;
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isSystemLookup"] = this.isSystemLookup;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }
}

/** Instance of a Lookup Version. */
export interface ILookupVersionDto {
    /** The UiD of the version */
    id?: string;
    /** The UiD of the Lookup that the version belongs to */
    lookupId?: string;
    /** Display name of the model */
    lookupName?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's active version
at the time of the query */
    isActive?: boolean;
    /** Flag to display if is a System Lookup and is protect  to be deleted or updated LookupName */
    isSystemLookup?: boolean;
    /** List of values for lookup */
    values?: string[] | undefined;
    /** The defined list of signees for the version */
    signees?: ISignee[] | undefined;
    /** Lookup metadata column collection */
    columns?: IMetadataColumnDto[] | undefined;
}

export class LookupVersionDtoServiceResponse implements ILookupVersionDtoServiceResponse {
    /** Instance of a Lookup Version. */
    data?: LookupVersionDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ILookupVersionDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new LookupVersionDto(data.data) : <LookupVersionDto>this.data;
            if (data.messages) {
                this.messages = [];
                for (let i = 0; i < data.messages.length; i++) {
                    let item = data.messages[i];
                    this.messages[i] = item && !(<any>item).toJSON ? new ServiceResponseMessage(item) : <ServiceResponseMessage>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LookupVersionDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupVersionDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LookupVersionDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupVersionDtoServiceResponse {
    /** Instance of a Lookup Version. */
    data?: ILookupVersionDto | undefined;
    messages?: IServiceResponseMessage[] | undefined;
}

/** Defines column with metadata for lookup values */
export class MetadataColumnDto implements IMetadataColumnDto {
    /** Type of column */
    type?: string | undefined;
    /** Name of column */
    name?: string | undefined;
    /** Column values - key is lookup value */
    values?: { [key: string]: MetadataColumnValueDto; } | undefined;

    constructor(data?: IMetadataColumnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.values) {
                this.values = {};
                for (let key in data.values) {
                    if (data.values.hasOwnProperty(key)) {
                        let item = data.values[key];
                        this.values[key] = item && !(<any>item).toJSON ? new MetadataColumnValueDto(item) : <MetadataColumnValueDto>item;
                    }
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.name = _data["name"];
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key] ? MetadataColumnValueDto.fromJS(_data["values"][key]) : new MetadataColumnValueDto();
                }
            }
        }
    }

    static fromJS(data: any): MetadataColumnDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataColumnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["name"] = this.name;
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = this.values[key] ? this.values[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Defines column with metadata for lookup values */
export interface IMetadataColumnDto {
    /** Type of column */
    type?: string | undefined;
    /** Name of column */
    name?: string | undefined;
    /** Column values - key is lookup value */
    values?: { [key: string]: IMetadataColumnValueDto; } | undefined;
}

/** Defines value of lookup value's column entry */
export class MetadataColumnValueDto implements IMetadataColumnValueDto {
    /** Value of lookup value's column entry */
    value?: string | undefined;

    constructor(data?: IMetadataColumnValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MetadataColumnValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataColumnValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

/** Defines value of lookup value's column entry */
export interface IMetadataColumnValueDto {
    /** Value of lookup value's column entry */
    value?: string | undefined;
}

export class ObjectServiceResponse implements IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.messages) {
                this.messages = [];
                for (let i = 0; i < data.messages.length; i++) {
                    let item = data.messages[i];
                    this.messages[i] = item && !(<any>item).toJSON ? new ServiceResponseMessage(item) : <ServiceResponseMessage>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IObjectServiceResponse {
    data?: any | undefined;
    messages?: IServiceResponseMessage[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class ServiceResponse implements IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.messages) {
                this.messages = [];
                for (let i = 0; i < data.messages.length; i++) {
                    let item = data.messages[i];
                    this.messages[i] = item && !(<any>item).toJSON ? new ServiceResponseMessage(item) : <ServiceResponseMessage>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IServiceResponse {
    data?: string | undefined;
    messages?: IServiceResponseMessage[] | undefined;
}

export class ServiceResponseMessage implements IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

export interface IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;
}

export class Signee implements ISignee {
    subject?: string | undefined;
    successor?: Approver | undefined;
    action?: ApproveAction | undefined;
    readonly hasProcessedRequest?: boolean;

    constructor(data?: ISignee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.successor = data.successor && !(<any>data.successor).toJSON ? new Approver(data.successor) : <Approver>this.successor;
            this.action = data.action && !(<any>data.action).toJSON ? new ApproveAction(data.action) : <ApproveAction>this.action;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.successor = _data["successor"] ? Approver.fromJS(_data["successor"]) : <any>undefined;
            this.action = _data["action"] ? ApproveAction.fromJS(_data["action"]) : <any>undefined;
            (<any>this).hasProcessedRequest = _data["hasProcessedRequest"];
        }
    }

    static fromJS(data: any): Signee {
        data = typeof data === 'object' ? data : {};
        let result = new Signee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["successor"] = this.successor ? this.successor.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["hasProcessedRequest"] = this.hasProcessedRequest;
        return data;
    }
}

export interface ISignee {
    subject?: string | undefined;
    successor?: IApprover | undefined;
    action?: IApproveAction | undefined;
    hasProcessedRequest?: boolean;
}

export class ValidationErrorModel implements IValidationErrorModel {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    errorCode?: string | undefined;

    constructor(data?: IValidationErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            this.attemptedValue = _data["attemptedValue"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ValidationErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

export interface IValidationErrorModel {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    errorCode?: string | undefined;
}

export class ValidationErrorModelListServiceResponse implements IValidationErrorModelListServiceResponse {
    data?: ValidationErrorModel[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IValidationErrorModelListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ValidationErrorModel(item) : <ValidationErrorModel>item;
                }
            }
            if (data.messages) {
                this.messages = [];
                for (let i = 0; i < data.messages.length; i++) {
                    let item = data.messages[i];
                    this.messages[i] = item && !(<any>item).toJSON ? new ServiceResponseMessage(item) : <ServiceResponseMessage>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ValidationErrorModel.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationErrorModelListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModelListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IValidationErrorModelListServiceResponse {
    data?: IValidationErrorModel[] | undefined;
    messages?: IServiceResponseMessage[] | undefined;
}

export enum VersionStatus {
    Draft = "Draft",
    Pending = "Pending",
    Rejected = "Rejected",
    Published = "Published",
    Archived = "Archived",
    Deleted = "Deleted",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}