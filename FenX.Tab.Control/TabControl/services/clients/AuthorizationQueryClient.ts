//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * Get access layers
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of access layers is returned
     */
    getAllAccessLayers(x_TENANT_ID: string): Promise<AccessLayerDtoIEnumerableServiceResponse>;
    /**
     * Get access layer by id
     * @param id Access layer id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Access layer is returned
     */
    getAccessLayer(id: string, x_TENANT_ID: string): Promise<AccessLayerDtoServiceResponse>;
    /**
     * Get users with given access layer assigned
     * @param id Access layer Id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list user ids is returned
     */
    getAccessLayerUsers(id: string, x_TENANT_ID: string): Promise<StringIEnumerableServiceResponse>;
    /**
     * Get access layers configuration
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The configuration options
     */
    getAccessLayersConfiguration(x_TENANT_ID: string): Promise<AccessLayersConfigurationDtoServiceResponse>;
    /**
     * Get reference data
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The reference data is returned
     */
    getReferenceData(x_TENANT_ID: string): Promise<ReferenceDataDtoServiceResponse>;
    /**
     * Get teams
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of teams is returned
     */
    getAllTeams(x_TENANT_ID: string): Promise<TeamDtoIEnumerableServiceResponse>;
    /**
     * Get team by id
     * @param id Team id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Team is returned
     */
    getTeam(id: string, x_TENANT_ID: string): Promise<TeamDtoServiceResponse>;
    /**
     * Get user teams
     * @param id Team Id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list user ids is returned
     */
    getTeamUsers(id: string, x_TENANT_ID: string): Promise<StringIEnumerableServiceResponse>;
    /**
     * Get users
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of users is returned
     */
    getAllUsers(x_TENANT_ID: string): Promise<UserDtoIEnumerableServiceResponse>;
    /**
     * Get user by id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. User is returned
     */
    getUserById(id: string, x_TENANT_ID: string): Promise<UserDtoServiceResponse>;
    /**
     * Get current user authorization profile
     * @param includeTeamDefinitions (optional) 
     * @param includeAccessLayersDefinitions (optional) 
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. User authorization profile is returned
     */
    getCurrentUserAuthorizationProfile(includeTeamDefinitions: boolean | undefined, includeAccessLayersDefinitions: boolean | undefined, x_TENANT_ID: string): Promise<UserAuthorizationProfileDtoServiceResponse>;
    /**
     * Get current user authorization profile by user id
     * @param includeTeamDefinitions (optional) 
     * @param includeAccessLayersDefinitions (optional) 
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. User authorization profile is returned
     */
    getUserAuthorizationProfileById(id: string, includeTeamDefinitions: boolean | undefined, includeAccessLayersDefinitions: boolean | undefined, x_TENANT_ID: string): Promise<UserAuthorizationProfileDtoServiceResponse>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/authorizationquery";

    }

    /**
     * Get access layers
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of access layers is returned
     */
    getAllAccessLayers(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<AccessLayerDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/access-layer";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllAccessLayers(_response);
        });
    }

    protected processGetAllAccessLayers(response: AxiosResponse): Promise<AccessLayerDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessLayerDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<AccessLayerDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessLayerDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get access layer by id
     * @param id Access layer id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Access layer is returned
     */
    getAccessLayer(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<AccessLayerDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/access-layer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccessLayer(_response);
        });
    }

    protected processGetAccessLayer(response: AxiosResponse): Promise<AccessLayerDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessLayerDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<AccessLayerDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ServiceResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessLayerDtoServiceResponse>(null as any);
    }

    /**
     * Get users with given access layer assigned
     * @param id Access layer Id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list user ids is returned
     */
    getAccessLayerUsers(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<StringIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/access-layer/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccessLayerUsers(_response);
        });
    }

    protected processGetAccessLayerUsers(response: AxiosResponse): Promise<StringIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<StringIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get access layers configuration
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The configuration options
     */
    getAccessLayersConfiguration(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<AccessLayersConfigurationDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/access-layer/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccessLayersConfiguration(_response);
        });
    }

    protected processGetAccessLayersConfiguration(response: AxiosResponse): Promise<AccessLayersConfigurationDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessLayersConfigurationDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<AccessLayersConfigurationDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ServiceResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessLayersConfigurationDtoServiceResponse>(null as any);
    }

    /**
     * Get reference data
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The reference data is returned
     */
    getReferenceData(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<ReferenceDataDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/reference-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReferenceData(_response);
        });
    }

    protected processGetReferenceData(response: AxiosResponse): Promise<ReferenceDataDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReferenceDataDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<ReferenceDataDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReferenceDataDtoServiceResponse>(null as any);
    }

    /**
     * Get teams
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of teams is returned
     */
    getAllTeams(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<TeamDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/team";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllTeams(_response);
        });
    }

    protected processGetAllTeams(response: AxiosResponse): Promise<TeamDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TeamDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<TeamDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get team by id
     * @param id Team id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Team is returned
     */
    getTeam(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<TeamDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/team/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeam(_response);
        });
    }

    protected processGetTeam(response: AxiosResponse): Promise<TeamDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TeamDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<TeamDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ServiceResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamDtoServiceResponse>(null as any);
    }

    /**
     * Get user teams
     * @param id Team Id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list user ids is returned
     */
    getTeamUsers(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<StringIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/team/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeamUsers(_response);
        });
    }

    protected processGetTeamUsers(response: AxiosResponse): Promise<StringIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<StringIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get users
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of users is returned
     */
    getAllUsers(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<UserDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: AxiosResponse): Promise<UserDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<UserDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get user by id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. User is returned
     */
    getUserById(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<UserDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/user/{id}/profile";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: AxiosResponse): Promise<UserDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<UserDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDtoServiceResponse>(null as any);
    }

    /**
     * Get current user authorization profile
     * @param includeTeamDefinitions (optional) 
     * @param includeAccessLayersDefinitions (optional) 
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. User authorization profile is returned
     */
    getCurrentUserAuthorizationProfile(includeTeamDefinitions: boolean | undefined, includeAccessLayersDefinitions: boolean | undefined, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<UserAuthorizationProfileDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/user/authorization-profile?";
        if (includeTeamDefinitions === null)
            throw new Error("The parameter 'includeTeamDefinitions' cannot be null.");
        else if (includeTeamDefinitions !== undefined)
            url_ += "includeTeamDefinitions=" + encodeURIComponent("" + includeTeamDefinitions) + "&";
        if (includeAccessLayersDefinitions === null)
            throw new Error("The parameter 'includeAccessLayersDefinitions' cannot be null.");
        else if (includeAccessLayersDefinitions !== undefined)
            url_ += "includeAccessLayersDefinitions=" + encodeURIComponent("" + includeAccessLayersDefinitions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentUserAuthorizationProfile(_response);
        });
    }

    protected processGetCurrentUserAuthorizationProfile(response: AxiosResponse): Promise<UserAuthorizationProfileDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserAuthorizationProfileDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<UserAuthorizationProfileDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserAuthorizationProfileDtoServiceResponse>(null as any);
    }

    /**
     * Get current user authorization profile by user id
     * @param includeTeamDefinitions (optional) 
     * @param includeAccessLayersDefinitions (optional) 
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. User authorization profile is returned
     */
    getUserAuthorizationProfileById(id: string, includeTeamDefinitions: boolean | undefined, includeAccessLayersDefinitions: boolean | undefined, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<UserAuthorizationProfileDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/user/{id}/authorization-profile?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includeTeamDefinitions === null)
            throw new Error("The parameter 'includeTeamDefinitions' cannot be null.");
        else if (includeTeamDefinitions !== undefined)
            url_ += "includeTeamDefinitions=" + encodeURIComponent("" + includeTeamDefinitions) + "&";
        if (includeAccessLayersDefinitions === null)
            throw new Error("The parameter 'includeAccessLayersDefinitions' cannot be null.");
        else if (includeAccessLayersDefinitions !== undefined)
            url_ += "includeAccessLayersDefinitions=" + encodeURIComponent("" + includeAccessLayersDefinitions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserAuthorizationProfileById(_response);
        });
    }

    protected processGetUserAuthorizationProfileById(response: AxiosResponse): Promise<UserAuthorizationProfileDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserAuthorizationProfileDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<UserAuthorizationProfileDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserAuthorizationProfileDtoServiceResponse>(null as any);
    }
}

export enum AccessLayerDataTypeDto {
    Field = "Field",
    DataGroup = "DataGroup",
    Entity = "Entity",
    Journey = "Journey",
    Document = "Document",
    Search = "Search",
}

/** Response DTO representing access layer data */
export class AccessLayerDto implements IAccessLayerDto {
    /** The UiD of the team */
    id?: string;
    /** Name of the access layer
The value is calculated based on dataKey, type and dataType fields */
    name?: string | undefined;
    /** Data key of the access layer */
    dataKey?: string | undefined;
    /** Label of the access layer */
    label?: string | undefined;
    /** Description of the access layer */
    description?: string | undefined;
    type?: AccessLayerTypeDto;
    dataType?: AccessLayerDataTypeDto;
    /** List of user ids assigned to the access layer */
    users?: string[] | undefined;
    /** Version number for given Entity */
    version?: number;

    constructor(data?: IAccessLayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dataKey = _data["dataKey"];
            this.label = _data["label"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.dataType = _data["dataType"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): AccessLayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dataKey"] = this.dataKey;
        data["label"] = this.label;
        data["description"] = this.description;
        data["type"] = this.type;
        data["dataType"] = this.dataType;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing access layer data */
export interface IAccessLayerDto {
    /** The UiD of the team */
    id?: string;
    /** Name of the access layer
The value is calculated based on dataKey, type and dataType fields */
    name?: string | undefined;
    /** Data key of the access layer */
    dataKey?: string | undefined;
    /** Label of the access layer */
    label?: string | undefined;
    /** Description of the access layer */
    description?: string | undefined;
    type?: AccessLayerTypeDto;
    dataType?: AccessLayerDataTypeDto;
    /** List of user ids assigned to the access layer */
    users?: string[] | undefined;
    /** Version number for given Entity */
    version?: number;
}

/** Service response data */
export class AccessLayerDtoIEnumerableServiceResponse implements IAccessLayerDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: AccessLayerDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IAccessLayerDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AccessLayerDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccessLayerDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IAccessLayerDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: AccessLayerDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Service response data */
export class AccessLayerDtoServiceResponse implements IAccessLayerDtoServiceResponse {
    data?: AccessLayerDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IAccessLayerDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AccessLayerDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccessLayerDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IAccessLayerDtoServiceResponse {
    data?: AccessLayerDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing access layer reference data */
export class AccessLayerReferenceDto implements IAccessLayerReferenceDto {
    /** The UiD of the access layer */
    id?: string | undefined;
    /** Label of the access layer */
    label?: string | undefined;
    /** Data key of the access layer */
    dataKey?: string | undefined;
    type?: AccessLayerTypeDto;
    dataType?: AccessLayerDataTypeDto;

    constructor(data?: IAccessLayerReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.label = _data["label"];
            this.dataKey = _data["dataKey"];
            this.type = _data["type"];
            this.dataType = _data["dataType"];
        }
    }

    static fromJS(data: any): AccessLayerReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        data["dataKey"] = this.dataKey;
        data["type"] = this.type;
        data["dataType"] = this.dataType;
        return data;
    }
}

/** Response DTO representing access layer reference data */
export interface IAccessLayerReferenceDto {
    /** The UiD of the access layer */
    id?: string | undefined;
    /** Label of the access layer */
    label?: string | undefined;
    /** Data key of the access layer */
    dataKey?: string | undefined;
    type?: AccessLayerTypeDto;
    dataType?: AccessLayerDataTypeDto;
}

export enum AccessLayerTypeDto {
    Geographic = "Geographic",
    BusinessRelated = "BusinessRelated",
}

/** Response DTO representing access layers configuration */
export class AccessLayersConfigurationDto implements IAccessLayersConfigurationDto {
    /** If set to true default access layers (Enterprise, Global) will be populated automatically when creating a new entity */
    populateDefaultAccessLayers?: boolean;
    /** Current version of the access layers-related configuration where the changes needs to be applied. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;

    constructor(data?: IAccessLayersConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.populateDefaultAccessLayers = _data["populateDefaultAccessLayers"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): AccessLayersConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayersConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["populateDefaultAccessLayers"] = this.populateDefaultAccessLayers;
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing access layers configuration */
export interface IAccessLayersConfigurationDto {
    /** If set to true default access layers (Enterprise, Global) will be populated automatically when creating a new entity */
    populateDefaultAccessLayers?: boolean;
    /** Current version of the access layers-related configuration where the changes needs to be applied. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;
}

/** Service response data */
export class AccessLayersConfigurationDtoServiceResponse implements IAccessLayersConfigurationDtoServiceResponse {
    data?: AccessLayersConfigurationDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IAccessLayersConfigurationDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AccessLayersConfigurationDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccessLayersConfigurationDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayersConfigurationDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IAccessLayersConfigurationDtoServiceResponse {
    data?: AccessLayersConfigurationDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class AccessLayersConfigurationReferenceDto implements IAccessLayersConfigurationReferenceDto {
    /** If set to true default access layers (Enterprise, Global) will be populated automatically when creating a new entity */
    populateDefaultAccessLayers?: boolean;

    constructor(data?: IAccessLayersConfigurationReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.populateDefaultAccessLayers = _data["populateDefaultAccessLayers"];
        }
    }

    static fromJS(data: any): AccessLayersConfigurationReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayersConfigurationReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["populateDefaultAccessLayers"] = this.populateDefaultAccessLayers;
        return data;
    }
}

export interface IAccessLayersConfigurationReferenceDto {
    /** If set to true default access layers (Enterprise, Global) will be populated automatically when creating a new entity */
    populateDefaultAccessLayers?: boolean;
}

/** Service response data */
export class ObjectServiceResponse implements IObjectServiceResponse {
    /** The service response DTO */
    data?: any | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IObjectServiceResponse {
    /** The service response DTO */
    data?: any | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

/** Response DTO representing reference data */
export class ReferenceDataDto implements IReferenceDataDto {
    /** Collection of access layer reference data */
    accessLayers?: AccessLayerReferenceDto[] | undefined;
    /** Collection of user reference data */
    users?: UserReferenceDto[] | undefined;
    /** Collection of user reference data */
    teams?: TeamReferenceDto[] | undefined;
    accessLayersConfiguration?: AccessLayersConfigurationReferenceDto;

    constructor(data?: IReferenceDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["accessLayers"])) {
                this.accessLayers = [] as any;
                for (let item of _data["accessLayers"])
                    this.accessLayers!.push(AccessLayerReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserReferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["teams"])) {
                this.teams = [] as any;
                for (let item of _data["teams"])
                    this.teams!.push(TeamReferenceDto.fromJS(item));
            }
            this.accessLayersConfiguration = _data["accessLayersConfiguration"] ? AccessLayersConfigurationReferenceDto.fromJS(_data["accessLayersConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReferenceDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.accessLayers)) {
            data["accessLayers"] = [];
            for (let item of this.accessLayers)
                data["accessLayers"].push(item.toJSON());
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.teams)) {
            data["teams"] = [];
            for (let item of this.teams)
                data["teams"].push(item.toJSON());
        }
        data["accessLayersConfiguration"] = this.accessLayersConfiguration ? this.accessLayersConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

/** Response DTO representing reference data */
export interface IReferenceDataDto {
    /** Collection of access layer reference data */
    accessLayers?: AccessLayerReferenceDto[] | undefined;
    /** Collection of user reference data */
    users?: UserReferenceDto[] | undefined;
    /** Collection of user reference data */
    teams?: TeamReferenceDto[] | undefined;
    accessLayersConfiguration?: AccessLayersConfigurationReferenceDto;
}

/** Service response data */
export class ReferenceDataDtoServiceResponse implements IReferenceDataDtoServiceResponse {
    data?: ReferenceDataDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IReferenceDataDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ReferenceDataDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReferenceDataDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceDataDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IReferenceDataDtoServiceResponse {
    data?: ReferenceDataDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Service response data */
export class ServiceResponse implements IServiceResponse {
    /** The service response DTO */
    data?: string | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IServiceResponse {
    /** The service response DTO */
    data?: string | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** The message associated to the service response */
export class ServiceResponseMessage implements IServiceResponseMessage {
    /** The message */
    message?: string | undefined;
    /** Type of the message
One of Info, Warning, Error, Forbidden */
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

/** The message associated to the service response */
export interface IServiceResponseMessage {
    /** The message */
    message?: string | undefined;
    /** Type of the message
One of Info, Warning, Error, Forbidden */
    type?: string | undefined;
}

/** Service response data */
export class StringIEnumerableServiceResponse implements IStringIEnumerableServiceResponse {
    /** The service response DTO */
    data?: string[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IStringIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StringIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IStringIEnumerableServiceResponse {
    /** The service response DTO */
    data?: string[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing team data */
export class TeamDto implements ITeamDto {
    /** The UiD of the team */
    id?: string;
    /** Name of the team */
    name?: string | undefined;
    /** Team description */
    description?: string | undefined;
    /** List of permissions the team should have */
    scopes?: string[] | undefined;
    /** List of user ids assigned to the team */
    users?: string[] | undefined;
    /** Version number for given Entity */
    version?: number;

    constructor(data?: ITeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): TeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing team data */
export interface ITeamDto {
    /** The UiD of the team */
    id?: string;
    /** Name of the team */
    name?: string | undefined;
    /** Team description */
    description?: string | undefined;
    /** List of permissions the team should have */
    scopes?: string[] | undefined;
    /** List of user ids assigned to the team */
    users?: string[] | undefined;
    /** Version number for given Entity */
    version?: number;
}

/** Service response data */
export class TeamDtoIEnumerableServiceResponse implements ITeamDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: TeamDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ITeamDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TeamDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeamDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TeamDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface ITeamDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: TeamDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Service response data */
export class TeamDtoServiceResponse implements ITeamDtoServiceResponse {
    data?: TeamDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ITeamDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? TeamDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeamDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TeamDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface ITeamDtoServiceResponse {
    data?: TeamDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing team reference data */
export class TeamReferenceDto implements ITeamReferenceDto {
    /** The UiD of the team */
    id?: string | undefined;
    /** Name of the team */
    name?: string | undefined;
    /** List of user ids assigned to the team */
    users?: string[] | undefined;

    constructor(data?: ITeamReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
        }
    }

    static fromJS(data: any): TeamReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        return data;
    }
}

/** Response DTO representing team reference data */
export interface ITeamReferenceDto {
    /** The UiD of the team */
    id?: string | undefined;
    /** Name of the team */
    name?: string | undefined;
    /** List of user ids assigned to the team */
    users?: string[] | undefined;
}

/** Response DTO representing user profile access layer data */
export class UserAccessLayerDto implements IUserAccessLayerDto {
    /** The UiD of the access layer */
    id?: string;
    /** Value of the access layer */
    dataKey?: string | undefined;
    /** Label of the access layer */
    label?: string | undefined;
    type?: AccessLayerTypeDto;
    dataType?: AccessLayerDataTypeDto;

    constructor(data?: IUserAccessLayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataKey = _data["dataKey"];
            this.label = _data["label"];
            this.type = _data["type"];
            this.dataType = _data["dataType"];
        }
    }

    static fromJS(data: any): UserAccessLayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAccessLayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataKey"] = this.dataKey;
        data["label"] = this.label;
        data["type"] = this.type;
        data["dataType"] = this.dataType;
        return data;
    }
}

/** Response DTO representing user profile access layer data */
export interface IUserAccessLayerDto {
    /** The UiD of the access layer */
    id?: string;
    /** Value of the access layer */
    dataKey?: string | undefined;
    /** Label of the access layer */
    label?: string | undefined;
    type?: AccessLayerTypeDto;
    dataType?: AccessLayerDataTypeDto;
}

/** Response DTO representing user authorization profile data */
export class UserAuthorizationProfileDto implements IUserAuthorizationProfileDto {
    /** The UiD of the user */
    id?: string | undefined;
    /** List of teams user belongs to */
    teams?: UserProfileTeamDto[] | undefined;
    /** List of access layers assigned to the user */
    accessLayers?: UserAccessLayerDto[] | undefined;

    constructor(data?: IUserAuthorizationProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["teams"])) {
                this.teams = [] as any;
                for (let item of _data["teams"])
                    this.teams!.push(UserProfileTeamDto.fromJS(item));
            }
            if (Array.isArray(_data["accessLayers"])) {
                this.accessLayers = [] as any;
                for (let item of _data["accessLayers"])
                    this.accessLayers!.push(UserAccessLayerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserAuthorizationProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAuthorizationProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.teams)) {
            data["teams"] = [];
            for (let item of this.teams)
                data["teams"].push(item.toJSON());
        }
        if (Array.isArray(this.accessLayers)) {
            data["accessLayers"] = [];
            for (let item of this.accessLayers)
                data["accessLayers"].push(item.toJSON());
        }
        return data;
    }
}

/** Response DTO representing user authorization profile data */
export interface IUserAuthorizationProfileDto {
    /** The UiD of the user */
    id?: string | undefined;
    /** List of teams user belongs to */
    teams?: UserProfileTeamDto[] | undefined;
    /** List of access layers assigned to the user */
    accessLayers?: UserAccessLayerDto[] | undefined;
}

/** Service response data */
export class UserAuthorizationProfileDtoServiceResponse implements IUserAuthorizationProfileDtoServiceResponse {
    data?: UserAuthorizationProfileDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IUserAuthorizationProfileDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UserAuthorizationProfileDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserAuthorizationProfileDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserAuthorizationProfileDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IUserAuthorizationProfileDtoServiceResponse {
    data?: UserAuthorizationProfileDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing user data */
export class UserDto implements IUserDto {
    /** The UiD of the user */
    id?: string | undefined;
    /** Username */
    username?: string | undefined;
    /** User email */
    email?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["email"] = this.email;
        return data;
    }
}

/** Response DTO representing user data */
export interface IUserDto {
    /** The UiD of the user */
    id?: string | undefined;
    /** Username */
    username?: string | undefined;
    /** User email */
    email?: string | undefined;
}

/** Service response data */
export class UserDtoIEnumerableServiceResponse implements IUserDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: UserDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IUserDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IUserDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: UserDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Service response data */
export class UserDtoServiceResponse implements IUserDtoServiceResponse {
    data?: UserDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IUserDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IUserDtoServiceResponse {
    data?: UserDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing user profile team data */
export class UserProfileTeamDto implements IUserProfileTeamDto {
    /** The UiD of the team */
    id?: string;
    /** Name of the team */
    name?: string | undefined;
    /** List of permissions the team have */
    scopes?: string[] | undefined;

    constructor(data?: IUserProfileTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
        }
    }

    static fromJS(data: any): UserProfileTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        return data;
    }
}

/** Response DTO representing user profile team data */
export interface IUserProfileTeamDto {
    /** The UiD of the team */
    id?: string;
    /** Name of the team */
    name?: string | undefined;
    /** List of permissions the team have */
    scopes?: string[] | undefined;
}

/** Response DTO representing user reference data */
export class UserReferenceDto implements IUserReferenceDto {
    /** The UiD of the user */
    id?: string | undefined;
    /** Display name of the user */
    label?: string | undefined;

    constructor(data?: IUserReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): UserReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        return data;
    }
}

/** Response DTO representing user reference data */
export interface IUserReferenceDto {
    /** The UiD of the user */
    id?: string | undefined;
    /** Display name of the user */
    label?: string | undefined;
}

/** Represents the details of validation error */
export class ValidationErrorModel implements IValidationErrorModel {
    /** Name of the property */
    propertyName?: string | undefined;
    /** User friendly error message */
    errorMessage?: string | undefined;
    /** Invalid value */
    attemptedValue?: any | undefined;
    /** Internal error code */
    errorCode?: string | undefined;

    constructor(data?: IValidationErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            this.attemptedValue = _data["attemptedValue"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ValidationErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

/** Represents the details of validation error */
export interface IValidationErrorModel {
    /** Name of the property */
    propertyName?: string | undefined;
    /** User friendly error message */
    errorMessage?: string | undefined;
    /** Invalid value */
    attemptedValue?: any | undefined;
    /** Internal error code */
    errorCode?: string | undefined;
}

/** Service response data */
export class ValidationErrorModelListServiceResponse implements IValidationErrorModelListServiceResponse {
    /** The service response DTO */
    data?: ValidationErrorModel[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IValidationErrorModelListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ValidationErrorModel.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationErrorModelListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModelListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IValidationErrorModelListServiceResponse {
    /** The service response DTO */
    data?: ValidationErrorModel[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}