//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * Allows clearing the Logic Engine API cache.
    This is an maintenance endpoint and does not need to be used under normal circumstances.
     * @param clearRequirementsCache (optional) If the Requirements cache should be flushed
     * @param clearRequirementSetsCache (optional) If the Requirement sets cache should be flushed
     * @param clearDataGroupsCache (optional) If the DataGroup cache should be flushed
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Cache was flushed successfully.
     */
    flush(clearRequirementsCache: boolean | undefined, clearRequirementSetsCache: boolean | undefined, clearDataGroupsCache: boolean | undefined, x_TENANT_ID: string): Promise<ClearCacheResponseDtoServiceResponse>;
    /**
     * Evaluate requirement set
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Service request with entity data properties required for evaluation
     * @return Success. The list of evaluated requirement sets is returned
     */
    evaluateRequirementSetsV3(x_TENANT_ID: string, body: EvaluateRequirementSetsRequestV2DtoServiceRequest | undefined): Promise<EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse>;
    /**
     * Evaluate requirement
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Service request with key-value data required for evaluation
     * @return Success. The list of evaluated requirements is returned
     */
    evaluateV3(x_TENANT_ID: string, body: EvaluateRequirementsRequestV3DtoServiceRequest | undefined): Promise<RequirementDtoListServiceResponse>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/policylogicengine";

    }

    /**
     * Allows clearing the Logic Engine API cache.
    This is an maintenance endpoint and does not need to be used under normal circumstances.
     * @param clearRequirementsCache (optional) If the Requirements cache should be flushed
     * @param clearRequirementSetsCache (optional) If the Requirement sets cache should be flushed
     * @param clearDataGroupsCache (optional) If the DataGroup cache should be flushed
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Cache was flushed successfully.
     */
    flush(clearRequirementsCache: boolean | undefined, clearRequirementSetsCache: boolean | undefined, clearDataGroupsCache: boolean | undefined, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<ClearCacheResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v3/cache/flush?";
        if (clearRequirementsCache === null)
            throw new Error("The parameter 'clearRequirementsCache' cannot be null.");
        else if (clearRequirementsCache !== undefined)
            url_ += "clearRequirementsCache=" + encodeURIComponent("" + clearRequirementsCache) + "&";
        if (clearRequirementSetsCache === null)
            throw new Error("The parameter 'clearRequirementSetsCache' cannot be null.");
        else if (clearRequirementSetsCache !== undefined)
            url_ += "clearRequirementSetsCache=" + encodeURIComponent("" + clearRequirementSetsCache) + "&";
        if (clearDataGroupsCache === null)
            throw new Error("The parameter 'clearDataGroupsCache' cannot be null.");
        else if (clearDataGroupsCache !== undefined)
            url_ += "clearDataGroupsCache=" + encodeURIComponent("" + clearDataGroupsCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFlush(_response);
        });
    }

    protected processFlush(response: AxiosResponse): Promise<ClearCacheResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClearCacheResponseDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<ClearCacheResponseDtoServiceResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClearCacheResponseDtoServiceResponse>(null as any);
    }

    /**
     * Evaluate requirement set
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Service request with entity data properties required for evaluation
     * @return Success. The list of evaluated requirement sets is returned
     */
    evaluateRequirementSetsV3(x_TENANT_ID: string, body: EvaluateRequirementSetsRequestV2DtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/v3/engine/evaluate-requirement-sets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvaluateRequirementSetsV3(_response);
        });
    }

    protected processEvaluateRequirementSetsV3(response: AxiosResponse): Promise<EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Evaluate requirement
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Service request with key-value data required for evaluation
     * @return Success. The list of evaluated requirements is returned
     */
    evaluateV3(x_TENANT_ID: string, body: EvaluateRequirementsRequestV3DtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<RequirementDtoListServiceResponse> {
        let url_ = this.baseUrl + "/api/v3/engine/evaluate-requirements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvaluateV3(_response);
        });
    }

    protected processEvaluateV3(response: AxiosResponse): Promise<RequirementDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequirementDtoListServiceResponse.fromJS(resultData200);
            return Promise.resolve<RequirementDtoListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequirementDtoListServiceResponse>(null as any);
    }
}

/** DTO representing associated access layers */
export class AccessLayerDto implements IAccessLayerDto {
    /** Collection of geographic access layers e.g. ["Global"] */
    geographic?: string[] | undefined;
    /** Collection of business related access layers e.g. ["Global"] */
    businessRelated?: string[] | undefined;

    constructor(data?: IAccessLayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["geographic"])) {
                this.geographic = [] as any;
                for (let item of _data["geographic"])
                    this.geographic!.push(item);
            }
            if (Array.isArray(_data["businessRelated"])) {
                this.businessRelated = [] as any;
                for (let item of _data["businessRelated"])
                    this.businessRelated!.push(item);
            }
        }
    }

    static fromJS(data: any): AccessLayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.geographic)) {
            data["geographic"] = [];
            for (let item of this.geographic)
                data["geographic"].push(item);
        }
        if (Array.isArray(this.businessRelated)) {
            data["businessRelated"] = [];
            for (let item of this.businessRelated)
                data["businessRelated"].push(item);
        }
        return data;
    }
}

/** DTO representing associated access layers */
export interface IAccessLayerDto {
    /** Collection of geographic access layers e.g. ["Global"] */
    geographic?: string[] | undefined;
    /** Collection of business related access layers e.g. ["Global"] */
    businessRelated?: string[] | undefined;
}

/** Request DTO representing basic validation rule metadata */
export class BasicRuleDto implements IBasicRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;

    constructor(data?: IBasicRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): BasicRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new BasicRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        return data;
    }
}

/** Request DTO representing basic validation rule metadata */
export interface IBasicRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
}

/** Represents the clear cache response */
export class ClearCacheResponseDto implements IClearCacheResponseDto {
    /** If true, the Requirements rules cache was cleared
<example>true</example> */
    requirementsCacheCleared?: boolean;
    /** If true, the RequirementsSets rules cache was cleared
<example>true</example> */
    requirementSetsCacheCleared?: boolean;
    /** If true, the DataGroup rules cache was cleared
<example>true</example> */
    dataGroupsCacheCleared?: boolean;

    constructor(data?: IClearCacheResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requirementsCacheCleared = _data["requirementsCacheCleared"];
            this.requirementSetsCacheCleared = _data["requirementSetsCacheCleared"];
            this.dataGroupsCacheCleared = _data["dataGroupsCacheCleared"];
        }
    }

    static fromJS(data: any): ClearCacheResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClearCacheResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requirementsCacheCleared"] = this.requirementsCacheCleared;
        data["requirementSetsCacheCleared"] = this.requirementSetsCacheCleared;
        data["dataGroupsCacheCleared"] = this.dataGroupsCacheCleared;
        return data;
    }
}

/** Represents the clear cache response */
export interface IClearCacheResponseDto {
    /** If true, the Requirements rules cache was cleared
<example>true</example> */
    requirementsCacheCleared?: boolean;
    /** If true, the RequirementsSets rules cache was cleared
<example>true</example> */
    requirementSetsCacheCleared?: boolean;
    /** If true, the DataGroup rules cache was cleared
<example>true</example> */
    dataGroupsCacheCleared?: boolean;
}

export class ClearCacheResponseDtoServiceResponse implements IClearCacheResponseDtoServiceResponse {
    /** Represents the clear cache response */
    data?: ClearCacheResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IClearCacheResponseDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ClearCacheResponseDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClearCacheResponseDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClearCacheResponseDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClearCacheResponseDtoServiceResponse {
    /** Represents the clear cache response */
    data?: ClearCacheResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class CollectionDto implements ICollectionDto {
    isValid?: boolean;
    properties?: { [key: string]: string; } | undefined;

    constructor(data?: ICollectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface ICollectionDto {
    isValid?: boolean;
    properties?: { [key: string]: string; } | undefined;
}

/** Request DTO representing collection maximum count validation rule metadata */
export class CollectionMaximumCountRuleDto implements ICollectionMaximumCountRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Dictionary of required Primary Data Group Field values with maximum count */
    requiredTypesMaxCount?: { [key: string]: number; } | undefined;
    /** Overall maximum count */
    overallMaximumCount?: number | undefined;

    constructor(data?: ICollectionMaximumCountRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            if (_data["requiredTypesMaxCount"]) {
                this.requiredTypesMaxCount = {} as any;
                for (let key in _data["requiredTypesMaxCount"]) {
                    if (_data["requiredTypesMaxCount"].hasOwnProperty(key))
                        (<any>this.requiredTypesMaxCount)![key] = _data["requiredTypesMaxCount"][key];
                }
            }
            this.overallMaximumCount = _data["overallMaximumCount"];
        }
    }

    static fromJS(data: any): CollectionMaximumCountRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionMaximumCountRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        if (this.requiredTypesMaxCount) {
            data["requiredTypesMaxCount"] = {};
            for (let key in this.requiredTypesMaxCount) {
                if (this.requiredTypesMaxCount.hasOwnProperty(key))
                    (<any>data["requiredTypesMaxCount"])[key] = (<any>this.requiredTypesMaxCount)[key];
            }
        }
        data["overallMaximumCount"] = this.overallMaximumCount;
        return data;
    }
}

/** Request DTO representing collection maximum count validation rule metadata */
export interface ICollectionMaximumCountRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Dictionary of required Primary Data Group Field values with maximum count */
    requiredTypesMaxCount?: { [key: string]: number; } | undefined;
    /** Overall maximum count */
    overallMaximumCount?: number | undefined;
}

/** Request DTO representing collection minimum count validation rule metadata */
export class CollectionMinimumCountRuleDto implements ICollectionMinimumCountRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Dictionary of required Primary Data Group Field values with minimum count */
    requiredTypesMinCount?: { [key: string]: number; } | undefined;
    /** Overall minimum count */
    overallMinimumCount?: number;

    constructor(data?: ICollectionMinimumCountRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            if (_data["requiredTypesMinCount"]) {
                this.requiredTypesMinCount = {} as any;
                for (let key in _data["requiredTypesMinCount"]) {
                    if (_data["requiredTypesMinCount"].hasOwnProperty(key))
                        (<any>this.requiredTypesMinCount)![key] = _data["requiredTypesMinCount"][key];
                }
            }
            this.overallMinimumCount = _data["overallMinimumCount"];
        }
    }

    static fromJS(data: any): CollectionMinimumCountRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionMinimumCountRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        if (this.requiredTypesMinCount) {
            data["requiredTypesMinCount"] = {};
            for (let key in this.requiredTypesMinCount) {
                if (this.requiredTypesMinCount.hasOwnProperty(key))
                    (<any>data["requiredTypesMinCount"])[key] = (<any>this.requiredTypesMinCount)[key];
            }
        }
        data["overallMinimumCount"] = this.overallMinimumCount;
        return data;
    }
}

/** Request DTO representing collection minimum count validation rule metadata */
export interface ICollectionMinimumCountRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Dictionary of required Primary Data Group Field values with minimum count */
    requiredTypesMinCount?: { [key: string]: number; } | undefined;
    /** Overall minimum count */
    overallMinimumCount?: number;
}

export class PropertyDto implements IPropertyDto {
    isValid?: boolean | undefined;

    protected _discriminator: string;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "PropertyDto";
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "Collection") {
            let result = new CollectionPropertyDto();
            result.init(data);
            return result;
        }
        if (data["type"] === "Custom") {
            let result = new CustomPropertyDto();
            result.init(data);
            return result;
        }
        if (data["type"] === "Single") {
            let result = new SinglePropertyDto();
            result.init(data);
            return result;
        }
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator;
        data["isValid"] = this.isValid;
        return data;
    }
}

export interface IPropertyDto {
    isValid?: boolean | undefined;
}

export class CollectionPropertyDto extends PropertyDto implements ICollectionPropertyDto {
    dataGroupId?: string;
    dataGroupVersionNumber?: number | undefined;
    collections?: { [key: string]: CollectionDto; } | undefined;

    constructor(data?: ICollectionPropertyDto) {
        super(data);
        this._discriminator = "Collection";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dataGroupId = _data["dataGroupId"];
            this.dataGroupVersionNumber = _data["dataGroupVersionNumber"];
            if (_data["collections"]) {
                this.collections = {} as any;
                for (let key in _data["collections"]) {
                    if (_data["collections"].hasOwnProperty(key))
                        (<any>this.collections)![key] = _data["collections"][key] ? CollectionDto.fromJS(_data["collections"][key]) : new CollectionDto();
                }
            }
        }
    }

    static fromJS(data: any): CollectionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataGroupId"] = this.dataGroupId;
        data["dataGroupVersionNumber"] = this.dataGroupVersionNumber;
        if (this.collections) {
            data["collections"] = {};
            for (let key in this.collections) {
                if (this.collections.hasOwnProperty(key))
                    (<any>data["collections"])[key] = this.collections[key] ? this.collections[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICollectionPropertyDto extends IPropertyDto {
    dataGroupId?: string;
    dataGroupVersionNumber?: number | undefined;
    collections?: { [key: string]: CollectionDto; } | undefined;
}

export class ConditionDefinitionDto implements IConditionDefinitionDto {
    fieldName?: string | undefined;
    value?: string[] | undefined;
    valueType?: string | undefined;
    dataSource?: string | undefined;
    operation?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;

    constructor(data?: IConditionDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.valueType = _data["valueType"];
            this.dataSource = _data["dataSource"];
            this.operation = _data["operation"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["valueType"] = this.valueType;
        data["dataSource"] = this.dataSource;
        data["operation"] = this.operation;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConditionDefinitionDto {
    fieldName?: string | undefined;
    value?: string[] | undefined;
    valueType?: string | undefined;
    dataSource?: string | undefined;
    operation?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;
}

export class ConditionDto implements IConditionDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;

    constructor(data?: IConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConditionDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;
}

export class ConditionalValueDto implements IConditionalValueDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;
    value?: string | undefined;
    priority?: number;

    constructor(data?: IConditionalValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
            this.value = _data["value"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): ConditionalValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionalValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        data["value"] = this.value;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IConditionalValueDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinitionDto[] | undefined;
    value?: string | undefined;
    priority?: number;
}

export class CustomPropertyDto extends PropertyDto implements ICustomPropertyDto {
    customTypeId?: string;
    properties?: { [key: string]: PropertyDto; } | undefined;

    constructor(data?: ICustomPropertyDto) {
        super(data);
        this._discriminator = "Custom";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customTypeId = _data["customTypeId"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): CustomPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTypeId"] = this.customTypeId;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICustomPropertyDto extends IPropertyDto {
    customTypeId?: string;
    properties?: { [key: string]: PropertyDto; } | undefined;
}

/** Response DTO representing data field data */
export class DataFieldDto implements IDataFieldDto {
    /** Property name */
    propertyName?: string | undefined;
    /** Property type */
    propertyType?: string | undefined;
    /** Property type id */
    propertyTypeId?: string | undefined;
    /** Linked child field property name */
    linkChildFieldPropertyName?: string | undefined;

    constructor(data?: IDataFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.propertyType = _data["propertyType"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.linkChildFieldPropertyName = _data["linkChildFieldPropertyName"];
        }
    }

    static fromJS(data: any): DataFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["propertyType"] = this.propertyType;
        data["propertyTypeId"] = this.propertyTypeId;
        data["linkChildFieldPropertyName"] = this.linkChildFieldPropertyName;
        return data;
    }
}

/** Response DTO representing data field data */
export interface IDataFieldDto {
    /** Property name */
    propertyName?: string | undefined;
    /** Property type */
    propertyType?: string | undefined;
    /** Property type id */
    propertyTypeId?: string | undefined;
    /** Linked child field property name */
    linkChildFieldPropertyName?: string | undefined;
}

/** Request DTO representing date limit rule metadata */
export class DateLimitRuleDto implements IDateLimitRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Minimum date */
    minDate?: Date | undefined;
    /** Maximum date */
    maxDate?: Date | undefined;

    constructor(data?: IDateLimitRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            this.minDate = _data["minDate"] ? new Date(_data["minDate"].toString()) : <any>undefined;
            this.maxDate = _data["maxDate"] ? new Date(_data["maxDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateLimitRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateLimitRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        data["minDate"] = this.minDate ? this.minDate.toISOString() : <any>undefined;
        data["maxDate"] = this.maxDate ? this.maxDate.toISOString() : <any>undefined;
        return data;
    }
}

/** Request DTO representing date limit rule metadata */
export interface IDateLimitRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Minimum date */
    minDate?: Date | undefined;
    /** Maximum date */
    maxDate?: Date | undefined;
}

/** Request DTO representing entity data properties used to evaluate the condition of requirement set */
export class EvaluateRequirementSetsRequestV2Dto implements IEvaluateRequirementSetsRequestV2Dto {
    /** Entity data properties for condition evaluation */
    properties!: { [key: string]: PropertyDto; };

    constructor(data?: IEvaluateRequirementSetsRequestV2Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): EvaluateRequirementSetsRequestV2Dto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementSetsRequestV2Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Request DTO representing entity data properties used to evaluate the condition of requirement set */
export interface IEvaluateRequirementSetsRequestV2Dto {
    /** Entity data properties for condition evaluation */
    properties: { [key: string]: PropertyDto; };
}

export class EvaluateRequirementSetsRequestV2DtoServiceRequest implements IEvaluateRequirementSetsRequestV2DtoServiceRequest {
    /** Request DTO representing entity data properties used to evaluate the condition of requirement set */
    data?: EvaluateRequirementSetsRequestV2Dto | undefined;

    constructor(data?: IEvaluateRequirementSetsRequestV2DtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EvaluateRequirementSetsRequestV2Dto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EvaluateRequirementSetsRequestV2DtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementSetsRequestV2DtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEvaluateRequirementSetsRequestV2DtoServiceRequest {
    /** Request DTO representing entity data properties used to evaluate the condition of requirement set */
    data?: EvaluateRequirementSetsRequestV2Dto | undefined;
}

/** Response DTO representing parameters of matched requirement set */
export class EvaluateRequirementSetsResponseDto implements IEvaluateRequirementSetsResponseDto {
    /** The UiD of matched requirement set */
    requirementSetId?: string;
    /** Name of matched requirement set */
    name?: string | undefined;
    /** Jurisdiction of matched requirement set */
    jurisdiction?: string | undefined;

    constructor(data?: IEvaluateRequirementSetsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requirementSetId = _data["requirementSetId"];
            this.name = _data["name"];
            this.jurisdiction = _data["jurisdiction"];
        }
    }

    static fromJS(data: any): EvaluateRequirementSetsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementSetsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requirementSetId"] = this.requirementSetId;
        data["name"] = this.name;
        data["jurisdiction"] = this.jurisdiction;
        return data;
    }
}

/** Response DTO representing parameters of matched requirement set */
export interface IEvaluateRequirementSetsResponseDto {
    /** The UiD of matched requirement set */
    requirementSetId?: string;
    /** Name of matched requirement set */
    name?: string | undefined;
    /** Jurisdiction of matched requirement set */
    jurisdiction?: string | undefined;
}

export class EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse implements IEvaluateRequirementSetsResponseDtoIEnumerableServiceResponse {
    data?: EvaluateRequirementSetsResponseDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEvaluateRequirementSetsResponseDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EvaluateRequirementSetsResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementSetsResponseDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEvaluateRequirementSetsResponseDtoIEnumerableServiceResponse {
    data?: EvaluateRequirementSetsResponseDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Request DTO representing object used to evaluate the condition of requirement */
export class EvaluateRequirementsRequestV3Dto implements IEvaluateRequirementsRequestV3Dto {
    /** List of versioned jurisdiction */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of requirement types [Data, Document, OwnershipAndControl] */
    requirementTypes?: string[] | undefined;
    /** Entity data properties for condition evaluation */
    properties!: { [key: string]: PropertyDto; };
    /** Target entity */
    targetEntity?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    categories?: string[] | undefined;

    constructor(data?: IEvaluateRequirementsRequestV3Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(VersionedJurisdictionDto.fromJS(item));
            }
            if (Array.isArray(_data["requirementTypes"])) {
                this.requirementTypes = [] as any;
                for (let item of _data["requirementTypes"])
                    this.requirementTypes!.push(item);
            }
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
            this.targetEntity = _data["targetEntity"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
        }
    }

    static fromJS(data: any): EvaluateRequirementsRequestV3Dto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementsRequestV3Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item.toJSON());
        }
        if (Array.isArray(this.requirementTypes)) {
            data["requirementTypes"] = [];
            for (let item of this.requirementTypes)
                data["requirementTypes"].push(item);
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        data["targetEntity"] = this.targetEntity;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        return data;
    }
}

/** Request DTO representing object used to evaluate the condition of requirement */
export interface IEvaluateRequirementsRequestV3Dto {
    /** List of versioned jurisdiction */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of requirement types [Data, Document, OwnershipAndControl] */
    requirementTypes?: string[] | undefined;
    /** Entity data properties for condition evaluation */
    properties: { [key: string]: PropertyDto; };
    /** Target entity */
    targetEntity?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    categories?: string[] | undefined;
}

export class EvaluateRequirementsRequestV3DtoServiceRequest implements IEvaluateRequirementsRequestV3DtoServiceRequest {
    /** Request DTO representing object used to evaluate the condition of requirement */
    data?: EvaluateRequirementsRequestV3Dto | undefined;

    constructor(data?: IEvaluateRequirementsRequestV3DtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EvaluateRequirementsRequestV3Dto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EvaluateRequirementsRequestV3DtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementsRequestV3DtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEvaluateRequirementsRequestV3DtoServiceRequest {
    /** Request DTO representing object used to evaluate the condition of requirement */
    data?: EvaluateRequirementsRequestV3Dto | undefined;
}

export class ObjectServiceResponse implements IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class OwnershipValidationDataDto implements IOwnershipValidationDataDto {
    /** Mandatory requirement */
    isMandatory?: BasicRuleDto | undefined;
    /** What is the minimum number of relationships that need to be added in order for this requirement to be fulfilled? */
    partyCount?: ValueLimitRuleDto | undefined;
    /** Is the unwrapping requirement non-calculable? */
    addAllParties?: BasicRuleDto | undefined;
    /** Mandatory ID&V */
    idvIsMandatory?: BasicRuleDto | undefined;
    /** What is the minimum number of relationships that need to be ID&Vd in order for this requirement to be fulfilled? */
    idvPartyCount?: ValueLimitRuleDto | undefined;
    /** Do all entities that meet the criteria of this requirement need to be ID&Vd? */
    idvAllParties?: BasicRuleDto | undefined;

    constructor(data?: IOwnershipValidationDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isMandatory = _data["isMandatory"] ? BasicRuleDto.fromJS(_data["isMandatory"]) : <any>undefined;
            this.partyCount = _data["partyCount"] ? ValueLimitRuleDto.fromJS(_data["partyCount"]) : <any>undefined;
            this.addAllParties = _data["addAllParties"] ? BasicRuleDto.fromJS(_data["addAllParties"]) : <any>undefined;
            this.idvIsMandatory = _data["idvIsMandatory"] ? BasicRuleDto.fromJS(_data["idvIsMandatory"]) : <any>undefined;
            this.idvPartyCount = _data["idvPartyCount"] ? ValueLimitRuleDto.fromJS(_data["idvPartyCount"]) : <any>undefined;
            this.idvAllParties = _data["idvAllParties"] ? BasicRuleDto.fromJS(_data["idvAllParties"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OwnershipValidationDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnershipValidationDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMandatory"] = this.isMandatory ? this.isMandatory.toJSON() : <any>undefined;
        data["partyCount"] = this.partyCount ? this.partyCount.toJSON() : <any>undefined;
        data["addAllParties"] = this.addAllParties ? this.addAllParties.toJSON() : <any>undefined;
        data["idvIsMandatory"] = this.idvIsMandatory ? this.idvIsMandatory.toJSON() : <any>undefined;
        data["idvPartyCount"] = this.idvPartyCount ? this.idvPartyCount.toJSON() : <any>undefined;
        data["idvAllParties"] = this.idvAllParties ? this.idvAllParties.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOwnershipValidationDataDto {
    /** Mandatory requirement */
    isMandatory?: BasicRuleDto | undefined;
    /** What is the minimum number of relationships that need to be added in order for this requirement to be fulfilled? */
    partyCount?: ValueLimitRuleDto | undefined;
    /** Is the unwrapping requirement non-calculable? */
    addAllParties?: BasicRuleDto | undefined;
    /** Mandatory ID&V */
    idvIsMandatory?: BasicRuleDto | undefined;
    /** What is the minimum number of relationships that need to be ID&Vd in order for this requirement to be fulfilled? */
    idvPartyCount?: ValueLimitRuleDto | undefined;
    /** Do all entities that meet the criteria of this requirement need to be ID&Vd? */
    idvAllParties?: BasicRuleDto | undefined;
}

export class OwnershipValidationRuleDto implements IOwnershipValidationRuleDto {
    /** The UiD of the ownership validation rule */
    id?: string;
    /** The UiD of the requirement set */
    setId?: string;
    /** Ownership Validation Data - set of validation rules specific to ownership requirement */
    ownershipValidationData?: OwnershipValidationDataDto | undefined;

    constructor(data?: IOwnershipValidationRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.setId = _data["setId"];
            this.ownershipValidationData = _data["ownershipValidationData"] ? OwnershipValidationDataDto.fromJS(_data["ownershipValidationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OwnershipValidationRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnershipValidationRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["setId"] = this.setId;
        data["ownershipValidationData"] = this.ownershipValidationData ? this.ownershipValidationData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOwnershipValidationRuleDto {
    /** The UiD of the ownership validation rule */
    id?: string;
    /** The UiD of the requirement set */
    setId?: string;
    /** Ownership Validation Data - set of validation rules specific to ownership requirement */
    ownershipValidationData?: OwnershipValidationDataDto | undefined;
}

export enum PropertyType {
    Single = "Single",
    Custom = "Custom",
    Collection = "Collection",
}

/** Request DTO representing reference metadata */
export class ReferenceDto implements IReferenceDto {
    /** Reference type */
    type?: string | undefined;
    /** Reference description */
    description?: string | undefined;
    /** Reference URL */
    url?: string | undefined;

    constructor(data?: IReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.description = _data["description"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): ReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["url"] = this.url;
        return data;
    }
}

/** Request DTO representing reference metadata */
export interface IReferenceDto {
    /** Reference type */
    type?: string | undefined;
    /** Reference description */
    description?: string | undefined;
    /** Reference URL */
    url?: string | undefined;
}

/** Request DTO representing regex rule metadata */
export class RegexRuleDto implements IRegexRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Flag that indicate if regex is case sensitive */
    isCaseSensitive?: boolean;
    /** Regex expression */
    regexValue?: string | undefined;

    constructor(data?: IRegexRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            this.isCaseSensitive = _data["isCaseSensitive"];
            this.regexValue = _data["regexValue"];
        }
    }

    static fromJS(data: any): RegexRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegexRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        data["isCaseSensitive"] = this.isCaseSensitive;
        data["regexValue"] = this.regexValue;
        return data;
    }
}

/** Request DTO representing regex rule metadata */
export interface IRegexRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Flag that indicate if regex is case sensitive */
    isCaseSensitive?: boolean;
    /** Regex expression */
    regexValue?: string | undefined;
}

/** Request DTO representing requirement metadata */
export class RequirementDto implements IRequirementDto {
    /** The UiD of the root requirement set version */
    rootVersionId?: string;
    /** Requirement set version number */
    versionNumber?: number;
    /** The UiD of the requirement */
    id?: string;
    /** The UiD of the tenant */
    tenant?: string | undefined;
    /** Requirement business category */
    category?: string | undefined;
    /** Requirement description */
    description?: string | undefined;
    /** Requirement template */
    template?: string | undefined;
    /** Requirement entity type */
    entityType?: string | undefined;
    /** Requirement name */
    name?: string | undefined;
    /** Requirement sensitive data flag */
    isSensitiveData?: boolean;
    /** Requirement material data flag */
    isMaterialData?: boolean;
    /** Requirement is defined as core
and cannot be deleted or altered */
    isCoreDefinition?: boolean;
    /** Requirement jurisdiction */
    jurisdiction?: string | undefined;
    /** Requirement references list */
    references?: ReferenceDto[] | undefined;
    /** Requirement target entity */
    targetEntity?: string | undefined;
    /** Requirement classification */
    classification?: string | undefined;
    /** Requirement type */
    type?: string | undefined;
    /** Requirement conditions list */
    conditions?: ConditionDto[] | undefined;
    /** The UiD of the current requirement set version */
    requirementSetId?: string;
    /** The UiD of the current requirement set version */
    versionId?: string;
    /** Data Field */
    dataField?: DataFieldDto | undefined;
    /** Order */
    order?: number | undefined;
    /** Default Value */
    defaultValue?: string | undefined;
    /** Is requirement readonly */
    isReadOnly?: boolean;
    /** Is requirement indexable */
    isIndexable?: boolean;
    /** Is requirement mandatory indexable */
    isMandatoryIndexable?: boolean;
    /** Is requirement mandatory */
    isMandatory?: boolean;
    /** Document Description */
    documentDescription?: string | undefined;
    /** Document Data Key */
    documentDataKey?: string | undefined;
    /** Document Access Layers */
    documentAccessLayers?: AccessLayerDto | undefined;
    /** Ownership Data Key */
    ownershipDataKey?: string | undefined;
    /** Party Types e.g. ["Director"] */
    partyTypes?: string[] | undefined;
    /** UBO Threshold */
    uboThreshold?: number | undefined;
    /** Types of Related Party Entity e.g. ["Individual"] */
    relatedPartyEntityTypes?: string[] | undefined;
    /** Is Only direct association */
    directAssociationsOnly?: boolean;
    /** Is Idv On */
    idvOn?: boolean;
    /** Idv Name */
    idvName?: string | undefined;
    /** Idv Tooltip */
    idvTooltip?: string | undefined;
    /** Ownership Validation Rule */
    ownershipValidationRule?: OwnershipValidationRuleDto | undefined;
    /** Validation Rule */
    validationRule?: ValidationRuleDto | undefined;
    /** List of conditional values */
    conditionalValues?: ConditionalValueDto[] | undefined;
    /** Does this field has evaluated conditional value? */
    hasEvaluatedConditionalValue?: boolean;
    /** Evaluated conditional value */
    evaluatedConditionalValue?: string | undefined;

    constructor(data?: IRequirementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootVersionId = _data["rootVersionId"];
            this.versionNumber = _data["versionNumber"];
            this.id = _data["id"];
            this.tenant = _data["tenant"];
            this.category = _data["category"];
            this.description = _data["description"];
            this.template = _data["template"];
            this.entityType = _data["entityType"];
            this.name = _data["name"];
            this.isSensitiveData = _data["isSensitiveData"];
            this.isMaterialData = _data["isMaterialData"];
            this.isCoreDefinition = _data["isCoreDefinition"];
            this.jurisdiction = _data["jurisdiction"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(ReferenceDto.fromJS(item));
            }
            this.targetEntity = _data["targetEntity"];
            this.classification = _data["classification"];
            this.type = _data["type"];
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            this.requirementSetId = _data["RequirementSetId"];
            this.versionId = _data["versionId"];
            this.dataField = _data["dataField"] ? DataFieldDto.fromJS(_data["dataField"]) : <any>undefined;
            this.order = _data["order"];
            this.defaultValue = _data["defaultValue"];
            this.isReadOnly = _data["isReadOnly"];
            this.isIndexable = _data["isIndexable"];
            this.isMandatoryIndexable = _data["isMandatoryIndexable"];
            this.isMandatory = _data["isMandatory"];
            this.documentDescription = _data["documentDescription"];
            this.documentDataKey = _data["documentDataKey"];
            this.documentAccessLayers = _data["documentAccessLayers"] ? AccessLayerDto.fromJS(_data["documentAccessLayers"]) : <any>undefined;
            this.ownershipDataKey = _data["ownershipDataKey"];
            if (Array.isArray(_data["partyTypes"])) {
                this.partyTypes = [] as any;
                for (let item of _data["partyTypes"])
                    this.partyTypes!.push(item);
            }
            this.uboThreshold = _data["uboThreshold"];
            if (Array.isArray(_data["relatedPartyEntityTypes"])) {
                this.relatedPartyEntityTypes = [] as any;
                for (let item of _data["relatedPartyEntityTypes"])
                    this.relatedPartyEntityTypes!.push(item);
            }
            this.directAssociationsOnly = _data["directAssociationsOnly"];
            this.idvOn = _data["idvOn"];
            this.idvName = _data["idvName"];
            this.idvTooltip = _data["idvTooltip"];
            this.ownershipValidationRule = _data["ownershipValidationRule"] ? OwnershipValidationRuleDto.fromJS(_data["ownershipValidationRule"]) : <any>undefined;
            this.validationRule = _data["validationRule"] ? ValidationRuleDto.fromJS(_data["validationRule"]) : <any>undefined;
            if (Array.isArray(_data["conditionalValues"])) {
                this.conditionalValues = [] as any;
                for (let item of _data["conditionalValues"])
                    this.conditionalValues!.push(ConditionalValueDto.fromJS(item));
            }
            this.hasEvaluatedConditionalValue = _data["hasEvaluatedConditionalValue"];
            this.evaluatedConditionalValue = _data["evaluatedConditionalValue"];
        }
    }

    static fromJS(data: any): RequirementDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootVersionId"] = this.rootVersionId;
        data["versionNumber"] = this.versionNumber;
        data["id"] = this.id;
        data["tenant"] = this.tenant;
        data["category"] = this.category;
        data["description"] = this.description;
        data["template"] = this.template;
        data["entityType"] = this.entityType;
        data["name"] = this.name;
        data["isSensitiveData"] = this.isSensitiveData;
        data["isMaterialData"] = this.isMaterialData;
        data["isCoreDefinition"] = this.isCoreDefinition;
        data["jurisdiction"] = this.jurisdiction;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item.toJSON());
        }
        data["targetEntity"] = this.targetEntity;
        data["classification"] = this.classification;
        data["type"] = this.type;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["RequirementSetId"] = this.requirementSetId;
        data["versionId"] = this.versionId;
        data["dataField"] = this.dataField ? this.dataField.toJSON() : <any>undefined;
        data["order"] = this.order;
        data["defaultValue"] = this.defaultValue;
        data["isReadOnly"] = this.isReadOnly;
        data["isIndexable"] = this.isIndexable;
        data["isMandatoryIndexable"] = this.isMandatoryIndexable;
        data["isMandatory"] = this.isMandatory;
        data["documentDescription"] = this.documentDescription;
        data["documentDataKey"] = this.documentDataKey;
        data["documentAccessLayers"] = this.documentAccessLayers ? this.documentAccessLayers.toJSON() : <any>undefined;
        data["ownershipDataKey"] = this.ownershipDataKey;
        if (Array.isArray(this.partyTypes)) {
            data["partyTypes"] = [];
            for (let item of this.partyTypes)
                data["partyTypes"].push(item);
        }
        data["uboThreshold"] = this.uboThreshold;
        if (Array.isArray(this.relatedPartyEntityTypes)) {
            data["relatedPartyEntityTypes"] = [];
            for (let item of this.relatedPartyEntityTypes)
                data["relatedPartyEntityTypes"].push(item);
        }
        data["directAssociationsOnly"] = this.directAssociationsOnly;
        data["idvOn"] = this.idvOn;
        data["idvName"] = this.idvName;
        data["idvTooltip"] = this.idvTooltip;
        data["ownershipValidationRule"] = this.ownershipValidationRule ? this.ownershipValidationRule.toJSON() : <any>undefined;
        data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
        if (Array.isArray(this.conditionalValues)) {
            data["conditionalValues"] = [];
            for (let item of this.conditionalValues)
                data["conditionalValues"].push(item.toJSON());
        }
        data["hasEvaluatedConditionalValue"] = this.hasEvaluatedConditionalValue;
        data["evaluatedConditionalValue"] = this.evaluatedConditionalValue;
        return data;
    }
}

/** Request DTO representing requirement metadata */
export interface IRequirementDto {
    /** The UiD of the root requirement set version */
    rootVersionId?: string;
    /** Requirement set version number */
    versionNumber?: number;
    /** The UiD of the requirement */
    id?: string;
    /** The UiD of the tenant */
    tenant?: string | undefined;
    /** Requirement business category */
    category?: string | undefined;
    /** Requirement description */
    description?: string | undefined;
    /** Requirement template */
    template?: string | undefined;
    /** Requirement entity type */
    entityType?: string | undefined;
    /** Requirement name */
    name?: string | undefined;
    /** Requirement sensitive data flag */
    isSensitiveData?: boolean;
    /** Requirement material data flag */
    isMaterialData?: boolean;
    /** Requirement is defined as core
and cannot be deleted or altered */
    isCoreDefinition?: boolean;
    /** Requirement jurisdiction */
    jurisdiction?: string | undefined;
    /** Requirement references list */
    references?: ReferenceDto[] | undefined;
    /** Requirement target entity */
    targetEntity?: string | undefined;
    /** Requirement classification */
    classification?: string | undefined;
    /** Requirement type */
    type?: string | undefined;
    /** Requirement conditions list */
    conditions?: ConditionDto[] | undefined;
    /** The UiD of the current requirement set version */
    requirementSetId?: string;
    /** The UiD of the current requirement set version */
    versionId?: string;
    /** Data Field */
    dataField?: DataFieldDto | undefined;
    /** Order */
    order?: number | undefined;
    /** Default Value */
    defaultValue?: string | undefined;
    /** Is requirement readonly */
    isReadOnly?: boolean;
    /** Is requirement indexable */
    isIndexable?: boolean;
    /** Is requirement mandatory indexable */
    isMandatoryIndexable?: boolean;
    /** Is requirement mandatory */
    isMandatory?: boolean;
    /** Document Description */
    documentDescription?: string | undefined;
    /** Document Data Key */
    documentDataKey?: string | undefined;
    /** Document Access Layers */
    documentAccessLayers?: AccessLayerDto | undefined;
    /** Ownership Data Key */
    ownershipDataKey?: string | undefined;
    /** Party Types e.g. ["Director"] */
    partyTypes?: string[] | undefined;
    /** UBO Threshold */
    uboThreshold?: number | undefined;
    /** Types of Related Party Entity e.g. ["Individual"] */
    relatedPartyEntityTypes?: string[] | undefined;
    /** Is Only direct association */
    directAssociationsOnly?: boolean;
    /** Is Idv On */
    idvOn?: boolean;
    /** Idv Name */
    idvName?: string | undefined;
    /** Idv Tooltip */
    idvTooltip?: string | undefined;
    /** Ownership Validation Rule */
    ownershipValidationRule?: OwnershipValidationRuleDto | undefined;
    /** Validation Rule */
    validationRule?: ValidationRuleDto | undefined;
    /** List of conditional values */
    conditionalValues?: ConditionalValueDto[] | undefined;
    /** Does this field has evaluated conditional value? */
    hasEvaluatedConditionalValue?: boolean;
    /** Evaluated conditional value */
    evaluatedConditionalValue?: string | undefined;
}

export class RequirementDtoListServiceResponse implements IRequirementDtoListServiceResponse {
    data?: RequirementDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IRequirementDtoListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RequirementDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequirementDtoListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementDtoListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRequirementDtoListServiceResponse {
    data?: RequirementDto[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ServiceResponse implements IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ServiceResponseMessage implements IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

export interface IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;
}

export class SinglePropertyDto extends PropertyDto implements ISinglePropertyDto {
    value?: string | undefined;

    constructor(data?: ISinglePropertyDto) {
        super(data);
        this._discriminator = "Single";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SinglePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SinglePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface ISinglePropertyDto extends IPropertyDto {
    value?: string | undefined;
}

/** Request DTO representing special characters rule metadata */
export class SpecialCharactersRuleDto implements ISpecialCharactersRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Array of special characters, which will be ignored by validation e.g. ["!","@","#"] */
    excludedCharacters?: string[] | undefined;

    constructor(data?: ISpecialCharactersRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            if (Array.isArray(_data["excludedCharacters"])) {
                this.excludedCharacters = [] as any;
                for (let item of _data["excludedCharacters"])
                    this.excludedCharacters!.push(item);
            }
        }
    }

    static fromJS(data: any): SpecialCharactersRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialCharactersRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        if (Array.isArray(this.excludedCharacters)) {
            data["excludedCharacters"] = [];
            for (let item of this.excludedCharacters)
                data["excludedCharacters"].push(item);
        }
        return data;
    }
}

/** Request DTO representing special characters rule metadata */
export interface ISpecialCharactersRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Array of special characters, which will be ignored by validation e.g. ["!","@","#"] */
    excludedCharacters?: string[] | undefined;
}

/** Request DTO representing validation data metadata */
export class ValidationDataDto implements IValidationDataDto {
    /** Mandatory Rule - does not allow empty value */
    isMandatory?: BasicRuleDto | undefined;
    /** Special characters validation rule - does not allow special characters,
but allows define array of characters which can be ignored by the validation */
    specialCharacters?: SpecialCharactersRuleDto | undefined;
    /** Validation rule that does not allow numbers */
    noNumbers?: BasicRuleDto | undefined;
    /** Validation rule that allows only integers */
    onlyInteger?: BasicRuleDto | undefined;
    /** Validation rule that does not allow negative numbers */
    noNegative?: BasicRuleDto | undefined;
    /** Validation rule that allows numbers up to two decimal places */
    onlyDecimal?: BasicRuleDto | undefined;
    /** Validation rule that validates the value against provided regex */
    regex?: RegexRuleDto | undefined;
    /** Validation rule that allows to set minimum and maximum count of characters */
    characterLimit?: ValueLimitRuleDto | undefined;
    /** Validation rule that allows to set number range */
    numberLimit?: ValueLimitRuleDto | undefined;
    /** Validation rule that does not allow future dates */
    noFutureDates?: BasicRuleDto | undefined;
    /** Validation rule that does not allow past dates */
    noPastDates?: BasicRuleDto | undefined;
    /** Validation rule that allows to set date range */
    dateLimit?: DateLimitRuleDto | undefined;
    /** Validation rule that allows to set selection range */
    multiSelectLimit?: ValueLimitRuleDto | undefined;
    /** Validation rule that allows to set minimum count requirements for collection */
    collectionMinimumCount?: CollectionMinimumCountRuleDto | undefined;
    /** Validation rule that allows to set maximum count requirements for collection */
    collectionMaximumCount?: CollectionMaximumCountRuleDto | undefined;

    constructor(data?: IValidationDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isMandatory = _data["isMandatory"] ? BasicRuleDto.fromJS(_data["isMandatory"]) : <any>undefined;
            this.specialCharacters = _data["specialCharacters"] ? SpecialCharactersRuleDto.fromJS(_data["specialCharacters"]) : <any>undefined;
            this.noNumbers = _data["noNumbers"] ? BasicRuleDto.fromJS(_data["noNumbers"]) : <any>undefined;
            this.onlyInteger = _data["onlyInteger"] ? BasicRuleDto.fromJS(_data["onlyInteger"]) : <any>undefined;
            this.noNegative = _data["noNegative"] ? BasicRuleDto.fromJS(_data["noNegative"]) : <any>undefined;
            this.onlyDecimal = _data["onlyDecimal"] ? BasicRuleDto.fromJS(_data["onlyDecimal"]) : <any>undefined;
            this.regex = _data["regex"] ? RegexRuleDto.fromJS(_data["regex"]) : <any>undefined;
            this.characterLimit = _data["characterLimit"] ? ValueLimitRuleDto.fromJS(_data["characterLimit"]) : <any>undefined;
            this.numberLimit = _data["numberLimit"] ? ValueLimitRuleDto.fromJS(_data["numberLimit"]) : <any>undefined;
            this.noFutureDates = _data["noFutureDates"] ? BasicRuleDto.fromJS(_data["noFutureDates"]) : <any>undefined;
            this.noPastDates = _data["noPastDates"] ? BasicRuleDto.fromJS(_data["noPastDates"]) : <any>undefined;
            this.dateLimit = _data["dateLimit"] ? DateLimitRuleDto.fromJS(_data["dateLimit"]) : <any>undefined;
            this.multiSelectLimit = _data["multiSelectLimit"] ? ValueLimitRuleDto.fromJS(_data["multiSelectLimit"]) : <any>undefined;
            this.collectionMinimumCount = _data["collectionMinimumCount"] ? CollectionMinimumCountRuleDto.fromJS(_data["collectionMinimumCount"]) : <any>undefined;
            this.collectionMaximumCount = _data["collectionMaximumCount"] ? CollectionMaximumCountRuleDto.fromJS(_data["collectionMaximumCount"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidationDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMandatory"] = this.isMandatory ? this.isMandatory.toJSON() : <any>undefined;
        data["specialCharacters"] = this.specialCharacters ? this.specialCharacters.toJSON() : <any>undefined;
        data["noNumbers"] = this.noNumbers ? this.noNumbers.toJSON() : <any>undefined;
        data["onlyInteger"] = this.onlyInteger ? this.onlyInteger.toJSON() : <any>undefined;
        data["noNegative"] = this.noNegative ? this.noNegative.toJSON() : <any>undefined;
        data["onlyDecimal"] = this.onlyDecimal ? this.onlyDecimal.toJSON() : <any>undefined;
        data["regex"] = this.regex ? this.regex.toJSON() : <any>undefined;
        data["characterLimit"] = this.characterLimit ? this.characterLimit.toJSON() : <any>undefined;
        data["numberLimit"] = this.numberLimit ? this.numberLimit.toJSON() : <any>undefined;
        data["noFutureDates"] = this.noFutureDates ? this.noFutureDates.toJSON() : <any>undefined;
        data["noPastDates"] = this.noPastDates ? this.noPastDates.toJSON() : <any>undefined;
        data["dateLimit"] = this.dateLimit ? this.dateLimit.toJSON() : <any>undefined;
        data["multiSelectLimit"] = this.multiSelectLimit ? this.multiSelectLimit.toJSON() : <any>undefined;
        data["collectionMinimumCount"] = this.collectionMinimumCount ? this.collectionMinimumCount.toJSON() : <any>undefined;
        data["collectionMaximumCount"] = this.collectionMaximumCount ? this.collectionMaximumCount.toJSON() : <any>undefined;
        return data;
    }
}

/** Request DTO representing validation data metadata */
export interface IValidationDataDto {
    /** Mandatory Rule - does not allow empty value */
    isMandatory?: BasicRuleDto | undefined;
    /** Special characters validation rule - does not allow special characters,
but allows define array of characters which can be ignored by the validation */
    specialCharacters?: SpecialCharactersRuleDto | undefined;
    /** Validation rule that does not allow numbers */
    noNumbers?: BasicRuleDto | undefined;
    /** Validation rule that allows only integers */
    onlyInteger?: BasicRuleDto | undefined;
    /** Validation rule that does not allow negative numbers */
    noNegative?: BasicRuleDto | undefined;
    /** Validation rule that allows numbers up to two decimal places */
    onlyDecimal?: BasicRuleDto | undefined;
    /** Validation rule that validates the value against provided regex */
    regex?: RegexRuleDto | undefined;
    /** Validation rule that allows to set minimum and maximum count of characters */
    characterLimit?: ValueLimitRuleDto | undefined;
    /** Validation rule that allows to set number range */
    numberLimit?: ValueLimitRuleDto | undefined;
    /** Validation rule that does not allow future dates */
    noFutureDates?: BasicRuleDto | undefined;
    /** Validation rule that does not allow past dates */
    noPastDates?: BasicRuleDto | undefined;
    /** Validation rule that allows to set date range */
    dateLimit?: DateLimitRuleDto | undefined;
    /** Validation rule that allows to set selection range */
    multiSelectLimit?: ValueLimitRuleDto | undefined;
    /** Validation rule that allows to set minimum count requirements for collection */
    collectionMinimumCount?: CollectionMinimumCountRuleDto | undefined;
    /** Validation rule that allows to set maximum count requirements for collection */
    collectionMaximumCount?: CollectionMaximumCountRuleDto | undefined;
}

/** Request DTO representing validation rule metadata */
export class ValidationRuleDto implements IValidationRuleDto {
    /** The UiD of the validation rule */
    id?: string;
    /** The UiD of the requirement set/data group */
    setId?: string;
    /** The UiD of the requirement/data group field */
    propertyId?: string;
    /** The UiD of the of data group - is set only when requirement/data group field propertyType is set to "dataGroup" */
    dataGroupId?: string | undefined;
    /** Flag indicating it is validation rules for data group field */
    isDataGroup?: boolean;
    /** Requirement/data group field property name */
    propertyName?: string | undefined;
    /** Requirement/data group field friendly Name */
    friendlyName?: string | undefined;
    /** Validation type */
    validationType?: string | undefined;
    /** Validation Data - set of validation rules specific to requirement/data group field */
    validationData?: ValidationDataDto | undefined;

    constructor(data?: IValidationRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.setId = _data["setId"];
            this.propertyId = _data["propertyId"];
            this.dataGroupId = _data["dataGroupId"];
            this.isDataGroup = _data["isDataGroup"];
            this.propertyName = _data["propertyName"];
            this.friendlyName = _data["friendlyName"];
            this.validationType = _data["validationType"];
            this.validationData = _data["validationData"] ? ValidationDataDto.fromJS(_data["validationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidationRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["setId"] = this.setId;
        data["propertyId"] = this.propertyId;
        data["dataGroupId"] = this.dataGroupId;
        data["isDataGroup"] = this.isDataGroup;
        data["propertyName"] = this.propertyName;
        data["friendlyName"] = this.friendlyName;
        data["validationType"] = this.validationType;
        data["validationData"] = this.validationData ? this.validationData.toJSON() : <any>undefined;
        return data;
    }
}

/** Request DTO representing validation rule metadata */
export interface IValidationRuleDto {
    /** The UiD of the validation rule */
    id?: string;
    /** The UiD of the requirement set/data group */
    setId?: string;
    /** The UiD of the requirement/data group field */
    propertyId?: string;
    /** The UiD of the of data group - is set only when requirement/data group field propertyType is set to "dataGroup" */
    dataGroupId?: string | undefined;
    /** Flag indicating it is validation rules for data group field */
    isDataGroup?: boolean;
    /** Requirement/data group field property name */
    propertyName?: string | undefined;
    /** Requirement/data group field friendly Name */
    friendlyName?: string | undefined;
    /** Validation type */
    validationType?: string | undefined;
    /** Validation Data - set of validation rules specific to requirement/data group field */
    validationData?: ValidationDataDto | undefined;
}

/** Request DTO representing value limit rule metadata */
export class ValueLimitRuleDto implements IValueLimitRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Minimum value */
    minValue?: number | undefined;
    /** Maximum value */
    maxValue?: number | undefined;

    constructor(data?: IValueLimitRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
        }
    }

    static fromJS(data: any): ValueLimitRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueLimitRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        return data;
    }
}

/** Request DTO representing value limit rule metadata */
export interface IValueLimitRuleDto {
    /** Validation rule active flag */
    active?: boolean;
    /** Validation rule error message */
    message?: string | undefined;
    /** Minimum value */
    minValue?: number | undefined;
    /** Maximum value */
    maxValue?: number | undefined;
}

export class VersionedJurisdictionDto implements IVersionedJurisdictionDto {
    /** Jurisdiction of the requirement */
    jurisdiction?: string | undefined;
    /** Jurisdiction of the requirement */
    versionId?: string | undefined;

    constructor(data?: IVersionedJurisdictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jurisdiction = _data["jurisdiction"];
            this.versionId = _data["versionId"];
        }
    }

    static fromJS(data: any): VersionedJurisdictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new VersionedJurisdictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jurisdiction"] = this.jurisdiction;
        data["versionId"] = this.versionId;
        return data;
    }
}

export interface IVersionedJurisdictionDto {
    /** Jurisdiction of the requirement */
    jurisdiction?: string | undefined;
    /** Jurisdiction of the requirement */
    versionId?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}