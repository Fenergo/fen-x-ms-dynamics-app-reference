//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/journeycommand";

    }

    /**
     * Create journey instance
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Create journey instance request
     * @return Success. Journey instance created
     */
    createJourney(x_TENANT_ID: string, body: CreateJourneyInstanceDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyInstanceCreatedDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-instance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateJourney(_response);
        });
    }

    protected processCreateJourney(response: AxiosResponse): Promise<JourneyInstanceCreatedDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneyInstanceCreatedDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneyInstanceCreatedDtoServiceResponse>(result202);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyInstanceCreatedDtoServiceResponse>(null as any);
    }

    /**
     * Cancel journey instance
     * @param journeyInstanceId Journey instance id to cancel
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Abort journey instance details (Optional)
     * @return Success. Journey instance canceled
     */
    abortJourneyInstance(journeyInstanceId: string, x_TENANT_ID: string, body: AbortJourneyDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-instance/{journeyInstanceId}/abort";
        if (journeyInstanceId === undefined || journeyInstanceId === null)
            throw new Error("The parameter 'journeyInstanceId' must be defined.");
        url_ = url_.replace("{journeyInstanceId}", encodeURIComponent("" + journeyInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAbortJourneyInstance(_response);
        });
    }

    protected processAbortJourneyInstance(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Batch cancel journey instances
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Abort journey instances request
     * @return Success. Journey instances canceled
     */
    batchAbortJourneyInstances(x_TENANT_ID: string, body: AbortMultipleJourneysDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-instance/batch/abort";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchAbortJourneyInstances(_response);
        });
    }

    protected processBatchAbortJourneyInstances(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Complete journey instance task
     * @param taskId Task id
     * @param journeyInstanceId Journey instance id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey instance task completed
     */
    completeTask(taskId: string, journeyInstanceId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-instance/{journeyInstanceId}/task/complete?";
        if (journeyInstanceId === undefined || journeyInstanceId === null)
            throw new Error("The parameter 'journeyInstanceId' must be defined.");
        url_ = url_.replace("{journeyInstanceId}", encodeURIComponent("" + journeyInstanceId));
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined and cannot be null.");
        else
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompleteTask(_response);
        });
    }

    protected processCompleteTask(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Save review outcome
     * @param journeyInstanceId Journey instance id
     * @param taskId Task id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Save review outcome task request
     * @return Success. Review outcome task completed
     */
    saveReviewOutcome(journeyInstanceId: string, taskId: string, x_TENANT_ID: string, body: ReviewOutcomeDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-instance/{journeyInstanceId}/task/{taskId}/reviewOutcome";
        if (journeyInstanceId === undefined || journeyInstanceId === null)
            throw new Error("The parameter 'journeyInstanceId' must be defined.");
        url_ = url_.replace("{journeyInstanceId}", encodeURIComponent("" + journeyInstanceId));
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveReviewOutcome(_response);
        });
    }

    protected processSaveReviewOutcome(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Reassign task
     * @param journeyInstanceId Journey instance id
     * @param taskId Task id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Reassign task properties
     * @return Success. Task team reassigned
     */
    reassignTask(journeyInstanceId: string, taskId: string, x_TENANT_ID: string, body: ReassignTaskDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-instance/{journeyInstanceId}/task/{taskId}/reassign";
        if (journeyInstanceId === undefined || journeyInstanceId === null)
            throw new Error("The parameter 'journeyInstanceId' must be defined.");
        url_ = url_.replace("{journeyInstanceId}", encodeURIComponent("" + journeyInstanceId));
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReassignTask(_response);
        });
    }

    protected processReassignTask(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Bulk reassign task
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) List of reassign task properties
     * @return Accepted. At least one task reassigned
     */
    reassignTaskBulk(x_TENANT_ID: string, body: ReassignMultipleTasksDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<TaskReassignOutcomeDtoListServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-instance/bulk-reassign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReassignTaskBulk(_response);
        });
    }

    protected processReassignTaskBulk(response: AxiosResponse): Promise<TaskReassignOutcomeDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = TaskReassignOutcomeDtoListServiceResponse.fromJS(resultData202);
            return Promise.resolve<TaskReassignOutcomeDtoListServiceResponse>(result202);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = TaskReassignOutcomeDtoListServiceResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TaskReassignOutcomeDtoListServiceResponse>(null as any);
    }

    /**
     * Reopen task
     * @param journeyInstanceId Journey instance id
     * @param taskId Task id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Task reopened
     * @deprecated
     */
    reopenTask(journeyInstanceId: string, taskId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-instance/{journeyInstanceId}/task/{taskId}/reopen";
        if (journeyInstanceId === undefined || journeyInstanceId === null)
            throw new Error("The parameter 'journeyInstanceId' must be defined.");
        url_ = url_.replace("{journeyInstanceId}", encodeURIComponent("" + journeyInstanceId));
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReopenTask(_response);
        });
    }

    protected processReopenTask(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Reset task
     * @param journeyInstanceId Journey instance id
     * @param taskId Task id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Reset task properties
     * @return Success. Task reopened
     */
    resetTask(journeyInstanceId: string, taskId: string, x_TENANT_ID: string, body: ResetTaskDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyInstanceCreatedDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-instance/{journeyInstanceId}/task/{taskId}/reset";
        if (journeyInstanceId === undefined || journeyInstanceId === null)
            throw new Error("The parameter 'journeyInstanceId' must be defined.");
        url_ = url_.replace("{journeyInstanceId}", encodeURIComponent("" + journeyInstanceId));
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetTask(_response);
        });
    }

    protected processResetTask(response: AxiosResponse): Promise<JourneyInstanceCreatedDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneyInstanceCreatedDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneyInstanceCreatedDtoServiceResponse>(result202);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyInstanceCreatedDtoServiceResponse>(null as any);
    }

    /**
     * Update journey instance access layers
     * @param id Journey instance id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update journey instance access layers request
     * @return Success. Journey instance access layers updated
     */
    updateJourneyAccessLayers(id: string, x_TENANT_ID: string, body: UpdateJourneyInstanceAccessLayersDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-instance/{id}/access-layers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateJourneyAccessLayers(_response);
        });
    }

    protected processUpdateJourneyAccessLayers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectServiceResponse.fromJS(resultData409);
            return throwException("Conflict saving changes in expected version", status, _responseText, _headers, result409);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create journey Schedule
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) 
     * @return Success. Journey Schedule created
     */
    createJourneySchedule(x_TENANT_ID: string, body: JourneyScheduleDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyScheduleDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateJourneySchedule(_response);
        });
    }

    protected processCreateJourneySchedule(response: AxiosResponse): Promise<JourneyScheduleDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneyScheduleDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneyScheduleDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyScheduleDtoServiceResponse>(null as any);
    }

    /**
     * Create journey Schedule version
     * @param journeyScheduleId Journey Schedule id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Create journey Schedule version request
     * @return Success. Journey Schedule version created
     */
    createJourneyScheduleVersion(journeyScheduleId: string, x_TENANT_ID: string, body: JourneyScheduleDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyScheduleDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schedule/{journeyScheduleId}";
        if (journeyScheduleId === undefined || journeyScheduleId === null)
            throw new Error("The parameter 'journeyScheduleId' must be defined.");
        url_ = url_.replace("{journeyScheduleId}", encodeURIComponent("" + journeyScheduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateJourneyScheduleVersion(_response);
        });
    }

    protected processCreateJourneyScheduleVersion(response: AxiosResponse): Promise<JourneyScheduleDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneyScheduleDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneyScheduleDtoServiceResponse>(result202);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyScheduleDtoServiceResponse>(null as any);
    }

    /**
     * Delete journey Schedule and all its versions
     * @param journeyScheduleId Journey Schedule Id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey schedule deleted
     */
    deleteJourneySchedule(journeyScheduleId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schedule/{journeyScheduleId}";
        if (journeyScheduleId === undefined || journeyScheduleId === null)
            throw new Error("The parameter 'journeyScheduleId' must be defined.");
        url_ = url_.replace("{journeyScheduleId}", encodeURIComponent("" + journeyScheduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteJourneySchedule(_response);
        });
    }

    protected processDeleteJourneySchedule(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update journey Schedule version
     * @param journeyScheduleId Journey Schedule id
     * @param versionNumber Version number to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update journey Schedule version request
     * @return Success. Journey Schedule version updated
     */
    updateJourneyScheduleVersion(journeyScheduleId: string, versionNumber: number, x_TENANT_ID: string, body: UpdateJourneyScheduleVersionDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schedule/{journeyScheduleId}/version/{versionNumber}";
        if (journeyScheduleId === undefined || journeyScheduleId === null)
            throw new Error("The parameter 'journeyScheduleId' must be defined.");
        url_ = url_.replace("{journeyScheduleId}", encodeURIComponent("" + journeyScheduleId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateJourneyScheduleVersion(_response);
        });
    }

    protected processUpdateJourneyScheduleVersion(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectServiceResponse.fromJS(resultData409);
            return throwException("Conflict saving changes in expected version", status, _responseText, _headers, result409);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete journey Schedule version
     * @param journeyScheduleId Journey Schedule Id
     * @param versionNumber Version number to delete
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey Schedule version deleted
     */
    deleteJourneyScheduleVersion(journeyScheduleId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schedule/{journeyScheduleId}/version/{versionNumber}";
        if (journeyScheduleId === undefined || journeyScheduleId === null)
            throw new Error("The parameter 'journeyScheduleId' must be defined.");
        url_ = url_.replace("{journeyScheduleId}", encodeURIComponent("" + journeyScheduleId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteJourneyScheduleVersion(_response);
        });
    }

    protected processDeleteJourneyScheduleVersion(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Clone journey Schedule version
     * @param journeyScheduleId Journey Schedule Id
     * @param versionNumber Version number to clone
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Clone journey Schedule version request
     * @return Success. Journey Schedule version cloned
     */
    cloneJourneyScheduleVersion(journeyScheduleId: string, versionNumber: number, x_TENANT_ID: string, body: CloneJourneyScheduleVersionDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<CloneJourneyScheduleVersionResponseServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schedule/{journeyScheduleId}/version/{versionNumber}/clone";
        if (journeyScheduleId === undefined || journeyScheduleId === null)
            throw new Error("The parameter 'journeyScheduleId' must be defined.");
        url_ = url_.replace("{journeyScheduleId}", encodeURIComponent("" + journeyScheduleId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCloneJourneyScheduleVersion(_response);
        });
    }

    protected processCloneJourneyScheduleVersion(response: AxiosResponse): Promise<CloneJourneyScheduleVersionResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = CloneJourneyScheduleVersionResponseServiceResponse.fromJS(resultData202);
            return Promise.resolve<CloneJourneyScheduleVersionResponseServiceResponse>(result202);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CloneJourneyScheduleVersionResponseServiceResponse>(null as any);
    }

    /**
     * Submit journey Schedule version for approval
     * @param journeyScheduleId Journey Schedule Id
     * @param versionNumber Version number to submit
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey Schedule version submitted
     */
    submitJourneyScheduleVersion(journeyScheduleId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schedule/{journeyScheduleId}/version/{versionNumber}/submit-for-approval";
        if (journeyScheduleId === undefined || journeyScheduleId === null)
            throw new Error("The parameter 'journeyScheduleId' must be defined.");
        url_ = url_.replace("{journeyScheduleId}", encodeURIComponent("" + journeyScheduleId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitJourneyScheduleVersion(_response);
        });
    }

    protected processSubmitJourneyScheduleVersion(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Sign journey Schedule version
     * @param journeyScheduleId Journey Schedule Id
     * @param versionNumber Version number to sign
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Sign journey Schedule version request
     * @return Success. Journey Schedule version signed
     */
    signJourneyScheduleVersion(journeyScheduleId: string, versionNumber: number, x_TENANT_ID: string, body: ApproveActionServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyScheduleVersionSignResponseServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schedule/{journeyScheduleId}/version/{versionNumber}/sign";
        if (journeyScheduleId === undefined || journeyScheduleId === null)
            throw new Error("The parameter 'journeyScheduleId' must be defined.");
        url_ = url_.replace("{journeyScheduleId}", encodeURIComponent("" + journeyScheduleId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignJourneyScheduleVersion(_response);
        });
    }

    protected processSignJourneyScheduleVersion(response: AxiosResponse): Promise<JourneyScheduleVersionSignResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneyScheduleVersionSignResponseServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneyScheduleVersionSignResponseServiceResponse>(result202);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyScheduleVersionSignResponseServiceResponse>(null as any);
    }

    /**
     * Archive journey Schedule version
     * @param journeyScheduleId Journey Schedule Id
     * @param versionNumber Version number to archive
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey Schedule version archived
     */
    archiveJourneyScheduleVersion(journeyScheduleId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schedule/{journeyScheduleId}/version/{versionNumber}/archive";
        if (journeyScheduleId === undefined || journeyScheduleId === null)
            throw new Error("The parameter 'journeyScheduleId' must be defined.");
        url_ = url_.replace("{journeyScheduleId}", encodeURIComponent("" + journeyScheduleId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArchiveJourneyScheduleVersion(_response);
        });
    }

    protected processArchiveJourneyScheduleVersion(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create journey Schedule Date
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) 
     * @return Success. Journey Schedule Date created
     */
    createJourneyScheduleDate(x_TENANT_ID: string, body: JourneyScheduleDateDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyScheduleDateDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schedule-date";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateJourneyScheduleDate(_response);
        });
    }

    protected processCreateJourneyScheduleDate(response: AxiosResponse): Promise<JourneyScheduleDateDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneyScheduleDateDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneyScheduleDateDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyScheduleDateDtoServiceResponse>(null as any);
    }

    /**
     * Update journey Schedule Date
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) 
     * @return Success. Journey Schedule Date Updated
     */
    updateJourneyScheduleDate(x_TENANT_ID: string, body: JourneyScheduleDateDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneyScheduleDateDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schedule-date";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateJourneyScheduleDate(_response);
        });
    }

    protected processUpdateJourneyScheduleDate(response: AxiosResponse): Promise<JourneyScheduleDateDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneyScheduleDateDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneyScheduleDateDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneyScheduleDateDtoServiceResponse>(null as any);
    }

    /**
     * Delete journey Schedule date record
     * @param journeyScheduleDateId Journey Schedule Date Id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey Schedule Date deleted
     */
    deleteJourneyScheduleDate(journeyScheduleDateId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schedule-date/{journeyScheduleDateId}";
        if (journeyScheduleDateId === undefined || journeyScheduleDateId === null)
            throw new Error("The parameter 'journeyScheduleDateId' must be defined.");
        url_ = url_.replace("{journeyScheduleDateId}", encodeURIComponent("" + journeyScheduleDateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteJourneyScheduleDate(_response);
        });
    }

    protected processDeleteJourneyScheduleDate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create journey schema
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) 
     * @return Success. Journey schema created
     */
    createJourneySchema(x_TENANT_ID: string, body: JourneySchemaDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneySchemaDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schema";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateJourneySchema(_response);
        });
    }

    protected processCreateJourneySchema(response: AxiosResponse): Promise<JourneySchemaDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneySchemaDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneySchemaDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneySchemaDtoServiceResponse>(null as any);
    }

    /**
     * Create journey schema version
     * @param journeySchemaId Journey schema id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Create journey schema version request
     * @return Success. Journey schema version created
     */
    createJourneySchemaVersion(journeySchemaId: string, x_TENANT_ID: string, body: JourneySchemaDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneySchemaDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schema/{journeySchemaId}";
        if (journeySchemaId === undefined || journeySchemaId === null)
            throw new Error("The parameter 'journeySchemaId' must be defined.");
        url_ = url_.replace("{journeySchemaId}", encodeURIComponent("" + journeySchemaId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateJourneySchemaVersion(_response);
        });
    }

    protected processCreateJourneySchemaVersion(response: AxiosResponse): Promise<JourneySchemaDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneySchemaDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneySchemaDtoServiceResponse>(result202);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneySchemaDtoServiceResponse>(null as any);
    }

    /**
     * Delete journey schema and all its versions
     * @param journeySchemaId Journey schema Id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey schema deleted
     */
    deleteJourneySchema(journeySchemaId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schema/{journeySchemaId}";
        if (journeySchemaId === undefined || journeySchemaId === null)
            throw new Error("The parameter 'journeySchemaId' must be defined.");
        url_ = url_.replace("{journeySchemaId}", encodeURIComponent("" + journeySchemaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteJourneySchema(_response);
        });
    }

    protected processDeleteJourneySchema(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update journey schema version
     * @param journeySchemaId Journey schema id
     * @param versionNumber Version number to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update journey schema version request
     * @return Success. Journey schema version updated
     */
    updateJourneySchemaVersion(journeySchemaId: string, versionNumber: number, x_TENANT_ID: string, body: UpdateJourneySchemaVersionDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneySchemaUpdatedDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schema/{journeySchemaId}/version/{versionNumber}";
        if (journeySchemaId === undefined || journeySchemaId === null)
            throw new Error("The parameter 'journeySchemaId' must be defined.");
        url_ = url_.replace("{journeySchemaId}", encodeURIComponent("" + journeySchemaId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateJourneySchemaVersion(_response);
        });
    }

    protected processUpdateJourneySchemaVersion(response: AxiosResponse): Promise<JourneySchemaUpdatedDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneySchemaUpdatedDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneySchemaUpdatedDtoServiceResponse>(result202);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectServiceResponse.fromJS(resultData409);
            return throwException("Conflict saving changes in expected version", status, _responseText, _headers, result409);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneySchemaUpdatedDtoServiceResponse>(null as any);
    }

    /**
     * Delete journey schema version
     * @param journeySchemaId Journey schema Id
     * @param versionNumber Version number to delete
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey schema version deleted
     */
    deleteJourneySchemaVersion(journeySchemaId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schema/{journeySchemaId}/version/{versionNumber}";
        if (journeySchemaId === undefined || journeySchemaId === null)
            throw new Error("The parameter 'journeySchemaId' must be defined.");
        url_ = url_.replace("{journeySchemaId}", encodeURIComponent("" + journeySchemaId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteJourneySchemaVersion(_response);
        });
    }

    protected processDeleteJourneySchemaVersion(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Clone journey schema version
     * @param journeySchemaId Journey schema Id
     * @param versionNumber Version number to clone
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Clone journey schema version request
     * @return Success. Journey schema version cloned
     */
    cloneJourneySchemaVersion(journeySchemaId: string, versionNumber: number, x_TENANT_ID: string, body: CloneJourneySchemaVersionDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<CloneJourneySchemaVersionResponseServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schema/{journeySchemaId}/version/{versionNumber}/clone";
        if (journeySchemaId === undefined || journeySchemaId === null)
            throw new Error("The parameter 'journeySchemaId' must be defined.");
        url_ = url_.replace("{journeySchemaId}", encodeURIComponent("" + journeySchemaId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCloneJourneySchemaVersion(_response);
        });
    }

    protected processCloneJourneySchemaVersion(response: AxiosResponse): Promise<CloneJourneySchemaVersionResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = CloneJourneySchemaVersionResponseServiceResponse.fromJS(resultData202);
            return Promise.resolve<CloneJourneySchemaVersionResponseServiceResponse>(result202);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CloneJourneySchemaVersionResponseServiceResponse>(null as any);
    }

    /**
     * Submit journey schema version for approval
     * @param journeySchemaId Journey schema Id
     * @param versionNumber Version number to submit
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey schema version submitted
     */
    submitJourneySchemaVersion(journeySchemaId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schema/{journeySchemaId}/version/{versionNumber}/submit-for-approval";
        if (journeySchemaId === undefined || journeySchemaId === null)
            throw new Error("The parameter 'journeySchemaId' must be defined.");
        url_ = url_.replace("{journeySchemaId}", encodeURIComponent("" + journeySchemaId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitJourneySchemaVersion(_response);
        });
    }

    protected processSubmitJourneySchemaVersion(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Sign journey schema version
     * @param journeySchemaId Journey schema Id
     * @param versionNumber Version number to sign
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Sign journey schema version request
     * @return Success. Journey schema version signed
     */
    signJourneySchemaVersion(journeySchemaId: string, versionNumber: number, x_TENANT_ID: string, body: ApproveActionServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<JourneySchemaVersionSignResponseServiceResponse> {
        let url_ = this.baseUrl + "/api/journey-schema/{journeySchemaId}/version/{versionNumber}/sign";
        if (journeySchemaId === undefined || journeySchemaId === null)
            throw new Error("The parameter 'journeySchemaId' must be defined.");
        url_ = url_.replace("{journeySchemaId}", encodeURIComponent("" + journeySchemaId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignJourneySchemaVersion(_response);
        });
    }

    protected processSignJourneySchemaVersion(response: AxiosResponse): Promise<JourneySchemaVersionSignResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = JourneySchemaVersionSignResponseServiceResponse.fromJS(resultData202);
            return Promise.resolve<JourneySchemaVersionSignResponseServiceResponse>(result202);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JourneySchemaVersionSignResponseServiceResponse>(null as any);
    }

    /**
     * Archive journey schema version
     * @param journeySchemaId Journey schema Id
     * @param versionNumber Version number to archive
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Journey schema version archived
     */
    archiveJourneySchemaVersion(journeySchemaId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/journey-schema/{journeySchemaId}/version/{versionNumber}/archive";
        if (journeySchemaId === undefined || journeySchemaId === null)
            throw new Error("The parameter 'journeySchemaId' must be defined.");
        url_ = url_.replace("{journeySchemaId}", encodeURIComponent("" + journeySchemaId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArchiveJourneySchemaVersion(_response);
        });
    }

    protected processArchiveJourneySchemaVersion(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

/** DTO to abort journey */
export class AbortJourneyDto implements IAbortJourneyDto {
    /** Reason for journey cancelation */
    cancellationReason?: string | undefined;
    /** Comments to journey cancelation */
    comments?: string | undefined;

    constructor(data?: IAbortJourneyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cancellationReason = _data["cancellationReason"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): AbortJourneyDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbortJourneyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cancellationReason"] = this.cancellationReason;
        data["comments"] = this.comments;
        return data;
    }
}

/** DTO to abort journey */
export interface IAbortJourneyDto {
    /** Reason for journey cancelation */
    cancellationReason?: string | undefined;
    /** Comments to journey cancelation */
    comments?: string | undefined;
}

/** Service request data */
export class AbortJourneyDtoServiceRequest implements IAbortJourneyDtoServiceRequest {
    data?: AbortJourneyDto;

    constructor(data?: IAbortJourneyDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AbortJourneyDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbortJourneyDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AbortJourneyDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IAbortJourneyDtoServiceRequest {
    data?: AbortJourneyDto;
}

/** DTO representing aborting journeys in bulk */
export class AbortMultipleJourneysDto implements IAbortMultipleJourneysDto {
    /** List of journeys to abort */
    journeysIds?: string[] | undefined;

    constructor(data?: IAbortMultipleJourneysDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["journeysIds"])) {
                this.journeysIds = [] as any;
                for (let item of _data["journeysIds"])
                    this.journeysIds!.push(item);
            }
        }
    }

    static fromJS(data: any): AbortMultipleJourneysDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbortMultipleJourneysDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.journeysIds)) {
            data["journeysIds"] = [];
            for (let item of this.journeysIds)
                data["journeysIds"].push(item);
        }
        return data;
    }
}

/** DTO representing aborting journeys in bulk */
export interface IAbortMultipleJourneysDto {
    /** List of journeys to abort */
    journeysIds?: string[] | undefined;
}

/** Service request data */
export class AbortMultipleJourneysDtoServiceRequest implements IAbortMultipleJourneysDtoServiceRequest {
    data?: AbortMultipleJourneysDto;

    constructor(data?: IAbortMultipleJourneysDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AbortMultipleJourneysDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbortMultipleJourneysDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AbortMultipleJourneysDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IAbortMultipleJourneysDtoServiceRequest {
    data?: AbortMultipleJourneysDto;
}

/** DTO representing access layers attached */
export class AccessLayerDto implements IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;

    constructor(data?: IAccessLayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["geographic"])) {
                this.geographic = [] as any;
                for (let item of _data["geographic"])
                    this.geographic!.push(item);
            }
            if (Array.isArray(_data["businessRelated"])) {
                this.businessRelated = [] as any;
                for (let item of _data["businessRelated"])
                    this.businessRelated!.push(item);
            }
        }
    }

    static fromJS(data: any): AccessLayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.geographic)) {
            data["geographic"] = [];
            for (let item of this.geographic)
                data["geographic"].push(item);
        }
        if (Array.isArray(this.businessRelated)) {
            data["businessRelated"] = [];
            for (let item of this.businessRelated)
                data["businessRelated"].push(item);
        }
        return data;
    }
}

/** DTO representing access layers attached */
export interface IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;
}

export class ApproveAction implements IApproveAction {
    comment?: string | undefined;
    decision?: Decision;
    created?: Date;

    constructor(data?: IApproveAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
            this.decision = _data["decision"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApproveAction {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["decision"] = this.decision;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IApproveAction {
    comment?: string | undefined;
    decision?: Decision;
    created?: Date;
}

/** Service request data */
export class ApproveActionServiceRequest implements IApproveActionServiceRequest {
    data?: ApproveAction;

    constructor(data?: IApproveActionServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ApproveAction.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApproveActionServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveActionServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IApproveActionServiceRequest {
    data?: ApproveAction;
}

export class Approver implements IApprover {
    subject?: string | undefined;
    successor?: Approver;
    action?: ApproveAction;
    readonly hasProcessedRequest?: boolean;

    constructor(data?: IApprover) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.successor = _data["successor"] ? Approver.fromJS(_data["successor"]) : <any>undefined;
            this.action = _data["action"] ? ApproveAction.fromJS(_data["action"]) : <any>undefined;
            (<any>this).hasProcessedRequest = _data["hasProcessedRequest"];
        }
    }

    static fromJS(data: any): Approver {
        data = typeof data === 'object' ? data : {};
        let result = new Approver();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["successor"] = this.successor ? this.successor.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["hasProcessedRequest"] = this.hasProcessedRequest;
        return data;
    }
}

export interface IApprover {
    subject?: string | undefined;
    successor?: Approver;
    action?: ApproveAction;
    hasProcessedRequest?: boolean;
}

export enum ChannelTypeDto {
    Internal = "Internal",
    External = "External",
    InternalAndExternal = "InternalAndExternal",
}

/** Request DTO representing clone journey Schedule data */
export class CloneJourneyScheduleVersionDto implements ICloneJourneyScheduleVersionDto {
    /** Name of new journey Schedule */
    name?: string | undefined;
    /** The type of new journey Schedule */
    type?: string | undefined;

    constructor(data?: ICloneJourneyScheduleVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CloneJourneyScheduleVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CloneJourneyScheduleVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

/** Request DTO representing clone journey Schedule data */
export interface ICloneJourneyScheduleVersionDto {
    /** Name of new journey Schedule */
    name?: string | undefined;
    /** The type of new journey Schedule */
    type?: string | undefined;
}

/** Service request data */
export class CloneJourneyScheduleVersionDtoServiceRequest implements ICloneJourneyScheduleVersionDtoServiceRequest {
    data?: CloneJourneyScheduleVersionDto;

    constructor(data?: ICloneJourneyScheduleVersionDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CloneJourneyScheduleVersionDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CloneJourneyScheduleVersionDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CloneJourneyScheduleVersionDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface ICloneJourneyScheduleVersionDtoServiceRequest {
    data?: CloneJourneyScheduleVersionDto;
}

/** Cloned journey schedule response data */
export class CloneJourneyScheduleVersionResponse implements ICloneJourneyScheduleVersionResponse {
    /** Id of the cloned journey schedule */
    journeyScheduleId?: string;

    constructor(data?: ICloneJourneyScheduleVersionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeyScheduleId = _data["journeyScheduleId"];
        }
    }

    static fromJS(data: any): CloneJourneyScheduleVersionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CloneJourneyScheduleVersionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeyScheduleId"] = this.journeyScheduleId;
        return data;
    }
}

/** Cloned journey schedule response data */
export interface ICloneJourneyScheduleVersionResponse {
    /** Id of the cloned journey schedule */
    journeyScheduleId?: string;
}

/** Service response data */
export class CloneJourneyScheduleVersionResponseServiceResponse implements ICloneJourneyScheduleVersionResponseServiceResponse {
    data?: CloneJourneyScheduleVersionResponse;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ICloneJourneyScheduleVersionResponseServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CloneJourneyScheduleVersionResponse.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CloneJourneyScheduleVersionResponseServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CloneJourneyScheduleVersionResponseServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface ICloneJourneyScheduleVersionResponseServiceResponse {
    data?: CloneJourneyScheduleVersionResponse;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Request DTO representing clone journey schema data */
export class CloneJourneySchemaVersionDto implements ICloneJourneySchemaVersionDto {
    /** Name of new journey schema */
    name?: string | undefined;
    /** Identifier of new journey schema */
    identifier?: string | undefined;
    /** The type of new journey schema */
    type?: string | undefined;
    channelType?: ChannelTypeDto;

    constructor(data?: ICloneJourneySchemaVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.identifier = _data["identifier"];
            this.type = _data["type"];
            this.channelType = _data["channelType"];
        }
    }

    static fromJS(data: any): CloneJourneySchemaVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CloneJourneySchemaVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["type"] = this.type;
        data["channelType"] = this.channelType;
        return data;
    }
}

/** Request DTO representing clone journey schema data */
export interface ICloneJourneySchemaVersionDto {
    /** Name of new journey schema */
    name?: string | undefined;
    /** Identifier of new journey schema */
    identifier?: string | undefined;
    /** The type of new journey schema */
    type?: string | undefined;
    channelType?: ChannelTypeDto;
}

/** Service request data */
export class CloneJourneySchemaVersionDtoServiceRequest implements ICloneJourneySchemaVersionDtoServiceRequest {
    data?: CloneJourneySchemaVersionDto;

    constructor(data?: ICloneJourneySchemaVersionDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CloneJourneySchemaVersionDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CloneJourneySchemaVersionDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CloneJourneySchemaVersionDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface ICloneJourneySchemaVersionDtoServiceRequest {
    data?: CloneJourneySchemaVersionDto;
}

/** Cloned journey schema response data */
export class CloneJourneySchemaVersionResponse implements ICloneJourneySchemaVersionResponse {
    /** Id of the cloned journey schema */
    journeySchemaId?: string;

    constructor(data?: ICloneJourneySchemaVersionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeySchemaId = _data["journeySchemaId"];
        }
    }

    static fromJS(data: any): CloneJourneySchemaVersionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CloneJourneySchemaVersionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeySchemaId"] = this.journeySchemaId;
        return data;
    }
}

/** Cloned journey schema response data */
export interface ICloneJourneySchemaVersionResponse {
    /** Id of the cloned journey schema */
    journeySchemaId?: string;
}

/** Service response data */
export class CloneJourneySchemaVersionResponseServiceResponse implements ICloneJourneySchemaVersionResponseServiceResponse {
    data?: CloneJourneySchemaVersionResponse;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ICloneJourneySchemaVersionResponseServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CloneJourneySchemaVersionResponse.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CloneJourneySchemaVersionResponseServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CloneJourneySchemaVersionResponseServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface ICloneJourneySchemaVersionResponseServiceResponse {
    data?: CloneJourneySchemaVersionResponse;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Represents condition */
export class ConditionDefinitionDto implements IConditionDefinitionDto {
    /** Name of the field to evaluate */
    fieldName?: string | undefined;
    /** List of values */
    value?: string[] | undefined;
    /** Type of the value */
    valueType?: string | undefined;
    /** Data source from which field is retrieved. If empty then Entity Data properties will be used. */
    dataSource?: string | undefined;
    /** Logical operation to be performed to match the values */
    operation?: string | undefined;
    /** Logical operation to be performed on the operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;

    constructor(data?: IConditionDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.valueType = _data["valueType"];
            this.dataSource = _data["dataSource"];
            this.operation = _data["operation"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["valueType"] = this.valueType;
        data["dataSource"] = this.dataSource;
        data["operation"] = this.operation;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents condition */
export interface IConditionDefinitionDto {
    /** Name of the field to evaluate */
    fieldName?: string | undefined;
    /** List of values */
    value?: string[] | undefined;
    /** Type of the value */
    valueType?: string | undefined;
    /** Data source from which field is retrieved. If empty then Entity Data properties will be used. */
    dataSource?: string | undefined;
    /** Logical operation to be performed to match the values */
    operation?: string | undefined;
    /** Logical operation to be performed on the operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;
}

/** Represents condition root */
export class ConditionDto implements IConditionDto {
    /** The ID of the condition */
    id?: string;
    /** The name of the condition */
    name?: string | undefined;
    /** The description of the condition */
    description?: string | undefined;
    /** Logical operation on the Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDto.Operands collection */
    logicalOperation!: string;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands!: ConditionDefinitionDto[];

    constructor(data?: IConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.operands = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents condition root */
export interface IConditionDto {
    /** The ID of the condition */
    id?: string;
    /** The name of the condition */
    name?: string | undefined;
    /** The description of the condition */
    description?: string | undefined;
    /** Logical operation on the Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDto.Operands collection */
    logicalOperation: string;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands: ConditionDefinitionDto[];
}

/** Request DTO representing journey instance to create */
export class CreateJourneyInstanceDto implements ICreateJourneyInstanceDto {
    /** Entity id from FenX entity data service */
    entityId?: string;
    /** Id of existing and published journey schema */
    journeySchemaId?: string;
    accessLayers?: AccessLayerDto;
    /** Jurisdictions this journey instance operates on. Only Client Offboarding journey type supports per jurisdiction journey instances. */
    jurisdictions?: JourneyJurisdictionDto[] | undefined;
    /** (Optional) Version number of journey schema to use; if null latest published version is used */
    journeySchemaVersionNumber?: number | undefined;

    constructor(data?: ICreateJourneyInstanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.journeySchemaId = _data["journeySchemaId"];
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(JourneyJurisdictionDto.fromJS(item));
            }
            this.journeySchemaVersionNumber = _data["journeySchemaVersionNumber"];
        }
    }

    static fromJS(data: any): CreateJourneyInstanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJourneyInstanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["journeySchemaId"] = this.journeySchemaId;
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item.toJSON());
        }
        data["journeySchemaVersionNumber"] = this.journeySchemaVersionNumber;
        return data;
    }
}

/** Request DTO representing journey instance to create */
export interface ICreateJourneyInstanceDto {
    /** Entity id from FenX entity data service */
    entityId?: string;
    /** Id of existing and published journey schema */
    journeySchemaId?: string;
    accessLayers?: AccessLayerDto;
    /** Jurisdictions this journey instance operates on. Only Client Offboarding journey type supports per jurisdiction journey instances. */
    jurisdictions?: JourneyJurisdictionDto[] | undefined;
    /** (Optional) Version number of journey schema to use; if null latest published version is used */
    journeySchemaVersionNumber?: number | undefined;
}

/** Service request data */
export class CreateJourneyInstanceDtoServiceRequest implements ICreateJourneyInstanceDtoServiceRequest {
    data?: CreateJourneyInstanceDto;

    constructor(data?: ICreateJourneyInstanceDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateJourneyInstanceDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateJourneyInstanceDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJourneyInstanceDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface ICreateJourneyInstanceDtoServiceRequest {
    data?: CreateJourneyInstanceDto;
}

export enum Decision {
    Approve = "Approve",
    Reject = "Reject",
}

/** Response DTO representing created journey instance */
export class JourneyInstanceCreatedDto implements IJourneyInstanceCreatedDto {
    /** Id of the created journey instance */
    journeyInstanceId?: string;
    /** Id of journey schema of the created journey instance */
    journeySchemaId?: string;
    /** Version number of the journey schema of created journey instance */
    journeySchemaVersionNumber?: number | undefined;
    /** Entity id from FenX entity data service */
    entityId?: string;

    constructor(data?: IJourneyInstanceCreatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeyInstanceId = _data["journeyInstanceId"];
            this.journeySchemaId = _data["journeySchemaId"];
            this.journeySchemaVersionNumber = _data["journeySchemaVersionNumber"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): JourneyInstanceCreatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyInstanceCreatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeyInstanceId"] = this.journeyInstanceId;
        data["journeySchemaId"] = this.journeySchemaId;
        data["journeySchemaVersionNumber"] = this.journeySchemaVersionNumber;
        data["entityId"] = this.entityId;
        return data;
    }
}

/** Response DTO representing created journey instance */
export interface IJourneyInstanceCreatedDto {
    /** Id of the created journey instance */
    journeyInstanceId?: string;
    /** Id of journey schema of the created journey instance */
    journeySchemaId?: string;
    /** Version number of the journey schema of created journey instance */
    journeySchemaVersionNumber?: number | undefined;
    /** Entity id from FenX entity data service */
    entityId?: string;
}

/** Service response data */
export class JourneyInstanceCreatedDtoServiceResponse implements IJourneyInstanceCreatedDtoServiceResponse {
    data?: JourneyInstanceCreatedDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneyInstanceCreatedDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneyInstanceCreatedDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyInstanceCreatedDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyInstanceCreatedDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneyInstanceCreatedDtoServiceResponse {
    data?: JourneyInstanceCreatedDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Request DTO representing jurisdiction journey should operate on */
export class JourneyJurisdictionDto implements IJourneyJurisdictionDto {
    /** Name of the jurisdiction */
    name?: string | undefined;

    constructor(data?: IJourneyJurisdictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): JourneyJurisdictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyJurisdictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

/** Request DTO representing jurisdiction journey should operate on */
export interface IJourneyJurisdictionDto {
    /** Name of the jurisdiction */
    name?: string | undefined;
}

/** DTO representing Journey Milestone */
export class JourneyMilestoneDto implements IJourneyMilestoneDto {
    /** The UiD of the Journey Milestone */
    id!: string;
    /** Journey Milestone name */
    name!: string;
    /** Journey Milestone description */
    description?: string | undefined;
    /** Journey Milestone order */
    order?: number;
    /** List of Journey Milestone's stages */
    stages!: string[];

    constructor(data?: IJourneyMilestoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.stages = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.order = _data["order"];
            if (Array.isArray(_data["stages"])) {
                this.stages = [] as any;
                for (let item of _data["stages"])
                    this.stages!.push(item);
            }
        }
    }

    static fromJS(data: any): JourneyMilestoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyMilestoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["order"] = this.order;
        if (Array.isArray(this.stages)) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item);
        }
        return data;
    }
}

/** DTO representing Journey Milestone */
export interface IJourneyMilestoneDto {
    /** The UiD of the Journey Milestone */
    id: string;
    /** Journey Milestone name */
    name: string;
    /** Journey Milestone description */
    description?: string | undefined;
    /** Journey Milestone order */
    order?: number;
    /** List of Journey Milestone's stages */
    stages: string[];
}

/** Response DTO representing Journey Schedule date data */
export class JourneyScheduleDateDto implements IJourneyScheduleDateDto {
    /** The UiD of the Journey Schedule Date */
    id?: string;
    /** The UiD of the Entity the Journey is scheduled for */
    entityId?: string;
    /** The UiD of the Journey Schedule this date is being set for */
    journeyScheduleId?: string;
    /** The date the journey will be launched for */
    scheduledDate?: Date;
    /** To track if schedule record was manually created by a user */
    userCreated?: boolean;
    /** The reason for which the journey is scheduled */
    comment?: string | undefined;
    /** The type of Journey that will be launched */
    type?: string | undefined;

    constructor(data?: IJourneyScheduleDateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityId = _data["entityId"];
            this.journeyScheduleId = _data["journeyScheduleId"];
            this.scheduledDate = _data["scheduledDate"] ? new Date(_data["scheduledDate"].toString()) : <any>undefined;
            this.userCreated = _data["userCreated"];
            this.comment = _data["comment"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): JourneyScheduleDateDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleDateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityId"] = this.entityId;
        data["journeyScheduleId"] = this.journeyScheduleId;
        data["scheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : <any>undefined;
        data["userCreated"] = this.userCreated;
        data["comment"] = this.comment;
        data["type"] = this.type;
        return data;
    }
}

/** Response DTO representing Journey Schedule date data */
export interface IJourneyScheduleDateDto {
    /** The UiD of the Journey Schedule Date */
    id?: string;
    /** The UiD of the Entity the Journey is scheduled for */
    entityId?: string;
    /** The UiD of the Journey Schedule this date is being set for */
    journeyScheduleId?: string;
    /** The date the journey will be launched for */
    scheduledDate?: Date;
    /** To track if schedule record was manually created by a user */
    userCreated?: boolean;
    /** The reason for which the journey is scheduled */
    comment?: string | undefined;
    /** The type of Journey that will be launched */
    type?: string | undefined;
}

/** Service request data */
export class JourneyScheduleDateDtoServiceRequest implements IJourneyScheduleDateDtoServiceRequest {
    data?: JourneyScheduleDateDto;

    constructor(data?: IJourneyScheduleDateDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneyScheduleDateDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JourneyScheduleDateDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleDateDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IJourneyScheduleDateDtoServiceRequest {
    data?: JourneyScheduleDateDto;
}

/** Service response data */
export class JourneyScheduleDateDtoServiceResponse implements IJourneyScheduleDateDtoServiceResponse {
    data?: JourneyScheduleDateDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneyScheduleDateDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneyScheduleDateDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyScheduleDateDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleDateDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneyScheduleDateDtoServiceResponse {
    data?: JourneyScheduleDateDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** DTO representing journey Schedule data */
export class JourneyScheduleDto implements IJourneyScheduleDto {
    /** The UiD of journey Schedule */
    id?: string;
    /** Journey Schedule name */
    name?: string | undefined;
    /** Version notes */
    notes?: string | undefined;
    /** Journey Type */
    type?: string | undefined;
    /** The version number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The creation date of the version (Read-only) */
    created?: Date;
    status?: VersionStatus;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Conditions under which the Schedule can be used */
    conditions?: ConditionDto[] | undefined;

    constructor(data?: IJourneyScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.type = _data["type"];
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["type"] = this.type;
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        return data;
    }
}

/** DTO representing journey Schedule data */
export interface IJourneyScheduleDto {
    /** The UiD of journey Schedule */
    id?: string;
    /** Journey Schedule name */
    name?: string | undefined;
    /** Version notes */
    notes?: string | undefined;
    /** Journey Type */
    type?: string | undefined;
    /** The version number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The creation date of the version (Read-only) */
    created?: Date;
    status?: VersionStatus;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Conditions under which the Schedule can be used */
    conditions?: ConditionDto[] | undefined;
}

/** Service request data */
export class JourneyScheduleDtoServiceRequest implements IJourneyScheduleDtoServiceRequest {
    data?: JourneyScheduleDto;

    constructor(data?: IJourneyScheduleDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneyScheduleDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JourneyScheduleDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IJourneyScheduleDtoServiceRequest {
    data?: JourneyScheduleDto;
}

/** Service response data */
export class JourneyScheduleDtoServiceResponse implements IJourneyScheduleDtoServiceResponse {
    data?: JourneyScheduleDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneyScheduleDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneyScheduleDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyScheduleDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneyScheduleDtoServiceResponse {
    data?: JourneyScheduleDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Sign journey Schedule response contains the new version status */
export class JourneyScheduleVersionSignResponse implements IJourneyScheduleVersionSignResponse {
    /** The UiD of the journey Schedule */
    journeyScheduleId?: string;
    /** The number of the version that has been signed */
    versionNumber?: number;
    status?: VersionStatus;

    constructor(data?: IJourneyScheduleVersionSignResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeyScheduleId = _data["journeyScheduleId"];
            this.versionNumber = _data["versionNumber"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): JourneyScheduleVersionSignResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleVersionSignResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeyScheduleId"] = this.journeyScheduleId;
        data["versionNumber"] = this.versionNumber;
        data["status"] = this.status;
        return data;
    }
}

/** Sign journey Schedule response contains the new version status */
export interface IJourneyScheduleVersionSignResponse {
    /** The UiD of the journey Schedule */
    journeyScheduleId?: string;
    /** The number of the version that has been signed */
    versionNumber?: number;
    status?: VersionStatus;
}

/** Service response data */
export class JourneyScheduleVersionSignResponseServiceResponse implements IJourneyScheduleVersionSignResponseServiceResponse {
    data?: JourneyScheduleVersionSignResponse;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneyScheduleVersionSignResponseServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneyScheduleVersionSignResponse.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneyScheduleVersionSignResponseServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneyScheduleVersionSignResponseServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneyScheduleVersionSignResponseServiceResponse {
    data?: JourneyScheduleVersionSignResponse;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** DTO representing journey schema data */
export class JourneySchemaDto implements IJourneySchemaDto {
    /** The UiD of journey schema */
    journeySchemaId?: string;
    /** Journey schema name */
    name?: string | undefined;
    /** Journey schema identifier */
    identifier?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** Journey schema stage collection */
    stages?: StageDto[] | undefined;
    /** The version number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The creation date of the version (Read-only) */
    created?: Date;
    status?: VersionStatus;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Conditions under which the schema can be used */
    conditions?: ConditionDto[] | undefined;
    /** External Conditions under which the schema can be used */
    externalConditions?: ConditionDto[] | undefined;
    /** List of Journey Schema Milestones */
    milestones?: JourneyMilestoneDto[] | undefined;
    channelType?: ChannelTypeDto;

    constructor(data?: IJourneySchemaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeySchemaId = _data["journeySchemaId"];
            this.name = _data["name"];
            this.identifier = _data["identifier"];
            this.type = _data["type"];
            if (Array.isArray(_data["stages"])) {
                this.stages = [] as any;
                for (let item of _data["stages"])
                    this.stages!.push(StageDto.fromJS(item));
            }
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            if (Array.isArray(_data["externalConditions"])) {
                this.externalConditions = [] as any;
                for (let item of _data["externalConditions"])
                    this.externalConditions!.push(ConditionDto.fromJS(item));
            }
            if (Array.isArray(_data["milestones"])) {
                this.milestones = [] as any;
                for (let item of _data["milestones"])
                    this.milestones!.push(JourneyMilestoneDto.fromJS(item));
            }
            this.channelType = _data["channelType"];
        }
    }

    static fromJS(data: any): JourneySchemaDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeySchemaId"] = this.journeySchemaId;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["type"] = this.type;
        if (Array.isArray(this.stages)) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        if (Array.isArray(this.externalConditions)) {
            data["externalConditions"] = [];
            for (let item of this.externalConditions)
                data["externalConditions"].push(item.toJSON());
        }
        if (Array.isArray(this.milestones)) {
            data["milestones"] = [];
            for (let item of this.milestones)
                data["milestones"].push(item.toJSON());
        }
        data["channelType"] = this.channelType;
        return data;
    }
}

/** DTO representing journey schema data */
export interface IJourneySchemaDto {
    /** The UiD of journey schema */
    journeySchemaId?: string;
    /** Journey schema name */
    name?: string | undefined;
    /** Journey schema identifier */
    identifier?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** Journey schema stage collection */
    stages?: StageDto[] | undefined;
    /** The version number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The creation date of the version (Read-only) */
    created?: Date;
    status?: VersionStatus;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Conditions under which the schema can be used */
    conditions?: ConditionDto[] | undefined;
    /** External Conditions under which the schema can be used */
    externalConditions?: ConditionDto[] | undefined;
    /** List of Journey Schema Milestones */
    milestones?: JourneyMilestoneDto[] | undefined;
    channelType?: ChannelTypeDto;
}

/** Service request data */
export class JourneySchemaDtoServiceRequest implements IJourneySchemaDtoServiceRequest {
    data?: JourneySchemaDto;

    constructor(data?: IJourneySchemaDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneySchemaDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JourneySchemaDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IJourneySchemaDtoServiceRequest {
    data?: JourneySchemaDto;
}

/** Service response data */
export class JourneySchemaDtoServiceResponse implements IJourneySchemaDtoServiceResponse {
    data?: JourneySchemaDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneySchemaDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneySchemaDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneySchemaDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneySchemaDtoServiceResponse {
    data?: JourneySchemaDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing updated journey schema */
export class JourneySchemaUpdatedDto implements IJourneySchemaUpdatedDto {
    /** Journey schema aggregate version after update */
    version?: number;

    constructor(data?: IJourneySchemaUpdatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): JourneySchemaUpdatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaUpdatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing updated journey schema */
export interface IJourneySchemaUpdatedDto {
    /** Journey schema aggregate version after update */
    version?: number;
}

/** Service response data */
export class JourneySchemaUpdatedDtoServiceResponse implements IJourneySchemaUpdatedDtoServiceResponse {
    data?: JourneySchemaUpdatedDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneySchemaUpdatedDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneySchemaUpdatedDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneySchemaUpdatedDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaUpdatedDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneySchemaUpdatedDtoServiceResponse {
    data?: JourneySchemaUpdatedDto;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Sign journey schema response contains the new version status */
export class JourneySchemaVersionSignResponse implements IJourneySchemaVersionSignResponse {
    /** The UiD of the journey schema */
    journeySchemaId?: string;
    /** The number of the version that has been signed */
    versionNumber?: number;
    status?: VersionStatus;

    constructor(data?: IJourneySchemaVersionSignResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeySchemaId = _data["journeySchemaId"];
            this.versionNumber = _data["versionNumber"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): JourneySchemaVersionSignResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaVersionSignResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeySchemaId"] = this.journeySchemaId;
        data["versionNumber"] = this.versionNumber;
        data["status"] = this.status;
        return data;
    }
}

/** Sign journey schema response contains the new version status */
export interface IJourneySchemaVersionSignResponse {
    /** The UiD of the journey schema */
    journeySchemaId?: string;
    /** The number of the version that has been signed */
    versionNumber?: number;
    status?: VersionStatus;
}

/** Service response data */
export class JourneySchemaVersionSignResponseServiceResponse implements IJourneySchemaVersionSignResponseServiceResponse {
    data?: JourneySchemaVersionSignResponse;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IJourneySchemaVersionSignResponseServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? JourneySchemaVersionSignResponse.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JourneySchemaVersionSignResponseServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JourneySchemaVersionSignResponseServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IJourneySchemaVersionSignResponseServiceResponse {
    data?: JourneySchemaVersionSignResponse;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Service response data */
export class ObjectServiceResponse implements IObjectServiceResponse {
    /** The service response DTO */
    data?: any | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IObjectServiceResponse {
    /** The service response DTO */
    data?: any | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

/** DTO representing journey process */
export class ProcessDto implements IProcessDto {
    /** The UiD of the process */
    id!: string;
    /** Process name */
    name!: string;
    /** Process description */
    description?: string | undefined;
    /** Process order */
    order?: number;
    /** Determines the order of completing tasks. Defaults to Sequential.
One of Sequential, AnyOrder */
    tasksCompletionOrder?: string | undefined;
    /** List of process tasks */
    tasks!: TaskDto[];
    /** List of conditions required to trigger process */
    conditions?: ConditionDto[] | undefined;

    constructor(data?: IProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tasks = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.order = _data["order"];
            this.tasksCompletionOrder = _data["tasksCompletionOrder"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(TaskDto.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["order"] = this.order;
        data["tasksCompletionOrder"] = this.tasksCompletionOrder;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        return data;
    }
}

/** DTO representing journey process */
export interface IProcessDto {
    /** The UiD of the process */
    id: string;
    /** Process name */
    name: string;
    /** Process description */
    description?: string | undefined;
    /** Process order */
    order?: number;
    /** Determines the order of completing tasks. Defaults to Sequential.
One of Sequential, AnyOrder */
    tasksCompletionOrder?: string | undefined;
    /** List of process tasks */
    tasks: TaskDto[];
    /** List of conditions required to trigger process */
    conditions?: ConditionDto[] | undefined;
}

/** DTO representing reassign tasks in bulk */
export class ReassignMultipleTasksDto implements IReassignMultipleTasksDto {
    /** List of tasks to reassign */
    tasks?: ReassignTaskInBulkDto[] | undefined;

    constructor(data?: IReassignMultipleTasksDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(ReassignTaskInBulkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReassignMultipleTasksDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReassignMultipleTasksDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        return data;
    }
}

/** DTO representing reassign tasks in bulk */
export interface IReassignMultipleTasksDto {
    /** List of tasks to reassign */
    tasks?: ReassignTaskInBulkDto[] | undefined;
}

/** Service request data */
export class ReassignMultipleTasksDtoServiceRequest implements IReassignMultipleTasksDtoServiceRequest {
    data?: ReassignMultipleTasksDto;

    constructor(data?: IReassignMultipleTasksDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ReassignMultipleTasksDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReassignMultipleTasksDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReassignMultipleTasksDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IReassignMultipleTasksDtoServiceRequest {
    data?: ReassignMultipleTasksDto;
}

/** DTO representing reassign task */
export class ReassignTaskDto implements IReassignTaskDto {
    /** The UiD of the team */
    teamId?: string;
    /** The UiD of the task owner - user of the system who belongs to the reassigned team */
    ownerId?: string | undefined;
    /** Optional comment for task reassign action */
    comment?: string | undefined;

    constructor(data?: IReassignTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teamId = _data["teamId"];
            this.ownerId = _data["ownerId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ReassignTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReassignTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamId"] = this.teamId;
        data["ownerId"] = this.ownerId;
        data["comment"] = this.comment;
        return data;
    }
}

/** DTO representing reassign task */
export interface IReassignTaskDto {
    /** The UiD of the team */
    teamId?: string;
    /** The UiD of the task owner - user of the system who belongs to the reassigned team */
    ownerId?: string | undefined;
    /** Optional comment for task reassign action */
    comment?: string | undefined;
}

/** Service request data */
export class ReassignTaskDtoServiceRequest implements IReassignTaskDtoServiceRequest {
    data?: ReassignTaskDto;

    constructor(data?: IReassignTaskDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ReassignTaskDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReassignTaskDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReassignTaskDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IReassignTaskDtoServiceRequest {
    data?: ReassignTaskDto;
}

/** DTO representing an request of a task reassignment process */
export class ReassignTaskInBulkDto implements IReassignTaskInBulkDto {
    /** The UiD of the task */
    taskId!: string;
    /** The UiD of the journey */
    journeyInstanceId!: string;
    /** The UiD of the team */
    teamId?: string;
    /** The UiD of the task owner - user of the system who belongs to the reassigned team */
    ownerId?: string | undefined;
    /** Optional comment for task reassign action */
    comment?: string | undefined;

    constructor(data?: IReassignTaskInBulkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.journeyInstanceId = _data["journeyInstanceId"];
            this.teamId = _data["teamId"];
            this.ownerId = _data["ownerId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ReassignTaskInBulkDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReassignTaskInBulkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["journeyInstanceId"] = this.journeyInstanceId;
        data["teamId"] = this.teamId;
        data["ownerId"] = this.ownerId;
        data["comment"] = this.comment;
        return data;
    }
}

/** DTO representing an request of a task reassignment process */
export interface IReassignTaskInBulkDto {
    /** The UiD of the task */
    taskId: string;
    /** The UiD of the journey */
    journeyInstanceId: string;
    /** The UiD of the team */
    teamId?: string;
    /** The UiD of the task owner - user of the system who belongs to the reassigned team */
    ownerId?: string | undefined;
    /** Optional comment for task reassign action */
    comment?: string | undefined;
}

/** DTO representing reset task */
export class ResetTaskDto implements IResetTaskDto {
    /** Comment for task reopen action */
    comment?: string | undefined;

    constructor(data?: IResetTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ResetTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        return data;
    }
}

/** DTO representing reset task */
export interface IResetTaskDto {
    /** Comment for task reopen action */
    comment?: string | undefined;
}

/** Service request data */
export class ResetTaskDtoServiceRequest implements IResetTaskDtoServiceRequest {
    data?: ResetTaskDto;

    constructor(data?: IResetTaskDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ResetTaskDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResetTaskDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetTaskDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IResetTaskDtoServiceRequest {
    data?: ResetTaskDto;
}

/** Request DTO representing review outcome task data to save */
export class ReviewOutcomeDto implements IReviewOutcomeDto {
    /** Outcome of the review - must be present on schema branches key parameter */
    outcome?: string | undefined;
    /** Review comment */
    message?: string | undefined;

    constructor(data?: IReviewOutcomeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outcome = _data["outcome"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ReviewOutcomeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewOutcomeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outcome"] = this.outcome;
        data["message"] = this.message;
        return data;
    }
}

/** Request DTO representing review outcome task data to save */
export interface IReviewOutcomeDto {
    /** Outcome of the review - must be present on schema branches key parameter */
    outcome?: string | undefined;
    /** Review comment */
    message?: string | undefined;
}

/** Service request data */
export class ReviewOutcomeDtoServiceRequest implements IReviewOutcomeDtoServiceRequest {
    data?: ReviewOutcomeDto;

    constructor(data?: IReviewOutcomeDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ReviewOutcomeDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReviewOutcomeDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewOutcomeDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IReviewOutcomeDtoServiceRequest {
    data?: ReviewOutcomeDto;
}

/** Service response data */
export class ServiceResponse implements IServiceResponse {
    /** The service response DTO */
    data?: string | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IServiceResponse {
    /** The service response DTO */
    data?: string | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** The message associated to the service response */
export class ServiceResponseMessage implements IServiceResponseMessage {
    /** The message */
    message?: string | undefined;
    /** Type of the message
One of Info, Warning, Error, Forbidden */
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

/** The message associated to the service response */
export interface IServiceResponseMessage {
    /** The message */
    message?: string | undefined;
    /** Type of the message
One of Info, Warning, Error, Forbidden */
    type?: string | undefined;
}

/** Defines a version Signee */
export class Signee implements ISignee {
    subject?: string | undefined;
    successor?: Approver;
    action?: ApproveAction;
    readonly hasProcessedRequest?: boolean;

    constructor(data?: ISignee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.successor = _data["successor"] ? Approver.fromJS(_data["successor"]) : <any>undefined;
            this.action = _data["action"] ? ApproveAction.fromJS(_data["action"]) : <any>undefined;
            (<any>this).hasProcessedRequest = _data["hasProcessedRequest"];
        }
    }

    static fromJS(data: any): Signee {
        data = typeof data === 'object' ? data : {};
        let result = new Signee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["successor"] = this.successor ? this.successor.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["hasProcessedRequest"] = this.hasProcessedRequest;
        return data;
    }
}

/** Defines a version Signee */
export interface ISignee {
    subject?: string | undefined;
    successor?: Approver;
    action?: ApproveAction;
    hasProcessedRequest?: boolean;
}

/** DTO representing journey stage */
export class StageDto implements IStageDto {
    /** The UiD of the stage */
    id!: string;
    /** Stage name */
    name!: string;
    /** Stage description */
    description?: string | undefined;
    /** Stage order */
    order?: number;
    /** Determines the order of completing processes. Defaults to Sequential.
One of Sequential, AnyOrder */
    processesCompletionOrder?: string | undefined;
    /** Optional list of previous stages when this stage should start */
    inParallelWithStages?: string[] | undefined;
    /** Stage channel */
    stageChannel?: string | undefined;
    /** List of stage processes */
    processes!: ProcessDto[];
    /** List of conditions required to trigger stage */
    conditions?: ConditionDto[] | undefined;

    constructor(data?: IStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.processes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.order = _data["order"];
            this.processesCompletionOrder = _data["processesCompletionOrder"];
            if (Array.isArray(_data["inParallelWithStages"])) {
                this.inParallelWithStages = [] as any;
                for (let item of _data["inParallelWithStages"])
                    this.inParallelWithStages!.push(item);
            }
            this.stageChannel = _data["stageChannel"];
            if (Array.isArray(_data["processes"])) {
                this.processes = [] as any;
                for (let item of _data["processes"])
                    this.processes!.push(ProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StageDto {
        data = typeof data === 'object' ? data : {};
        let result = new StageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["order"] = this.order;
        data["processesCompletionOrder"] = this.processesCompletionOrder;
        if (Array.isArray(this.inParallelWithStages)) {
            data["inParallelWithStages"] = [];
            for (let item of this.inParallelWithStages)
                data["inParallelWithStages"].push(item);
        }
        data["stageChannel"] = this.stageChannel;
        if (Array.isArray(this.processes)) {
            data["processes"] = [];
            for (let item of this.processes)
                data["processes"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        return data;
    }
}

/** DTO representing journey stage */
export interface IStageDto {
    /** The UiD of the stage */
    id: string;
    /** Stage name */
    name: string;
    /** Stage description */
    description?: string | undefined;
    /** Stage order */
    order?: number;
    /** Determines the order of completing processes. Defaults to Sequential.
One of Sequential, AnyOrder */
    processesCompletionOrder?: string | undefined;
    /** Optional list of previous stages when this stage should start */
    inParallelWithStages?: string[] | undefined;
    /** Stage channel */
    stageChannel?: string | undefined;
    /** List of stage processes */
    processes: ProcessDto[];
    /** List of conditions required to trigger stage */
    conditions?: ConditionDto[] | undefined;
}

/** DTO representing journey task */
export class TaskDto implements ITaskDto {
    /** The UiD of the task */
    id!: string;
    /** Task name */
    name!: string;
    /** Task key */
    taskKey?: string | undefined;
    /** Task description */
    description?: string | undefined;
    /** Task order */
    order?: number;
    /** Task type */
    taskType!: string;
    /** Team id that task belongs to */
    teamId?: string | undefined;
    /** List of conditions required to trigger task */
    conditions?: ConditionDto[] | undefined;
    /** List of previous tasks that must be completed before this task */
    completeAfter?: string[] | undefined;
    /** Policy target */
    policyTarget?: string | undefined;
    /** Policy category */
    policyCategory?: string | undefined;
    /** Policy requirement type */
    policyRequirementType?: string | undefined;
    /** List of policy business category e.g. ["Basic Details", "Enrich Details"] */
    businessCategory?: string[] | undefined;
    /** Policy subcategory */
    businessSubCategory?: string | undefined;
    /** Enable Document Persistence */
    documentPersistence?: boolean | undefined;
    /** List of related party data and document category e.g. ["Related Party Basic Details", "Relationship Details"] */
    relatedPartyCategory?: string[] | undefined;
    /** Service name */
    serviceName?: string | undefined;
    /** Service task properties */
    properties?: { [key: string]: string; } | undefined;
    /** Risk assessment condition task - List of risk levels e.g. ["High", "Restricted"] */
    riskLevels?: string[] | undefined;
    /** Risk assessment condition task - the policy field where the risk is stored, used in the condition */
    riskConditionField?: string | undefined;
    /** Entity data and If/Then condition task property */
    property?: string | undefined;
    /** Entity data condition task value */
    value?: string | undefined;
    /** Group task - list of sub tasks */
    subTasks?: TaskDto[] | undefined;
    /** Branchable task - list of branches */
    branches?: { [key: string]: TaskDto; } | undefined;
    /** Data review task - approval method */
    approvalMethod?: string | undefined;
    /** Data review task - outcome */
    outcome?: string | undefined;
    /** Data review task - message */
    message?: string | undefined;
    /** Data review task - include revise outcome */
    includeReviseOutcome?: boolean;
    /** Data review task - include risk section */
    includeRiskSection?: boolean;
    /** Combined policy task - list of policy requirement types */
    policyRequirementTypes?: string[] | undefined;

    constructor(data?: ITaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.taskKey = _data["taskKey"];
            this.description = _data["description"];
            this.order = _data["order"];
            this.taskType = _data["taskType"];
            this.teamId = _data["teamId"];
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            if (Array.isArray(_data["completeAfter"])) {
                this.completeAfter = [] as any;
                for (let item of _data["completeAfter"])
                    this.completeAfter!.push(item);
            }
            this.policyTarget = _data["policyTarget"];
            this.policyCategory = _data["policyCategory"];
            this.policyRequirementType = _data["policyRequirementType"];
            if (Array.isArray(_data["businessCategory"])) {
                this.businessCategory = [] as any;
                for (let item of _data["businessCategory"])
                    this.businessCategory!.push(item);
            }
            this.businessSubCategory = _data["businessSubCategory"];
            this.documentPersistence = _data["documentPersistence"];
            if (Array.isArray(_data["relatedPartyCategory"])) {
                this.relatedPartyCategory = [] as any;
                for (let item of _data["relatedPartyCategory"])
                    this.relatedPartyCategory!.push(item);
            }
            this.serviceName = _data["serviceName"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            if (Array.isArray(_data["riskLevels"])) {
                this.riskLevels = [] as any;
                for (let item of _data["riskLevels"])
                    this.riskLevels!.push(item);
            }
            this.riskConditionField = _data["riskConditionField"];
            this.property = _data["property"];
            this.value = _data["value"];
            if (Array.isArray(_data["subTasks"])) {
                this.subTasks = [] as any;
                for (let item of _data["subTasks"])
                    this.subTasks!.push(TaskDto.fromJS(item));
            }
            if (_data["branches"]) {
                this.branches = {} as any;
                for (let key in _data["branches"]) {
                    if (_data["branches"].hasOwnProperty(key))
                        (<any>this.branches)![key] = _data["branches"][key] ? TaskDto.fromJS(_data["branches"][key]) : new TaskDto();
                }
            }
            this.approvalMethod = _data["approvalMethod"];
            this.outcome = _data["outcome"];
            this.message = _data["message"];
            this.includeReviseOutcome = _data["includeReviseOutcome"];
            this.includeRiskSection = _data["includeRiskSection"];
            if (Array.isArray(_data["policyRequirementTypes"])) {
                this.policyRequirementTypes = [] as any;
                for (let item of _data["policyRequirementTypes"])
                    this.policyRequirementTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): TaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["taskKey"] = this.taskKey;
        data["description"] = this.description;
        data["order"] = this.order;
        data["taskType"] = this.taskType;
        data["teamId"] = this.teamId;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        if (Array.isArray(this.completeAfter)) {
            data["completeAfter"] = [];
            for (let item of this.completeAfter)
                data["completeAfter"].push(item);
        }
        data["policyTarget"] = this.policyTarget;
        data["policyCategory"] = this.policyCategory;
        data["policyRequirementType"] = this.policyRequirementType;
        if (Array.isArray(this.businessCategory)) {
            data["businessCategory"] = [];
            for (let item of this.businessCategory)
                data["businessCategory"].push(item);
        }
        data["businessSubCategory"] = this.businessSubCategory;
        data["documentPersistence"] = this.documentPersistence;
        if (Array.isArray(this.relatedPartyCategory)) {
            data["relatedPartyCategory"] = [];
            for (let item of this.relatedPartyCategory)
                data["relatedPartyCategory"].push(item);
        }
        data["serviceName"] = this.serviceName;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        if (Array.isArray(this.riskLevels)) {
            data["riskLevels"] = [];
            for (let item of this.riskLevels)
                data["riskLevels"].push(item);
        }
        data["riskConditionField"] = this.riskConditionField;
        data["property"] = this.property;
        data["value"] = this.value;
        if (Array.isArray(this.subTasks)) {
            data["subTasks"] = [];
            for (let item of this.subTasks)
                data["subTasks"].push(item.toJSON());
        }
        if (this.branches) {
            data["branches"] = {};
            for (let key in this.branches) {
                if (this.branches.hasOwnProperty(key))
                    (<any>data["branches"])[key] = this.branches[key] ? this.branches[key].toJSON() : <any>undefined;
            }
        }
        data["approvalMethod"] = this.approvalMethod;
        data["outcome"] = this.outcome;
        data["message"] = this.message;
        data["includeReviseOutcome"] = this.includeReviseOutcome;
        data["includeRiskSection"] = this.includeRiskSection;
        if (Array.isArray(this.policyRequirementTypes)) {
            data["policyRequirementTypes"] = [];
            for (let item of this.policyRequirementTypes)
                data["policyRequirementTypes"].push(item);
        }
        return data;
    }
}

/** DTO representing journey task */
export interface ITaskDto {
    /** The UiD of the task */
    id: string;
    /** Task name */
    name: string;
    /** Task key */
    taskKey?: string | undefined;
    /** Task description */
    description?: string | undefined;
    /** Task order */
    order?: number;
    /** Task type */
    taskType: string;
    /** Team id that task belongs to */
    teamId?: string | undefined;
    /** List of conditions required to trigger task */
    conditions?: ConditionDto[] | undefined;
    /** List of previous tasks that must be completed before this task */
    completeAfter?: string[] | undefined;
    /** Policy target */
    policyTarget?: string | undefined;
    /** Policy category */
    policyCategory?: string | undefined;
    /** Policy requirement type */
    policyRequirementType?: string | undefined;
    /** List of policy business category e.g. ["Basic Details", "Enrich Details"] */
    businessCategory?: string[] | undefined;
    /** Policy subcategory */
    businessSubCategory?: string | undefined;
    /** Enable Document Persistence */
    documentPersistence?: boolean | undefined;
    /** List of related party data and document category e.g. ["Related Party Basic Details", "Relationship Details"] */
    relatedPartyCategory?: string[] | undefined;
    /** Service name */
    serviceName?: string | undefined;
    /** Service task properties */
    properties?: { [key: string]: string; } | undefined;
    /** Risk assessment condition task - List of risk levels e.g. ["High", "Restricted"] */
    riskLevels?: string[] | undefined;
    /** Risk assessment condition task - the policy field where the risk is stored, used in the condition */
    riskConditionField?: string | undefined;
    /** Entity data and If/Then condition task property */
    property?: string | undefined;
    /** Entity data condition task value */
    value?: string | undefined;
    /** Group task - list of sub tasks */
    subTasks?: TaskDto[] | undefined;
    /** Branchable task - list of branches */
    branches?: { [key: string]: TaskDto; } | undefined;
    /** Data review task - approval method */
    approvalMethod?: string | undefined;
    /** Data review task - outcome */
    outcome?: string | undefined;
    /** Data review task - message */
    message?: string | undefined;
    /** Data review task - include revise outcome */
    includeReviseOutcome?: boolean;
    /** Data review task - include risk section */
    includeRiskSection?: boolean;
    /** Combined policy task - list of policy requirement types */
    policyRequirementTypes?: string[] | undefined;
}

/** DTO representing an outcome of a task reassignment process */
export class TaskReassignOutcomeDto implements ITaskReassignOutcomeDto {
    /** The UiD of the journey */
    journeyInstanceId?: string;
    /** The UiD of the task */
    taskId?: string;
    /** Information if task has been reassigned successfully */
    success?: boolean;
    /** Information about the reason why the task could not be reassigned. */
    errorMessage?: string | undefined;

    constructor(data?: ITaskReassignOutcomeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeyInstanceId = _data["journeyInstanceId"];
            this.taskId = _data["taskId"];
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): TaskReassignOutcomeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskReassignOutcomeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeyInstanceId"] = this.journeyInstanceId;
        data["taskId"] = this.taskId;
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

/** DTO representing an outcome of a task reassignment process */
export interface ITaskReassignOutcomeDto {
    /** The UiD of the journey */
    journeyInstanceId?: string;
    /** The UiD of the task */
    taskId?: string;
    /** Information if task has been reassigned successfully */
    success?: boolean;
    /** Information about the reason why the task could not be reassigned. */
    errorMessage?: string | undefined;
}

/** Service response data */
export class TaskReassignOutcomeDtoListServiceResponse implements ITaskReassignOutcomeDtoListServiceResponse {
    /** The service response DTO */
    data?: TaskReassignOutcomeDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ITaskReassignOutcomeDtoListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TaskReassignOutcomeDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaskReassignOutcomeDtoListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskReassignOutcomeDtoListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface ITaskReassignOutcomeDtoListServiceResponse {
    /** The service response DTO */
    data?: TaskReassignOutcomeDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Request DTO representing the journey instance access layers data */
export class UpdateJourneyInstanceAccessLayersDto implements IUpdateJourneyInstanceAccessLayersDto {
    accessLayers?: AccessLayerDto;
    /** Current version of the Journey instance where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;

    constructor(data?: IUpdateJourneyInstanceAccessLayersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = -1;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.version = _data["version"] !== undefined ? _data["version"] : -1;
        }
    }

    static fromJS(data: any): UpdateJourneyInstanceAccessLayersDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJourneyInstanceAccessLayersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

/** Request DTO representing the journey instance access layers data */
export interface IUpdateJourneyInstanceAccessLayersDto {
    accessLayers?: AccessLayerDto;
    /** Current version of the Journey instance where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;
}

/** Service request data */
export class UpdateJourneyInstanceAccessLayersDtoServiceRequest implements IUpdateJourneyInstanceAccessLayersDtoServiceRequest {
    data?: UpdateJourneyInstanceAccessLayersDto;

    constructor(data?: IUpdateJourneyInstanceAccessLayersDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateJourneyInstanceAccessLayersDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateJourneyInstanceAccessLayersDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJourneyInstanceAccessLayersDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IUpdateJourneyInstanceAccessLayersDtoServiceRequest {
    data?: UpdateJourneyInstanceAccessLayersDto;
}

/** Request DTO representing set of properties which define a new version of journey Schedule */
export class UpdateJourneyScheduleVersionDto implements IUpdateJourneyScheduleVersionDto {
    /** The UiD of the journey Schedule */
    journeyScheduleId?: string;
    /** Journey schedule name */
    name?: string | undefined;
    /** Journey Type */
    type?: string | undefined;
    /** Version Notes */
    notes?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Conditions under which the Schedule can be used */
    conditions?: ConditionDto[] | undefined;
    /** Current version of journey instance aggregate where the changes needs to be applied. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;

    constructor(data?: IUpdateJourneyScheduleVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = -1;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeyScheduleId = _data["journeyScheduleId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.notes = _data["notes"];
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            this.version = _data["version"] !== undefined ? _data["version"] : -1;
        }
    }

    static fromJS(data: any): UpdateJourneyScheduleVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJourneyScheduleVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeyScheduleId"] = this.journeyScheduleId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["notes"] = this.notes;
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

/** Request DTO representing set of properties which define a new version of journey Schedule */
export interface IUpdateJourneyScheduleVersionDto {
    /** The UiD of the journey Schedule */
    journeyScheduleId?: string;
    /** Journey schedule name */
    name?: string | undefined;
    /** Journey Type */
    type?: string | undefined;
    /** Version Notes */
    notes?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Conditions under which the Schedule can be used */
    conditions?: ConditionDto[] | undefined;
    /** Current version of journey instance aggregate where the changes needs to be applied. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;
}

/** Service request data */
export class UpdateJourneyScheduleVersionDtoServiceRequest implements IUpdateJourneyScheduleVersionDtoServiceRequest {
    data?: UpdateJourneyScheduleVersionDto;

    constructor(data?: IUpdateJourneyScheduleVersionDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateJourneyScheduleVersionDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateJourneyScheduleVersionDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJourneyScheduleVersionDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IUpdateJourneyScheduleVersionDtoServiceRequest {
    data?: UpdateJourneyScheduleVersionDto;
}

/** Request DTO representing set of properties which define a new version of journey schema */
export class UpdateJourneySchemaVersionDto implements IUpdateJourneySchemaVersionDto {
    /** The UiD of the journey schema */
    journeySchemaId?: string;
    /** Journey schema name */
    name?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** Journey schema stage collection */
    stages?: StageDto[] | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Conditions under which the schema can be used */
    conditions?: ConditionDto[] | undefined;
    /** External Conditions under which the schema can be used */
    externalConditions?: ConditionDto[] | undefined;
    /** List of Journey Schema Milestones */
    milestones?: JourneyMilestoneDto[] | undefined;
    channelType?: ChannelTypeDto;
    /** Current version of journey schema version aggregate where the changes needs to be applied. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;

    constructor(data?: IUpdateJourneySchemaVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = -1;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeySchemaId = _data["journeySchemaId"];
            this.name = _data["name"];
            this.type = _data["type"];
            if (Array.isArray(_data["stages"])) {
                this.stages = [] as any;
                for (let item of _data["stages"])
                    this.stages!.push(StageDto.fromJS(item));
            }
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            if (Array.isArray(_data["externalConditions"])) {
                this.externalConditions = [] as any;
                for (let item of _data["externalConditions"])
                    this.externalConditions!.push(ConditionDto.fromJS(item));
            }
            if (Array.isArray(_data["milestones"])) {
                this.milestones = [] as any;
                for (let item of _data["milestones"])
                    this.milestones!.push(JourneyMilestoneDto.fromJS(item));
            }
            this.channelType = _data["channelType"];
            this.version = _data["version"] !== undefined ? _data["version"] : -1;
        }
    }

    static fromJS(data: any): UpdateJourneySchemaVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJourneySchemaVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeySchemaId"] = this.journeySchemaId;
        data["name"] = this.name;
        data["type"] = this.type;
        if (Array.isArray(this.stages)) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        if (Array.isArray(this.externalConditions)) {
            data["externalConditions"] = [];
            for (let item of this.externalConditions)
                data["externalConditions"].push(item.toJSON());
        }
        if (Array.isArray(this.milestones)) {
            data["milestones"] = [];
            for (let item of this.milestones)
                data["milestones"].push(item.toJSON());
        }
        data["channelType"] = this.channelType;
        data["version"] = this.version;
        return data;
    }
}

/** Request DTO representing set of properties which define a new version of journey schema */
export interface IUpdateJourneySchemaVersionDto {
    /** The UiD of the journey schema */
    journeySchemaId?: string;
    /** Journey schema name */
    name?: string | undefined;
    /** Journey schema type */
    type?: string | undefined;
    /** Journey schema stage collection */
    stages?: StageDto[] | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Conditions under which the schema can be used */
    conditions?: ConditionDto[] | undefined;
    /** External Conditions under which the schema can be used */
    externalConditions?: ConditionDto[] | undefined;
    /** List of Journey Schema Milestones */
    milestones?: JourneyMilestoneDto[] | undefined;
    channelType?: ChannelTypeDto;
    /** Current version of journey schema version aggregate where the changes needs to be applied. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;
}

/** Service request data */
export class UpdateJourneySchemaVersionDtoServiceRequest implements IUpdateJourneySchemaVersionDtoServiceRequest {
    data?: UpdateJourneySchemaVersionDto;

    constructor(data?: IUpdateJourneySchemaVersionDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateJourneySchemaVersionDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateJourneySchemaVersionDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJourneySchemaVersionDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IUpdateJourneySchemaVersionDtoServiceRequest {
    data?: UpdateJourneySchemaVersionDto;
}

/** Represents the details of validation error */
export class ValidationErrorModel implements IValidationErrorModel {
    /** Name of the property */
    propertyName?: string | undefined;
    /** User friendly error message */
    errorMessage?: string | undefined;
    /** Invalid value */
    attemptedValue?: any | undefined;
    /** Internal error code */
    errorCode?: string | undefined;

    constructor(data?: IValidationErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            this.attemptedValue = _data["attemptedValue"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ValidationErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

/** Represents the details of validation error */
export interface IValidationErrorModel {
    /** Name of the property */
    propertyName?: string | undefined;
    /** User friendly error message */
    errorMessage?: string | undefined;
    /** Invalid value */
    attemptedValue?: any | undefined;
    /** Internal error code */
    errorCode?: string | undefined;
}

/** Service response data */
export class ValidationErrorModelListServiceResponse implements IValidationErrorModelListServiceResponse {
    /** The service response DTO */
    data?: ValidationErrorModel[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IValidationErrorModelListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ValidationErrorModel.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationErrorModelListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModelListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IValidationErrorModelListServiceResponse {
    /** The service response DTO */
    data?: ValidationErrorModel[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export enum VersionStatus {
    Draft = "Draft",
    Pending = "Pending",
    Rejected = "Rejected",
    Published = "Published",
    Archived = "Archived",
    Deleted = "Deleted",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}