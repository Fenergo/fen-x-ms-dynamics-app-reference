//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * Create entity
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Create entity request
     * @return Success. Entity created
     */
    createEntity(x_TENANT_ID: string, body: EntityDtoServiceRequest | undefined): Promise<EntityCreatedDtoServiceResponse>;
    /**
     * Update entity status
     * @param id Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update entity status request
     * @return Success. Entity status updated
     * @deprecated
     */
    updateEntityStatus(id: string, x_TENANT_ID: string, body: UpdateEntityStatusDtoServiceRequest | undefined): Promise<void>;
    /**
     * Update entity draft
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update entity draft request. Must contain Policy jurisdiction(s) and entity draft properties
     * @return Success. Entity draft updated
     */
    updateEntityDraftRecordV2(entityId: string, id: string, x_TENANT_ID: string, body: UpdateEntityDraftRequestV3DtoServiceRequest | undefined): Promise<EntityDraftUpdatedDtoServiceResponse>;
    /**
     * Manage conflicts for Entity Draft Record.
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Conflict Resolutions request
     * @return Success. Entity draft verified
     */
    entityDraftConflicts(entityId: string, id: string, x_TENANT_ID: string, body: DraftConflictDtoServiceRequest | undefined): Promise<void>;
    /**
     * Create entity draft
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Create entity draft request
     * @return Success. Entity draft created
     */
    createEntityDraft(entityId: string, x_TENANT_ID: string, body: EntityDraftDtoServiceRequest | undefined): Promise<EntityDraftCreatedDtoServiceResponse>;
    /**
     * Verify entity draft
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Conflict Resolutions request
     * @return Success. Entity draft verified
     */
    verifyEntityDraft(entityId: string, id: string, x_TENANT_ID: string, body: ConflictResolutionsDtoServiceRequest | undefined): Promise<void>;
    /**
     * Reject entity draft
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Reject Entity Draft request
     * @return Success. Entity draft rejected
     */
    rejectEntityDraft(entityId: string, id: string, x_TENANT_ID: string, body: RejectEntityDraftDtoServiceRequest | undefined): Promise<void>;
    /**
     * Update risk of entity draft
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update entity draft risk request
     * @return Success. Entity draft risk updated
     */
    updateEntityDraftRisk(entityId: string, id: string, x_TENANT_ID: string, body: EntityRiskDtoServiceRequest | undefined): Promise<void>;
    /**
     * Update the role of entity draft
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update entity draft role request
     * @return Success. Entity draft role updated
     */
    updateEntityDraftRole(entityId: string, id: string, x_TENANT_ID: string, body: EntityRoleDtoServiceRequest | undefined): Promise<void>;
    /**
     * Update the access layers of the entity draft. The changes will be propagated to related entity.
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update entity draft role request
     * @return Success. Entity draft role updated
     */
    updateEntityDraftAccessLayers(entityId: string, id: string, x_TENANT_ID: string, body: UpdateDraftAccessLayersDtoServiceRequest | undefined): Promise<void>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/entitydatacommand";

    }

    /**
     * Create entity
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Create entity request
     * @return Success. Entity created
     */
    createEntity(x_TENANT_ID: string, body: EntityDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<EntityCreatedDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/entity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: AxiosResponse): Promise<EntityCreatedDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = EntityCreatedDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<EntityCreatedDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityCreatedDtoServiceResponse>(null as any);
    }

    /**
     * Update entity status
     * @param id Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update entity status request
     * @return Success. Entity status updated
     * @deprecated
     */
    updateEntityStatus(id: string, x_TENANT_ID: string, body: UpdateEntityStatusDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/entity/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateEntityStatus(_response);
        });
    }

    protected processUpdateEntityStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update entity draft
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update entity draft request. Must contain Policy jurisdiction(s) and entity draft properties
     * @return Success. Entity draft updated
     */
    updateEntityDraftRecordV2(entityId: string, id: string, x_TENANT_ID: string, body: UpdateEntityDraftRequestV3DtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<EntityDraftUpdatedDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/entity/{entityId}/draft/{id}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateEntityDraftRecordV2(_response);
        });
    }

    protected processUpdateEntityDraftRecordV2(response: AxiosResponse): Promise<EntityDraftUpdatedDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = EntityDraftUpdatedDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<EntityDraftUpdatedDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectServiceResponse.fromJS(resultData409);
            return throwException("Conflict saving changes in expected version", status, _responseText, _headers, result409);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDraftUpdatedDtoServiceResponse>(null as any);
    }

    /**
     * Manage conflicts for Entity Draft Record.
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Conflict Resolutions request
     * @return Success. Entity draft verified
     */
    entityDraftConflicts(entityId: string, id: string, x_TENANT_ID: string, body: DraftConflictDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/entity/{entityId}/draft/{id}/conflicts";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityDraftConflicts(_response);
        });
    }

    protected processEntityDraftConflicts(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectServiceResponse.fromJS(resultData409);
            return throwException("Conflict saving changes in expected version", status, _responseText, _headers, result409);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create entity draft
     * @param entityId Entity id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Create entity draft request
     * @return Success. Entity draft created
     */
    createEntityDraft(entityId: string, x_TENANT_ID: string, body: EntityDraftDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<EntityDraftCreatedDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/entity/{entityId}/draft";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateEntityDraft(_response);
        });
    }

    protected processCreateEntityDraft(response: AxiosResponse): Promise<EntityDraftCreatedDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = EntityDraftCreatedDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<EntityDraftCreatedDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityDraftCreatedDtoServiceResponse>(null as any);
    }

    /**
     * Verify entity draft
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Conflict Resolutions request
     * @return Success. Entity draft verified
     */
    verifyEntityDraft(entityId: string, id: string, x_TENANT_ID: string, body: ConflictResolutionsDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/entity/{entityId}/draft/{id}/verify";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyEntityDraft(_response);
        });
    }

    protected processVerifyEntityDraft(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectServiceResponse.fromJS(resultData409);
            return throwException("Conflict saving changes in expected version", status, _responseText, _headers, result409);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Reject entity draft
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Reject Entity Draft request
     * @return Success. Entity draft rejected
     */
    rejectEntityDraft(entityId: string, id: string, x_TENANT_ID: string, body: RejectEntityDraftDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/entity/{entityId}/draft/{id}/reject";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRejectEntityDraft(_response);
        });
    }

    protected processRejectEntityDraft(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectServiceResponse.fromJS(resultData409);
            return throwException("Conflict saving changes in expected version", status, _responseText, _headers, result409);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update risk of entity draft
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update entity draft risk request
     * @return Success. Entity draft risk updated
     */
    updateEntityDraftRisk(entityId: string, id: string, x_TENANT_ID: string, body: EntityRiskDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/entity/{entityId}/draft/{id}/risk";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateEntityDraftRisk(_response);
        });
    }

    protected processUpdateEntityDraftRisk(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectServiceResponse.fromJS(resultData409);
            return throwException("Conflict saving changes in expected version", status, _responseText, _headers, result409);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update the role of entity draft
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update entity draft role request
     * @return Success. Entity draft role updated
     */
    updateEntityDraftRole(entityId: string, id: string, x_TENANT_ID: string, body: EntityRoleDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/entity/{entityId}/draft/{id}/role";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateEntityDraftRole(_response);
        });
    }

    protected processUpdateEntityDraftRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectServiceResponse.fromJS(resultData409);
            return throwException("Conflict saving changes in expected version", status, _responseText, _headers, result409);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update the access layers of the entity draft. The changes will be propagated to related entity.
     * @param entityId Entity id
     * @param id Entity draft id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update entity draft role request
     * @return Success. Entity draft role updated
     */
    updateEntityDraftAccessLayers(entityId: string, id: string, x_TENANT_ID: string, body: UpdateDraftAccessLayersDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/entity/{entityId}/draft/{id}/access-layers";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateEntityDraftAccessLayers(_response);
        });
    }

    protected processUpdateEntityDraftAccessLayers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectServiceResponse.fromJS(resultData409);
            return throwException("Conflict saving changes in expected version", status, _responseText, _headers, result409);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

/** Response DTO representing associated access layers */
export class AccessLayerDto implements IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;

    constructor(data?: IAccessLayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["geographic"])) {
                this.geographic = [] as any;
                for (let item of _data["geographic"])
                    this.geographic!.push(item);
            }
            if (Array.isArray(_data["businessRelated"])) {
                this.businessRelated = [] as any;
                for (let item of _data["businessRelated"])
                    this.businessRelated!.push(item);
            }
        }
    }

    static fromJS(data: any): AccessLayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.geographic)) {
            data["geographic"] = [];
            for (let item of this.geographic)
                data["geographic"].push(item);
        }
        if (Array.isArray(this.businessRelated)) {
            data["businessRelated"] = [];
            for (let item of this.businessRelated)
                data["businessRelated"].push(item);
        }
        return data;
    }
}

/** Response DTO representing associated access layers */
export interface IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;
}

export class CollectionDto implements ICollectionDto {
    isValid?: boolean;
    properties?: { [key: string]: string; } | undefined;

    constructor(data?: ICollectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface ICollectionDto {
    isValid?: boolean;
    properties?: { [key: string]: string; } | undefined;
}

export class PropertyDto implements IPropertyDto {
    readonly type?: PropertyType;
    isValid?: boolean | undefined;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
            this.isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["isValid"] = this.isValid;
        return data;
    }
}

export interface IPropertyDto {
    type?: PropertyType;
    isValid?: boolean | undefined;
}

export class CollectionPropertyDto extends PropertyDto implements ICollectionPropertyDto {
    dataGroupId?: string;
    dataGroupVersionNumber?: number | undefined;
    collections?: { [key: string]: CollectionDto; } | undefined;

    constructor(data?: ICollectionPropertyDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dataGroupId = _data["dataGroupId"];
            this.dataGroupVersionNumber = _data["dataGroupVersionNumber"];
            if (_data["collections"]) {
                this.collections = {} as any;
                for (let key in _data["collections"]) {
                    if (_data["collections"].hasOwnProperty(key))
                        (<any>this.collections)![key] = _data["collections"][key] ? CollectionDto.fromJS(_data["collections"][key]) : new CollectionDto();
                }
            }
        }
    }

    static fromJS(data: any): CollectionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataGroupId"] = this.dataGroupId;
        data["dataGroupVersionNumber"] = this.dataGroupVersionNumber;
        if (this.collections) {
            data["collections"] = {};
            for (let key in this.collections) {
                if (this.collections.hasOwnProperty(key))
                    (<any>data["collections"])[key] = this.collections[key] ? this.collections[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICollectionPropertyDto extends IPropertyDto {
    dataGroupId?: string;
    dataGroupVersionNumber?: number | undefined;
    collections?: { [key: string]: CollectionDto; } | undefined;
}

/** Request DTO representing the conflict resolution data */
export class ConflictResolutionsDto implements IConflictResolutionsDto {
    /** Data conflict resolutions properties */
    dataConflictResolutions?: { [key: string]: PropertyDto; } | undefined;
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;

    constructor(data?: IConflictResolutionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = -1;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["dataConflictResolutions"]) {
                this.dataConflictResolutions = {} as any;
                for (let key in _data["dataConflictResolutions"]) {
                    if (_data["dataConflictResolutions"].hasOwnProperty(key))
                        (<any>this.dataConflictResolutions)![key] = _data["dataConflictResolutions"][key] ? PropertyDto.fromJS(_data["dataConflictResolutions"][key]) : new PropertyDto();
                }
            }
            this.version = _data["version"] !== undefined ? _data["version"] : -1;
        }
    }

    static fromJS(data: any): ConflictResolutionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConflictResolutionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dataConflictResolutions) {
            data["dataConflictResolutions"] = {};
            for (let key in this.dataConflictResolutions) {
                if (this.dataConflictResolutions.hasOwnProperty(key))
                    (<any>data["dataConflictResolutions"])[key] = this.dataConflictResolutions[key] ? this.dataConflictResolutions[key].toJSON() : <any>undefined;
            }
        }
        data["version"] = this.version;
        return data;
    }
}

/** Request DTO representing the conflict resolution data */
export interface IConflictResolutionsDto {
    /** Data conflict resolutions properties */
    dataConflictResolutions?: { [key: string]: PropertyDto; } | undefined;
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;
}

export class ConflictResolutionsDtoServiceRequest implements IConflictResolutionsDtoServiceRequest {
    /** Request DTO representing the conflict resolution data */
    data?: ConflictResolutionsDto | undefined;

    constructor(data?: IConflictResolutionsDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ConflictResolutionsDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConflictResolutionsDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConflictResolutionsDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConflictResolutionsDtoServiceRequest {
    /** Request DTO representing the conflict resolution data */
    data?: ConflictResolutionsDto | undefined;
}

export class CustomPropertyDto extends PropertyDto implements ICustomPropertyDto {
    customTypeId?: string;
    properties?: { [key: string]: PropertyDto; } | undefined;

    constructor(data?: ICustomPropertyDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customTypeId = _data["customTypeId"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): CustomPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTypeId"] = this.customTypeId;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICustomPropertyDto extends IPropertyDto {
    customTypeId?: string;
    properties?: { [key: string]: PropertyDto; } | undefined;
}

/** Class to represent data conflicts */
export class DataConflictDto implements IDataConflictDto {
    /** Existing value. */
    existingValue?: PropertyDto | undefined;
    /** New value. */
    newValue?: PropertyDto | undefined;

    constructor(data?: IDataConflictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.existingValue = _data["existingValue"] ? PropertyDto.fromJS(_data["existingValue"]) : <any>undefined;
            this.newValue = _data["newValue"] ? PropertyDto.fromJS(_data["newValue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DataConflictDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataConflictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["existingValue"] = this.existingValue ? this.existingValue.toJSON() : <any>undefined;
        data["newValue"] = this.newValue ? this.newValue.toJSON() : <any>undefined;
        return data;
    }
}

/** Class to represent data conflicts */
export interface IDataConflictDto {
    /** Existing value. */
    existingValue?: PropertyDto | undefined;
    /** New value. */
    newValue?: PropertyDto | undefined;
}

/** Request DTO representing the conflict resolution data */
export class DraftConflictDto implements IDraftConflictDto {
    /** Used to determine if passed draft is outdated */
    entityVersion?: number | undefined;
    /** If true updates the entity Draft when all conflicts are resolved */
    pushChanges?: boolean;
    /** Data conflict resolutions properties */
    dataConflictResolutions?: { [key: string]: PropertyDto; } | undefined;

    constructor(data?: IDraftConflictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityVersion = _data["entityVersion"];
            this.pushChanges = _data["pushChanges"];
            if (_data["dataConflictResolutions"]) {
                this.dataConflictResolutions = {} as any;
                for (let key in _data["dataConflictResolutions"]) {
                    if (_data["dataConflictResolutions"].hasOwnProperty(key))
                        (<any>this.dataConflictResolutions)![key] = _data["dataConflictResolutions"][key] ? PropertyDto.fromJS(_data["dataConflictResolutions"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): DraftConflictDto {
        data = typeof data === 'object' ? data : {};
        let result = new DraftConflictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityVersion"] = this.entityVersion;
        data["pushChanges"] = this.pushChanges;
        if (this.dataConflictResolutions) {
            data["dataConflictResolutions"] = {};
            for (let key in this.dataConflictResolutions) {
                if (this.dataConflictResolutions.hasOwnProperty(key))
                    (<any>data["dataConflictResolutions"])[key] = this.dataConflictResolutions[key] ? this.dataConflictResolutions[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Request DTO representing the conflict resolution data */
export interface IDraftConflictDto {
    /** Used to determine if passed draft is outdated */
    entityVersion?: number | undefined;
    /** If true updates the entity Draft when all conflicts are resolved */
    pushChanges?: boolean;
    /** Data conflict resolutions properties */
    dataConflictResolutions?: { [key: string]: PropertyDto; } | undefined;
}

export class DraftConflictDtoServiceRequest implements IDraftConflictDtoServiceRequest {
    /** Request DTO representing the conflict resolution data */
    data?: DraftConflictDto | undefined;

    constructor(data?: IDraftConflictDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DraftConflictDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DraftConflictDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DraftConflictDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDraftConflictDtoServiceRequest {
    /** Request DTO representing the conflict resolution data */
    data?: DraftConflictDto | undefined;
}

/** Response DTO representing created entity */
export class EntityCreatedDto implements IEntityCreatedDto {
    /** Id of the created entity */
    id?: string;

    constructor(data?: IEntityCreatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityCreatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityCreatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** Response DTO representing created entity */
export interface IEntityCreatedDto {
    /** Id of the created entity */
    id?: string;
}

export class EntityCreatedDtoServiceResponse implements IEntityCreatedDtoServiceResponse {
    /** Response DTO representing created entity */
    data?: EntityCreatedDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEntityCreatedDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityCreatedDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityCreatedDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntityCreatedDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntityCreatedDtoServiceResponse {
    /** Response DTO representing created entity */
    data?: EntityCreatedDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing created entity draft */
export class EntityDraftCreatedDto implements IEntityDraftCreatedDto {
    /** Id of the created entity draft */
    id?: string;

    constructor(data?: IEntityDraftCreatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDraftCreatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDraftCreatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** Response DTO representing created entity draft */
export interface IEntityDraftCreatedDto {
    /** Id of the created entity draft */
    id?: string;
}

export class EntityDraftCreatedDtoServiceResponse implements IEntityDraftCreatedDtoServiceResponse {
    /** Response DTO representing created entity draft */
    data?: EntityDraftCreatedDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEntityDraftCreatedDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityDraftCreatedDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityDraftCreatedDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDraftCreatedDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntityDraftCreatedDtoServiceResponse {
    /** Response DTO representing created entity draft */
    data?: EntityDraftCreatedDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Request DTO to create new entity draft Contains required Journey id to define entity draft */
export class EntityDraftDto implements IEntityDraftDto {
    /** Journey id */
    journeyId?: string;
    /** Optional parent draft id (jurisdictions are taken from parent if defined) */
    parentDraftId?: string | undefined;

    constructor(data?: IEntityDraftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journeyId = _data["journeyId"];
            this.parentDraftId = _data["parentDraftId"];
        }
    }

    static fromJS(data: any): EntityDraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journeyId"] = this.journeyId;
        data["parentDraftId"] = this.parentDraftId;
        return data;
    }
}

/** Request DTO to create new entity draft Contains required Journey id to define entity draft */
export interface IEntityDraftDto {
    /** Journey id */
    journeyId?: string;
    /** Optional parent draft id (jurisdictions are taken from parent if defined) */
    parentDraftId?: string | undefined;
}

export class EntityDraftDtoServiceRequest implements IEntityDraftDtoServiceRequest {
    /** Request DTO to create new entity draft
Contains required Journey id to define entity draft */
    data?: EntityDraftDto | undefined;

    constructor(data?: IEntityDraftDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityDraftDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityDraftDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDraftDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEntityDraftDtoServiceRequest {
    /** Request DTO to create new entity draft
Contains required Journey id to define entity draft */
    data?: EntityDraftDto | undefined;
}

/** Response DTO representing updated entity draft */
export class EntityDraftUpdatedDto implements IEntityDraftUpdatedDto {
    /** Version of entity draft after update */
    version?: number;

    constructor(data?: IEntityDraftUpdatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): EntityDraftUpdatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDraftUpdatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing updated entity draft */
export interface IEntityDraftUpdatedDto {
    /** Version of entity draft after update */
    version?: number;
}

export class EntityDraftUpdatedDtoServiceResponse implements IEntityDraftUpdatedDtoServiceResponse {
    /** Response DTO representing updated entity draft */
    data?: EntityDraftUpdatedDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IEntityDraftUpdatedDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityDraftUpdatedDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityDraftUpdatedDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDraftUpdatedDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntityDraftUpdatedDtoServiceResponse {
    /** Response DTO representing updated entity draft */
    data?: EntityDraftUpdatedDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Request DTO to create new entity Contains required parameters to define entity */
export class EntityDto implements IEntityDto {
    /** Entity type
One of Company, Individual, Other, Entity Group */
    type?: string | undefined;
    /** Id from external system to migrate data */
    alternateId?: string | undefined;
    /** Policy jurisdiction */
    policyJurisdiction?: string | undefined;
    /** List of policy jurisdictions e.g. ["Global", "Ireland"] */
    policyJurisdictions?: string[] | undefined;
    /** Target Entity type
One of Client, Related Party */
    targetEntity?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    category?: string[] | undefined;
    /** Entity properties. If the field does not exist inside defined policy then it will not be saved */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Entity access layers determining the access to the entity */
    accessLayers?: AccessLayerDto | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.alternateId = _data["alternateId"];
            this.policyJurisdiction = _data["policyJurisdiction"];
            if (Array.isArray(_data["policyJurisdictions"])) {
                this.policyJurisdictions = [] as any;
                for (let item of _data["policyJurisdictions"])
                    this.policyJurisdictions!.push(item);
            }
            this.targetEntity = _data["targetEntity"];
            if (Array.isArray(_data["category"])) {
                this.category = [] as any;
                for (let item of _data["category"])
                    this.category!.push(item);
            }
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["alternateId"] = this.alternateId;
        data["policyJurisdiction"] = this.policyJurisdiction;
        if (Array.isArray(this.policyJurisdictions)) {
            data["policyJurisdictions"] = [];
            for (let item of this.policyJurisdictions)
                data["policyJurisdictions"].push(item);
        }
        data["targetEntity"] = this.targetEntity;
        if (Array.isArray(this.category)) {
            data["category"] = [];
            for (let item of this.category)
                data["category"].push(item);
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        return data;
    }
}

/** Request DTO to create new entity Contains required parameters to define entity */
export interface IEntityDto {
    /** Entity type
One of Company, Individual, Other, Entity Group */
    type?: string | undefined;
    /** Id from external system to migrate data */
    alternateId?: string | undefined;
    /** Policy jurisdiction */
    policyJurisdiction?: string | undefined;
    /** List of policy jurisdictions e.g. ["Global", "Ireland"] */
    policyJurisdictions?: string[] | undefined;
    /** Target Entity type
One of Client, Related Party */
    targetEntity?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    category?: string[] | undefined;
    /** Entity properties. If the field does not exist inside defined policy then it will not be saved */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Entity access layers determining the access to the entity */
    accessLayers?: AccessLayerDto | undefined;
}

export class EntityDtoServiceRequest implements IEntityDtoServiceRequest {
    /** Request DTO to create new entity
Contains required parameters to define entity */
    data?: EntityDto | undefined;

    constructor(data?: IEntityDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEntityDtoServiceRequest {
    /** Request DTO to create new entity
Contains required parameters to define entity */
    data?: EntityDto | undefined;
}

/** Request DTO representing the entity risk data */
export class EntityRiskDto implements IEntityRiskDto {
    /** Risk level */
    riskLevel?: number | undefined;
    /** Risk category */
    riskCategory?: string | undefined;
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;

    constructor(data?: IEntityRiskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = -1;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.riskLevel = _data["riskLevel"];
            this.riskCategory = _data["riskCategory"];
            this.version = _data["version"] !== undefined ? _data["version"] : -1;
        }
    }

    static fromJS(data: any): EntityRiskDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityRiskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["riskLevel"] = this.riskLevel;
        data["riskCategory"] = this.riskCategory;
        data["version"] = this.version;
        return data;
    }
}

/** Request DTO representing the entity risk data */
export interface IEntityRiskDto {
    /** Risk level */
    riskLevel?: number | undefined;
    /** Risk category */
    riskCategory?: string | undefined;
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;
}

export class EntityRiskDtoServiceRequest implements IEntityRiskDtoServiceRequest {
    /** Request DTO representing the entity risk data */
    data?: EntityRiskDto | undefined;

    constructor(data?: IEntityRiskDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityRiskDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityRiskDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntityRiskDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEntityRiskDtoServiceRequest {
    /** Request DTO representing the entity risk data */
    data?: EntityRiskDto | undefined;
}

/** Request DTO representing the entity role data */
export class EntityRoleDto implements IEntityRoleDto {
    /** Role of the entity */
    name?: string | undefined;
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;

    constructor(data?: IEntityRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = -1;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.version = _data["version"] !== undefined ? _data["version"] : -1;
        }
    }

    static fromJS(data: any): EntityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["version"] = this.version;
        return data;
    }
}

/** Request DTO representing the entity role data */
export interface IEntityRoleDto {
    /** Role of the entity */
    name?: string | undefined;
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;
}

export class EntityRoleDtoServiceRequest implements IEntityRoleDtoServiceRequest {
    /** Request DTO representing the entity role data */
    data?: EntityRoleDto | undefined;

    constructor(data?: IEntityRoleDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EntityRoleDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityRoleDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntityRoleDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEntityRoleDtoServiceRequest {
    /** Request DTO representing the entity role data */
    data?: EntityRoleDto | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    readonly errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                (<any>this).errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>(<any>this).errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

/** Class to represent merge conflicts */
export class MergeConflictsDto implements IMergeConflictsDto {
    /** Current Entity version returned to frontend after resolving merge conflicts. */
    entityVersion?: number;
    /** Data conflicts. */
    dataConflicts?: { [key: string]: DataConflictDto; } | undefined;

    constructor(data?: IMergeConflictsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityVersion = _data["entityVersion"];
            if (_data["dataConflicts"]) {
                this.dataConflicts = {} as any;
                for (let key in _data["dataConflicts"]) {
                    if (_data["dataConflicts"].hasOwnProperty(key))
                        (<any>this.dataConflicts)![key] = _data["dataConflicts"][key] ? DataConflictDto.fromJS(_data["dataConflicts"][key]) : new DataConflictDto();
                }
            }
        }
    }

    static fromJS(data: any): MergeConflictsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MergeConflictsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityVersion"] = this.entityVersion;
        if (this.dataConflicts) {
            data["dataConflicts"] = {};
            for (let key in this.dataConflicts) {
                if (this.dataConflicts.hasOwnProperty(key))
                    (<any>data["dataConflicts"])[key] = this.dataConflicts[key] ? this.dataConflicts[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Class to represent merge conflicts */
export interface IMergeConflictsDto {
    /** Current Entity version returned to frontend after resolving merge conflicts. */
    entityVersion?: number;
    /** Data conflicts. */
    dataConflicts?: { [key: string]: DataConflictDto; } | undefined;
}

export class MergeConflictsDtoServiceResponse implements IMergeConflictsDtoServiceResponse {
    /** Class to represent merge conflicts */
    data?: MergeConflictsDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IMergeConflictsDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? MergeConflictsDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MergeConflictsDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MergeConflictsDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMergeConflictsDtoServiceResponse {
    /** Class to represent merge conflicts */
    data?: MergeConflictsDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ObjectServiceResponse implements IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export enum PropertyType {
    Single = "Single",
    Custom = "Custom",
    Collection = "Collection",
}

/** Request DTO representing the entity risk data */
export class RejectEntityDraftDto implements IRejectEntityDraftDto {
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;

    constructor(data?: IRejectEntityDraftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = -1;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"] !== undefined ? _data["version"] : -1;
        }
    }

    static fromJS(data: any): RejectEntityDraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new RejectEntityDraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        return data;
    }
}

/** Request DTO representing the entity risk data */
export interface IRejectEntityDraftDto {
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;
}

export class RejectEntityDraftDtoServiceRequest implements IRejectEntityDraftDtoServiceRequest {
    /** Request DTO representing the entity risk data */
    data?: RejectEntityDraftDto | undefined;

    constructor(data?: IRejectEntityDraftDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? RejectEntityDraftDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RejectEntityDraftDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RejectEntityDraftDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRejectEntityDraftDtoServiceRequest {
    /** Request DTO representing the entity risk data */
    data?: RejectEntityDraftDto | undefined;
}

/** Dto to store the risk configuration models and versions used in the Entity Draft */
export class RiskConfigurationVersionDto implements IRiskConfigurationVersionDto {
    /** The list of Risk Models and their versions used in the Entity Draft */
    riskModel?: RiskVersionDto[] | undefined;
    /** The list of Risk Configuration Models and their versions used in the Entity Draft */
    riskConfigurationModel?: RiskVersionDto[] | undefined;
    /** The list of Threshold Models and their versions used in the Entity Draft */
    thresholdModel?: RiskVersionDto[] | undefined;

    constructor(data?: IRiskConfigurationVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["riskModel"])) {
                this.riskModel = [] as any;
                for (let item of _data["riskModel"])
                    this.riskModel!.push(RiskVersionDto.fromJS(item));
            }
            if (Array.isArray(_data["riskConfigurationModel"])) {
                this.riskConfigurationModel = [] as any;
                for (let item of _data["riskConfigurationModel"])
                    this.riskConfigurationModel!.push(RiskVersionDto.fromJS(item));
            }
            if (Array.isArray(_data["thresholdModel"])) {
                this.thresholdModel = [] as any;
                for (let item of _data["thresholdModel"])
                    this.thresholdModel!.push(RiskVersionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RiskConfigurationVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RiskConfigurationVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.riskModel)) {
            data["riskModel"] = [];
            for (let item of this.riskModel)
                data["riskModel"].push(item.toJSON());
        }
        if (Array.isArray(this.riskConfigurationModel)) {
            data["riskConfigurationModel"] = [];
            for (let item of this.riskConfigurationModel)
                data["riskConfigurationModel"].push(item.toJSON());
        }
        if (Array.isArray(this.thresholdModel)) {
            data["thresholdModel"] = [];
            for (let item of this.thresholdModel)
                data["thresholdModel"].push(item.toJSON());
        }
        return data;
    }
}

/** Dto to store the risk configuration models and versions used in the Entity Draft */
export interface IRiskConfigurationVersionDto {
    /** The list of Risk Models and their versions used in the Entity Draft */
    riskModel?: RiskVersionDto[] | undefined;
    /** The list of Risk Configuration Models and their versions used in the Entity Draft */
    riskConfigurationModel?: RiskVersionDto[] | undefined;
    /** The list of Threshold Models and their versions used in the Entity Draft */
    thresholdModel?: RiskVersionDto[] | undefined;
}

/** Stores the Id and the Version of a Risk Configuration Model */
export class RiskVersionDto implements IRiskVersionDto {
    /** The Id of the risk model */
    id?: string;
    /** The version of the model */
    version?: number;

    constructor(data?: IRiskVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): RiskVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RiskVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        return data;
    }
}

/** Stores the Id and the Version of a Risk Configuration Model */
export interface IRiskVersionDto {
    /** The Id of the risk model */
    id?: string;
    /** The version of the model */
    version?: number;
}

export class ServiceResponse implements IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ServiceResponseMessage implements IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

export interface IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;
}

export class SinglePropertyDto extends PropertyDto implements ISinglePropertyDto {
    value?: string | undefined;

    constructor(data?: ISinglePropertyDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SinglePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SinglePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface ISinglePropertyDto extends IPropertyDto {
    value?: string | undefined;
}

/** Request DTO representing the entity draft access layers data */
export class UpdateDraftAccessLayersDto implements IUpdateDraftAccessLayersDto {
    /** Entity access layers determining the access to the entity draft and related entity */
    accessLayers?: AccessLayerDto | undefined;
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;

    constructor(data?: IUpdateDraftAccessLayersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = -1;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.version = _data["version"] !== undefined ? _data["version"] : -1;
        }
    }

    static fromJS(data: any): UpdateDraftAccessLayersDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDraftAccessLayersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

/** Request DTO representing the entity draft access layers data */
export interface IUpdateDraftAccessLayersDto {
    /** Entity access layers determining the access to the entity draft and related entity */
    accessLayers?: AccessLayerDto | undefined;
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;
}

export class UpdateDraftAccessLayersDtoServiceRequest implements IUpdateDraftAccessLayersDtoServiceRequest {
    /** Request DTO representing the entity draft access layers data */
    data?: UpdateDraftAccessLayersDto | undefined;

    constructor(data?: IUpdateDraftAccessLayersDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateDraftAccessLayersDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateDraftAccessLayersDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDraftAccessLayersDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateDraftAccessLayersDtoServiceRequest {
    /** Request DTO representing the entity draft access layers data */
    data?: UpdateDraftAccessLayersDto | undefined;
}

export class UpdateEntityDraftRequestV3Dto implements IUpdateEntityDraftRequestV3Dto {
    /** List of Risk Configurations associated with EntityDraft */
    riskVersions?: RiskConfigurationVersionDto | undefined;
    /** Collection of policy jurisdictions */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** The type of the entity */
    entityType?: string | undefined;
    /** Target Entity type (Client, Related Party) */
    targetEntity?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    category?: string[] | undefined;
    /** Entity draft properties */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;

    constructor(data?: IUpdateEntityDraftRequestV3Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = -1;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.riskVersions = _data["riskVersions"] ? RiskConfigurationVersionDto.fromJS(_data["riskVersions"]) : <any>undefined;
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(VersionedJurisdictionDto.fromJS(item));
            }
            this.entityType = _data["entityType"];
            this.targetEntity = _data["targetEntity"];
            if (Array.isArray(_data["category"])) {
                this.category = [] as any;
                for (let item of _data["category"])
                    this.category!.push(item);
            }
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
            this.version = _data["version"] !== undefined ? _data["version"] : -1;
        }
    }

    static fromJS(data: any): UpdateEntityDraftRequestV3Dto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEntityDraftRequestV3Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["riskVersions"] = this.riskVersions ? this.riskVersions.toJSON() : <any>undefined;
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item.toJSON());
        }
        data["entityType"] = this.entityType;
        data["targetEntity"] = this.targetEntity;
        if (Array.isArray(this.category)) {
            data["category"] = [];
            for (let item of this.category)
                data["category"].push(item);
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        data["version"] = this.version;
        return data;
    }
}

export interface IUpdateEntityDraftRequestV3Dto {
    /** List of Risk Configurations associated with EntityDraft */
    riskVersions?: RiskConfigurationVersionDto | undefined;
    /** Collection of policy jurisdictions */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** The type of the entity */
    entityType?: string | undefined;
    /** Target Entity type (Client, Related Party) */
    targetEntity?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    category?: string[] | undefined;
    /** Entity draft properties */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Current version of the Draft where you want to apply your changes. This parameter is required 
to guarantee consistency and conflicts detection. If it is not provided, it will save new changes
on top of latest without conflicts checking */
    version?: number;
}

export class UpdateEntityDraftRequestV3DtoServiceRequest implements IUpdateEntityDraftRequestV3DtoServiceRequest {
    data?: UpdateEntityDraftRequestV3Dto | undefined;

    constructor(data?: IUpdateEntityDraftRequestV3DtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateEntityDraftRequestV3Dto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateEntityDraftRequestV3DtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEntityDraftRequestV3DtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateEntityDraftRequestV3DtoServiceRequest {
    data?: UpdateEntityDraftRequestV3Dto | undefined;
}

/** Request DTO to update entity status */
export class UpdateEntityStatusDto implements IUpdateEntityStatusDto {
    /** Entity status */
    status?: string | undefined;

    constructor(data?: IUpdateEntityStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateEntityStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEntityStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

/** Request DTO to update entity status */
export interface IUpdateEntityStatusDto {
    /** Entity status */
    status?: string | undefined;
}

export class UpdateEntityStatusDtoServiceRequest implements IUpdateEntityStatusDtoServiceRequest {
    /** Request DTO to update entity status */
    data?: UpdateEntityStatusDto | undefined;

    constructor(data?: IUpdateEntityStatusDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateEntityStatusDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateEntityStatusDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEntityStatusDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateEntityStatusDtoServiceRequest {
    /** Request DTO to update entity status */
    data?: UpdateEntityStatusDto | undefined;
}

export class ValidationErrorModel implements IValidationErrorModel {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    errorCode?: string | undefined;

    constructor(data?: IValidationErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            this.attemptedValue = _data["attemptedValue"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ValidationErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

export interface IValidationErrorModel {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    errorCode?: string | undefined;
}

export class ValidationErrorModelListServiceResponse implements IValidationErrorModelListServiceResponse {
    data?: ValidationErrorModel[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IValidationErrorModelListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ValidationErrorModel.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationErrorModelListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModelListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IValidationErrorModelListServiceResponse {
    data?: ValidationErrorModel[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class VersionedJurisdictionDto implements IVersionedJurisdictionDto {
    /** Jurisdiction Name */
    jurisdiction!: string;
    /** Jurisdiction Version Id */
    versionId!: string;

    constructor(data?: IVersionedJurisdictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jurisdiction = _data["jurisdiction"];
            this.versionId = _data["versionId"];
        }
    }

    static fromJS(data: any): VersionedJurisdictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new VersionedJurisdictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jurisdiction"] = this.jurisdiction;
        data["versionId"] = this.versionId;
        return data;
    }
}

export interface IVersionedJurisdictionDto {
    /** Jurisdiction Name */
    jurisdiction: string;
    /** Jurisdiction Version Id */
    versionId: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}