//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * Get data groups
     * @param onlyPublishedAndArchived (optional) Flag that indicate that we will return only versions with status Published and Archived
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of data groups is returned
     */
    getAllDataGroups(onlyPublishedAndArchived: boolean | undefined, x_TENANT_ID: string): Promise<DataGroupDtoIEnumerableServiceResponse>;
    /**
     * Get latest data groups with published or archived status
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of data groups is returned
     */
    getLatestDataGroups(x_TENANT_ID: string): Promise<DataGroupVersionDtoListServiceResponse>;
    /**
     * Get data groups lite
     * @param onlyPublishedAndArchived (optional) Flag that indicate that we will return only versions with status Published and Archived
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of data groups is returned
     */
    getDataGroupsLite(onlyPublishedAndArchived: boolean | undefined, x_TENANT_ID: string): Promise<DataGroupLiteDtoIEnumerableServiceResponse>;
    /**
     * Get data group by id
     * @param dataGroupId Data group id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Data group is returned
     */
    getDataGroupById(dataGroupId: string, x_TENANT_ID: string): Promise<DataGroupVersionDtoServiceResponse>;
    /**
     * Get data group by id and version
     * @param dataGroupId Data group id
     * @param versionNumber Data group version number
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Data group is returned
     */
    getDataGroupVersionById(dataGroupId: string, versionNumber: number, x_TENANT_ID: string): Promise<DataGroupVersionDtoServiceResponse>;
    /**
     * Get data group field by id
     * @param dataGroupId Data group id
     * @param versionNumber Data group version number
     * @param id Data group field id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Data group field is returned
     */
    getDataGroupFieldById(dataGroupId: string, versionNumber: number, id: string, x_TENANT_ID: string): Promise<DataGroupFieldDtoServiceResponse>;
    /**
     * Get data groups by id and version numbers
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body List of Data Group data with versions
     * @return Success. Data group is returned
     */
    getDataGroups(x_TENANT_ID: string, body: GetDataGroupsRequestDtoServiceRequest): Promise<DataGroupDtoIEnumerableServiceResponse>;
    /**
     * Gets light version of requirenment sets based on entity requirenments
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) List of entity requirements with offboarded jurisdictions included
     * @return Success. List of light requirement sets data is returned
     */
    getRequirenmentSetsByIdsLight(x_TENANT_ID: string, body: GetRequirementSetsByIdsLightRequestDtoServiceRequest | undefined): Promise<RequirementSetLightDtoListServiceResponse>;
    /**
     * Get requirement sets
     * @param includeRequirements (optional) Flag to include requirements in the response.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. List of requirement sets data is returned
     */
    getAllRequirementSets(includeRequirements: boolean | undefined, x_TENANT_ID: string): Promise<RequirementSetDtoIEnumerableServiceResponse>;
    /**
     * Get requirement set by id
     * @param setId Requirement set id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Requirement set is returned
     */
    getRequirementSetById(setId: string, x_TENANT_ID: string): Promise<RequirementSetVersionDtoServiceResponse>;
    /**
     * Get requirement set by id and version
     * @param setId Requirement set id
     * @param versionNumber Requirement set version number
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Requirement set is returned
     */
    getRequirementSetVersionById(setId: string, versionNumber: number, x_TENANT_ID: string): Promise<RequirementSetVersionDtoServiceResponse>;
    /**
     * Get requirement by id
     * @param setId Requirement set id
     * @param versionNumber Requirement set version number
     * @param id Requirement id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Requirement is returned
     */
    getRequirementById(setId: string, versionNumber: number, id: string, x_TENANT_ID: string): Promise<RequirementServiceResponse>;
    /**
     * Get requirements in scope
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Requirements in scope request with a set of criteria to search
     * @return Success. List of requirements is returned
     */
    getRequirementsInScopeV2(x_TENANT_ID: string, body: RequirementsInScopeRequestV2DtoServiceRequest | undefined): Promise<RequirementListServiceResponse>;
    /**
     * Search requirements
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Requirements in scope request with a set of criteria to search
     * @return Success. List of requirements is returned
     */
    searchRequirements(x_TENANT_ID: string, body: SearchRequirementsDtoServiceRequest | undefined): Promise<RequirementListServiceResponse>;
    /**
     * Evaluate requirements in scope
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Evaluate requirements in scope request with a set of criteria to search requirements and evaluate conditions
     * @return Success. List of requirements is returned
     */
    evaluateRequirementsInScope(x_TENANT_ID: string, body: EvaluateRequirementsInScopeRequestDtoServiceRequest | undefined): Promise<RequirementListServiceResponse>;
    /**
     * Get validation data by jurisdiction(s)
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Get validation data request.
     * @return Success. The list of validation data is returned
     */
    getValidationRules(x_TENANT_ID: string, body: GetValidationRulesRequestDtoServiceRequest | undefined): Promise<ValidationRuleListServiceResponse>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/policyquery";

    }

    /**
     * Get data groups
     * @param onlyPublishedAndArchived (optional) Flag that indicate that we will return only versions with status Published and Archived
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of data groups is returned
     */
    getAllDataGroups(onlyPublishedAndArchived: boolean | undefined, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DataGroupDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/data-group?";
        if (onlyPublishedAndArchived === null)
            throw new Error("The parameter 'onlyPublishedAndArchived' cannot be null.");
        else if (onlyPublishedAndArchived !== undefined)
            url_ += "onlyPublishedAndArchived=" + encodeURIComponent("" + onlyPublishedAndArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllDataGroups(_response);
        });
    }

    protected processGetAllDataGroups(response: AxiosResponse): Promise<DataGroupDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataGroupDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<DataGroupDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataGroupDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get latest data groups with published or archived status
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of data groups is returned
     */
    getLatestDataGroups(x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DataGroupVersionDtoListServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/data-group/latest";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLatestDataGroups(_response);
        });
    }

    protected processGetLatestDataGroups(response: AxiosResponse): Promise<DataGroupVersionDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataGroupVersionDtoListServiceResponse.fromJS(resultData200);
            return Promise.resolve<DataGroupVersionDtoListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataGroupVersionDtoListServiceResponse>(null as any);
    }

    /**
     * Get data groups lite
     * @param onlyPublishedAndArchived (optional) Flag that indicate that we will return only versions with status Published and Archived
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. The list of data groups is returned
     */
    getDataGroupsLite(onlyPublishedAndArchived: boolean | undefined, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DataGroupLiteDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/data-group/lite?";
        if (onlyPublishedAndArchived === null)
            throw new Error("The parameter 'onlyPublishedAndArchived' cannot be null.");
        else if (onlyPublishedAndArchived !== undefined)
            url_ += "onlyPublishedAndArchived=" + encodeURIComponent("" + onlyPublishedAndArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataGroupsLite(_response);
        });
    }

    protected processGetDataGroupsLite(response: AxiosResponse): Promise<DataGroupLiteDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataGroupLiteDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<DataGroupLiteDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataGroupLiteDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get data group by id
     * @param dataGroupId Data group id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Data group is returned
     */
    getDataGroupById(dataGroupId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DataGroupVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/data-group/{dataGroupId}";
        if (dataGroupId === undefined || dataGroupId === null)
            throw new Error("The parameter 'dataGroupId' must be defined.");
        url_ = url_.replace("{dataGroupId}", encodeURIComponent("" + dataGroupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataGroupById(_response);
        });
    }

    protected processGetDataGroupById(response: AxiosResponse): Promise<DataGroupVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataGroupVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<DataGroupVersionDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataGroupVersionDtoServiceResponse>(null as any);
    }

    /**
     * Get data group by id and version
     * @param dataGroupId Data group id
     * @param versionNumber Data group version number
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Data group is returned
     */
    getDataGroupVersionById(dataGroupId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DataGroupVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/data-group/{dataGroupId}/version/{versionNumber}";
        if (dataGroupId === undefined || dataGroupId === null)
            throw new Error("The parameter 'dataGroupId' must be defined.");
        url_ = url_.replace("{dataGroupId}", encodeURIComponent("" + dataGroupId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataGroupVersionById(_response);
        });
    }

    protected processGetDataGroupVersionById(response: AxiosResponse): Promise<DataGroupVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataGroupVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<DataGroupVersionDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataGroupVersionDtoServiceResponse>(null as any);
    }

    /**
     * Get data group field by id
     * @param dataGroupId Data group id
     * @param versionNumber Data group version number
     * @param id Data group field id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Data group field is returned
     */
    getDataGroupFieldById(dataGroupId: string, versionNumber: number, id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<DataGroupFieldDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/data-group/{dataGroupId}/version/{versionNumber}/field/{id}";
        if (dataGroupId === undefined || dataGroupId === null)
            throw new Error("The parameter 'dataGroupId' must be defined.");
        url_ = url_.replace("{dataGroupId}", encodeURIComponent("" + dataGroupId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataGroupFieldById(_response);
        });
    }

    protected processGetDataGroupFieldById(response: AxiosResponse): Promise<DataGroupFieldDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataGroupFieldDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<DataGroupFieldDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataGroupFieldDtoServiceResponse>(null as any);
    }

    /**
     * Get data groups by id and version numbers
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body List of Data Group data with versions
     * @return Success. Data group is returned
     */
    getDataGroups(x_TENANT_ID: string, body: GetDataGroupsRequestDtoServiceRequest , cancelToken?: CancelToken | undefined): Promise<DataGroupDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/data-group/versions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataGroups(_response);
        });
    }

    protected processGetDataGroups(response: AxiosResponse): Promise<DataGroupDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataGroupDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<DataGroupDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataGroupDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Gets light version of requirenment sets based on entity requirenments
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) List of entity requirements with offboarded jurisdictions included
     * @return Success. List of light requirement sets data is returned
     */
    getRequirenmentSetsByIdsLight(x_TENANT_ID: string, body: GetRequirementSetsByIdsLightRequestDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<RequirementSetLightDtoListServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/requirement-set/light";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRequirenmentSetsByIdsLight(_response);
        });
    }

    protected processGetRequirenmentSetsByIdsLight(response: AxiosResponse): Promise<RequirementSetLightDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequirementSetLightDtoListServiceResponse.fromJS(resultData200);
            return Promise.resolve<RequirementSetLightDtoListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequirementSetLightDtoListServiceResponse>(null as any);
    }

    /**
     * Get requirement sets
     * @param includeRequirements (optional) Flag to include requirements in the response.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. List of requirement sets data is returned
     */
    getAllRequirementSets(includeRequirements: boolean | undefined, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<RequirementSetDtoIEnumerableServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/requirement-set?";
        if (includeRequirements === null)
            throw new Error("The parameter 'includeRequirements' cannot be null.");
        else if (includeRequirements !== undefined)
            url_ += "includeRequirements=" + encodeURIComponent("" + includeRequirements) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRequirementSets(_response);
        });
    }

    protected processGetAllRequirementSets(response: AxiosResponse): Promise<RequirementSetDtoIEnumerableServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequirementSetDtoIEnumerableServiceResponse.fromJS(resultData200);
            return Promise.resolve<RequirementSetDtoIEnumerableServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequirementSetDtoIEnumerableServiceResponse>(null as any);
    }

    /**
     * Get requirement set by id
     * @param setId Requirement set id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Requirement set is returned
     */
    getRequirementSetById(setId: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<RequirementSetVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/requirement-set/{setId}";
        if (setId === undefined || setId === null)
            throw new Error("The parameter 'setId' must be defined.");
        url_ = url_.replace("{setId}", encodeURIComponent("" + setId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRequirementSetById(_response);
        });
    }

    protected processGetRequirementSetById(response: AxiosResponse): Promise<RequirementSetVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequirementSetVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<RequirementSetVersionDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequirementSetVersionDtoServiceResponse>(null as any);
    }

    /**
     * Get requirement set by id and version
     * @param setId Requirement set id
     * @param versionNumber Requirement set version number
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Requirement set is returned
     */
    getRequirementSetVersionById(setId: string, versionNumber: number, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<RequirementSetVersionDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/requirement-set/{setId}/version/{versionNumber}";
        if (setId === undefined || setId === null)
            throw new Error("The parameter 'setId' must be defined.");
        url_ = url_.replace("{setId}", encodeURIComponent("" + setId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRequirementSetVersionById(_response);
        });
    }

    protected processGetRequirementSetVersionById(response: AxiosResponse): Promise<RequirementSetVersionDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequirementSetVersionDtoServiceResponse.fromJS(resultData200);
            return Promise.resolve<RequirementSetVersionDtoServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequirementSetVersionDtoServiceResponse>(null as any);
    }

    /**
     * Get requirement by id
     * @param setId Requirement set id
     * @param versionNumber Requirement set version number
     * @param id Requirement id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Requirement is returned
     */
    getRequirementById(setId: string, versionNumber: number, id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<RequirementServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/requirement-set/{setId}/version/{versionNumber}/field/{id}";
        if (setId === undefined || setId === null)
            throw new Error("The parameter 'setId' must be defined.");
        url_ = url_.replace("{setId}", encodeURIComponent("" + setId));
        if (versionNumber === undefined || versionNumber === null)
            throw new Error("The parameter 'versionNumber' must be defined.");
        url_ = url_.replace("{versionNumber}", encodeURIComponent("" + versionNumber));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRequirementById(_response);
        });
    }

    protected processGetRequirementById(response: AxiosResponse): Promise<RequirementServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequirementServiceResponse.fromJS(resultData200);
            return Promise.resolve<RequirementServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequirementServiceResponse>(null as any);
    }

    /**
     * Get requirements in scope
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Requirements in scope request with a set of criteria to search
     * @return Success. List of requirements is returned
     */
    getRequirementsInScopeV2(x_TENANT_ID: string, body: RequirementsInScopeRequestV2DtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<RequirementListServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/requirements-in-scope";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRequirementsInScopeV2(_response);
        });
    }

    protected processGetRequirementsInScopeV2(response: AxiosResponse): Promise<RequirementListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequirementListServiceResponse.fromJS(resultData200);
            return Promise.resolve<RequirementListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequirementListServiceResponse>(null as any);
    }

    /**
     * Search requirements
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Requirements in scope request with a set of criteria to search
     * @return Success. List of requirements is returned
     */
    searchRequirements(x_TENANT_ID: string, body: SearchRequirementsDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<RequirementListServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/requirements-in-scope/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchRequirements(_response);
        });
    }

    protected processSearchRequirements(response: AxiosResponse): Promise<RequirementListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequirementListServiceResponse.fromJS(resultData200);
            return Promise.resolve<RequirementListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequirementListServiceResponse>(null as any);
    }

    /**
     * Evaluate requirements in scope
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Evaluate requirements in scope request with a set of criteria to search requirements and evaluate conditions
     * @return Success. List of requirements is returned
     */
    evaluateRequirementsInScope(x_TENANT_ID: string, body: EvaluateRequirementsInScopeRequestDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<RequirementListServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/requirements-in-scope/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEvaluateRequirementsInScope(_response);
        });
    }

    protected processEvaluateRequirementsInScope(response: AxiosResponse): Promise<RequirementListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequirementListServiceResponse.fromJS(resultData200);
            return Promise.resolve<RequirementListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequirementListServiceResponse>(null as any);
    }

    /**
     * Get validation data by jurisdiction(s)
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Get validation data request.
     * @return Success. The list of validation data is returned
     */
    getValidationRules(x_TENANT_ID: string, body: GetValidationRulesRequestDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<ValidationRuleListServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/validation-rule/validation-rules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidationRules(_response);
        });
    }

    protected processGetValidationRules(response: AxiosResponse): Promise<ValidationRuleListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ValidationRuleListServiceResponse.fromJS(resultData200);
            return Promise.resolve<ValidationRuleListServiceResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ValidationRuleListServiceResponse>(null as any);
    }
}

export class AccessLayer implements IAccessLayer {
    businessRelated?: string[] | undefined;
    geographic?: string[] | undefined;

    constructor(data?: IAccessLayer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["businessRelated"])) {
                this.businessRelated = [] as any;
                for (let item of _data["businessRelated"])
                    this.businessRelated!.push(item);
            }
            if (Array.isArray(_data["geographic"])) {
                this.geographic = [] as any;
                for (let item of _data["geographic"])
                    this.geographic!.push(item);
            }
        }
    }

    static fromJS(data: any): AccessLayer {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.businessRelated)) {
            data["businessRelated"] = [];
            for (let item of this.businessRelated)
                data["businessRelated"].push(item);
        }
        if (Array.isArray(this.geographic)) {
            data["geographic"] = [];
            for (let item of this.geographic)
                data["geographic"].push(item);
        }
        return data;
    }
}

export interface IAccessLayer {
    businessRelated?: string[] | undefined;
    geographic?: string[] | undefined;
}

export class ApproveAction implements IApproveAction {
    comment?: string | undefined;
    decision?: Decision;
    created?: Date;

    constructor(data?: IApproveAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
            this.decision = _data["decision"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApproveAction {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["decision"] = this.decision;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IApproveAction {
    comment?: string | undefined;
    decision?: Decision;
    created?: Date;
}

export class Approver implements IApprover {
    subject?: string | undefined;
    successor?: Approver | undefined;
    action?: ApproveAction | undefined;
    readonly hasProcessedRequest?: boolean;

    constructor(data?: IApprover) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.successor = _data["successor"] ? Approver.fromJS(_data["successor"]) : <any>undefined;
            this.action = _data["action"] ? ApproveAction.fromJS(_data["action"]) : <any>undefined;
            (<any>this).hasProcessedRequest = _data["hasProcessedRequest"];
        }
    }

    static fromJS(data: any): Approver {
        data = typeof data === 'object' ? data : {};
        let result = new Approver();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["successor"] = this.successor ? this.successor.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["hasProcessedRequest"] = this.hasProcessedRequest;
        return data;
    }
}

export interface IApprover {
    subject?: string | undefined;
    successor?: Approver | undefined;
    action?: ApproveAction | undefined;
    hasProcessedRequest?: boolean;
}

export class BasicRule implements IBasicRule {
    active?: boolean;
    message?: string | undefined;

    constructor(data?: IBasicRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): BasicRule {
        data = typeof data === 'object' ? data : {};
        let result = new BasicRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        return data;
    }
}

export interface IBasicRule {
    active?: boolean;
    message?: string | undefined;
}

export class CollectionDto implements ICollectionDto {
    isValid?: boolean;
    properties?: { [key: string]: string; } | undefined;

    constructor(data?: ICollectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface ICollectionDto {
    isValid?: boolean;
    properties?: { [key: string]: string; } | undefined;
}

export class CollectionMaximumCountRule implements ICollectionMaximumCountRule {
    active?: boolean;
    message?: string | undefined;
    requiredTypesMaxCount?: { [key: string]: number; } | undefined;
    overallMaximumCount?: number | undefined;

    constructor(data?: ICollectionMaximumCountRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            if (_data["requiredTypesMaxCount"]) {
                this.requiredTypesMaxCount = {} as any;
                for (let key in _data["requiredTypesMaxCount"]) {
                    if (_data["requiredTypesMaxCount"].hasOwnProperty(key))
                        (<any>this.requiredTypesMaxCount)![key] = _data["requiredTypesMaxCount"][key];
                }
            }
            this.overallMaximumCount = _data["overallMaximumCount"];
        }
    }

    static fromJS(data: any): CollectionMaximumCountRule {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionMaximumCountRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        if (this.requiredTypesMaxCount) {
            data["requiredTypesMaxCount"] = {};
            for (let key in this.requiredTypesMaxCount) {
                if (this.requiredTypesMaxCount.hasOwnProperty(key))
                    (<any>data["requiredTypesMaxCount"])[key] = (<any>this.requiredTypesMaxCount)[key];
            }
        }
        data["overallMaximumCount"] = this.overallMaximumCount;
        return data;
    }
}

export interface ICollectionMaximumCountRule {
    active?: boolean;
    message?: string | undefined;
    requiredTypesMaxCount?: { [key: string]: number; } | undefined;
    overallMaximumCount?: number | undefined;
}

export class CollectionMinimumCountRule implements ICollectionMinimumCountRule {
    active?: boolean;
    message?: string | undefined;
    requiredTypesMinCount?: { [key: string]: number; } | undefined;
    overallMinimumCount?: number;

    constructor(data?: ICollectionMinimumCountRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            if (_data["requiredTypesMinCount"]) {
                this.requiredTypesMinCount = {} as any;
                for (let key in _data["requiredTypesMinCount"]) {
                    if (_data["requiredTypesMinCount"].hasOwnProperty(key))
                        (<any>this.requiredTypesMinCount)![key] = _data["requiredTypesMinCount"][key];
                }
            }
            this.overallMinimumCount = _data["overallMinimumCount"];
        }
    }

    static fromJS(data: any): CollectionMinimumCountRule {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionMinimumCountRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        if (this.requiredTypesMinCount) {
            data["requiredTypesMinCount"] = {};
            for (let key in this.requiredTypesMinCount) {
                if (this.requiredTypesMinCount.hasOwnProperty(key))
                    (<any>data["requiredTypesMinCount"])[key] = (<any>this.requiredTypesMinCount)[key];
            }
        }
        data["overallMinimumCount"] = this.overallMinimumCount;
        return data;
    }
}

export interface ICollectionMinimumCountRule {
    active?: boolean;
    message?: string | undefined;
    requiredTypesMinCount?: { [key: string]: number; } | undefined;
    overallMinimumCount?: number;
}

export class PropertyDto implements IPropertyDto {
    isValid?: boolean | undefined;

    protected _discriminator: string;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "PropertyDto";
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "Collection") {
            let result = new CollectionPropertyDto();
            result.init(data);
            return result;
        }
        if (data["type"] === "Custom") {
            let result = new CustomPropertyDto();
            result.init(data);
            return result;
        }
        if (data["type"] === "Single") {
            let result = new SinglePropertyDto();
            result.init(data);
            return result;
        }
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator;
        data["isValid"] = this.isValid;
        return data;
    }
}

export interface IPropertyDto {
    isValid?: boolean | undefined;
}

export class CollectionPropertyDto extends PropertyDto implements ICollectionPropertyDto {
    dataGroupId?: string;
    dataGroupVersionNumber?: number | undefined;
    collections?: { [key: string]: CollectionDto; } | undefined;

    constructor(data?: ICollectionPropertyDto) {
        super(data);
        this._discriminator = "Collection";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dataGroupId = _data["dataGroupId"];
            this.dataGroupVersionNumber = _data["dataGroupVersionNumber"];
            if (_data["collections"]) {
                this.collections = {} as any;
                for (let key in _data["collections"]) {
                    if (_data["collections"].hasOwnProperty(key))
                        (<any>this.collections)![key] = _data["collections"][key] ? CollectionDto.fromJS(_data["collections"][key]) : new CollectionDto();
                }
            }
        }
    }

    static fromJS(data: any): CollectionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataGroupId"] = this.dataGroupId;
        data["dataGroupVersionNumber"] = this.dataGroupVersionNumber;
        if (this.collections) {
            data["collections"] = {};
            for (let key in this.collections) {
                if (this.collections.hasOwnProperty(key))
                    (<any>data["collections"])[key] = this.collections[key] ? this.collections[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICollectionPropertyDto extends IPropertyDto {
    dataGroupId?: string;
    dataGroupVersionNumber?: number | undefined;
    collections?: { [key: string]: CollectionDto; } | undefined;
}

export class Condition implements ICondition {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;

    constructor(data?: ICondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Condition {
        data = typeof data === 'object' ? data : {};
        let result = new Condition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICondition {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
}

export class ConditionDefinition implements IConditionDefinition {
    fieldName?: string | undefined;
    value?: string[] | undefined;
    valueType?: string | undefined;
    dataSource?: string | undefined;
    operation?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
    readonly isCondition?: boolean;

    constructor(data?: IConditionDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.valueType = _data["valueType"];
            this.dataSource = _data["dataSource"];
            this.operation = _data["operation"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinition.fromJS(item));
            }
            (<any>this).isCondition = _data["isCondition"];
        }
    }

    static fromJS(data: any): ConditionDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["valueType"] = this.valueType;
        data["dataSource"] = this.dataSource;
        data["operation"] = this.operation;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        data["isCondition"] = this.isCondition;
        return data;
    }
}

export interface IConditionDefinition {
    fieldName?: string | undefined;
    value?: string[] | undefined;
    valueType?: string | undefined;
    dataSource?: string | undefined;
    operation?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
    isCondition?: boolean;
}

/** Represents condition */
export class ConditionDefinitionDto implements IConditionDefinitionDto {
    /** Name of the field to evaluate */
    fieldName?: string | undefined;
    /** List of values */
    value?: string[] | undefined;
    /** Type of the value */
    valueType?: string | undefined;
    /** Data source from which field is retrieved. If empty then Entity Data properties will be used. */
    dataSource?: string | undefined;
    /** Logical operation to be performed to match the values */
    operation?: string | undefined;
    /** Logical operation to be performed on the operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;

    constructor(data?: IConditionDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.valueType = _data["valueType"];
            this.dataSource = _data["dataSource"];
            this.operation = _data["operation"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["valueType"] = this.valueType;
        data["dataSource"] = this.dataSource;
        data["operation"] = this.operation;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents condition */
export interface IConditionDefinitionDto {
    /** Name of the field to evaluate */
    fieldName?: string | undefined;
    /** List of values */
    value?: string[] | undefined;
    /** Type of the value */
    valueType?: string | undefined;
    /** Data source from which field is retrieved. If empty then Entity Data properties will be used. */
    dataSource?: string | undefined;
    /** Logical operation to be performed to match the values */
    operation?: string | undefined;
    /** Logical operation to be performed on the operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;
}

/** Represents condition root */
export class ConditionDto implements IConditionDto {
    /** The ID of the condition */
    id?: string;
    /** The name of the condition */
    name?: string | undefined;
    /** The description of the condition */
    description?: string | undefined;
    /** Logical operation on the Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDto.Operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;

    constructor(data?: IConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents condition root */
export interface IConditionDto {
    /** The ID of the condition */
    id?: string;
    /** The name of the condition */
    name?: string | undefined;
    /** The description of the condition */
    description?: string | undefined;
    /** Logical operation on the Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDto.Operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;
}

export class ConditionalValue implements IConditionalValue {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
    value?: string | undefined;
    priority?: number;

    constructor(data?: IConditionalValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinition.fromJS(item));
            }
            this.value = _data["value"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): ConditionalValue {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionalValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        data["value"] = this.value;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IConditionalValue {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    logicalOperation?: string | undefined;
    operands?: ConditionDefinition[] | undefined;
    value?: string | undefined;
    priority?: number;
}

export class ConditionalValueDto implements IConditionalValueDto {
    /** The ID of the condition */
    id?: string;
    /** The name of the condition */
    name?: string | undefined;
    /** The description of the condition */
    description?: string | undefined;
    /** Logical operation on the Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDto.Operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;
    /** Value that should be returned when conditions are met */
    value?: string | undefined;
    /** Priority of the value in case when multiple conditional values are evaluated */
    priority?: number;

    constructor(data?: IConditionalValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.logicalOperation = _data["logicalOperation"];
            if (Array.isArray(_data["operands"])) {
                this.operands = [] as any;
                for (let item of _data["operands"])
                    this.operands!.push(ConditionDefinitionDto.fromJS(item));
            }
            this.value = _data["value"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): ConditionalValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionalValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["logicalOperation"] = this.logicalOperation;
        if (Array.isArray(this.operands)) {
            data["operands"] = [];
            for (let item of this.operands)
                data["operands"].push(item.toJSON());
        }
        data["value"] = this.value;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IConditionalValueDto {
    /** The ID of the condition */
    id?: string;
    /** The name of the condition */
    name?: string | undefined;
    /** The description of the condition */
    description?: string | undefined;
    /** Logical operation on the Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDto.Operands collection */
    logicalOperation?: string | undefined;
    /** Collection of operands for given condition. These might contain additional, nested conditions of type Fenergo.Nebula.Platform.LogicEngine.Model.Dto.ConditionDefinitionDto */
    operands?: ConditionDefinitionDto[] | undefined;
    /** Value that should be returned when conditions are met */
    value?: string | undefined;
    /** Priority of the value in case when multiple conditional values are evaluated */
    priority?: number;
}

export class CustomPropertyDto extends PropertyDto implements ICustomPropertyDto {
    customTypeId?: string;
    properties?: { [key: string]: PropertyDto; } | undefined;

    constructor(data?: ICustomPropertyDto) {
        super(data);
        this._discriminator = "Custom";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customTypeId = _data["customTypeId"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): CustomPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTypeId"] = this.customTypeId;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICustomPropertyDto extends IPropertyDto {
    customTypeId?: string;
    properties?: { [key: string]: PropertyDto; } | undefined;
}

export class DataField implements IDataField {
    propertyName?: string | undefined;
    propertyType?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVersion?: number | undefined;
    linkChildFieldPropertyName?: string | undefined;

    constructor(data?: IDataField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.propertyType = _data["propertyType"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.propertyTypeVersion = _data["propertyTypeVersion"];
            this.linkChildFieldPropertyName = _data["linkChildFieldPropertyName"];
        }
    }

    static fromJS(data: any): DataField {
        data = typeof data === 'object' ? data : {};
        let result = new DataField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["propertyType"] = this.propertyType;
        data["propertyTypeId"] = this.propertyTypeId;
        data["propertyTypeVersion"] = this.propertyTypeVersion;
        data["linkChildFieldPropertyName"] = this.linkChildFieldPropertyName;
        return data;
    }
}

export interface IDataField {
    propertyName?: string | undefined;
    propertyType?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVersion?: number | undefined;
    linkChildFieldPropertyName?: string | undefined;
}

/** Response DTO representing data field data */
export class DataFieldDto implements IDataFieldDto {
    /** Property name */
    propertyName?: string | undefined;
    /** Property type */
    propertyType?: string | undefined;
    /** Property type id */
    propertyTypeId?: string | undefined;
    /** Linked child field property name */
    linkChildFieldPropertyName?: string | undefined;

    constructor(data?: IDataFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.propertyType = _data["propertyType"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.linkChildFieldPropertyName = _data["linkChildFieldPropertyName"];
        }
    }

    static fromJS(data: any): DataFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["propertyType"] = this.propertyType;
        data["propertyTypeId"] = this.propertyTypeId;
        data["linkChildFieldPropertyName"] = this.linkChildFieldPropertyName;
        return data;
    }
}

/** Response DTO representing data field data */
export interface IDataFieldDto {
    /** Property name */
    propertyName?: string | undefined;
    /** Property type */
    propertyType?: string | undefined;
    /** Property type id */
    propertyTypeId?: string | undefined;
    /** Linked child field property name */
    linkChildFieldPropertyName?: string | undefined;
}

/** Response DTO representing data group data */
export class DataGroupDto implements IDataGroupDto {
    /** The UiD of the data group */
    id?: string;
    /** Versions associated to this data group */
    versions?: DataGroupVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;

    constructor(data?: IDataGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(DataGroupVersionDto.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): DataGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing data group data */
export interface IDataGroupDto {
    /** The UiD of the data group */
    id?: string;
    /** Versions associated to this data group */
    versions?: DataGroupVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
}

/** Service response data */
export class DataGroupDtoIEnumerableServiceResponse implements IDataGroupDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: DataGroupDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDataGroupDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DataGroupDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataGroupDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IDataGroupDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: DataGroupDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class Requirement implements IRequirement {
    version?: number;
    isLocked?: boolean;
    rootVersionId?: string;
    versionNumber?: number;
    id?: string;
    tenant?: string | undefined;
    category?: string | undefined;
    description?: string | undefined;
    template?: string | undefined;
    entityType?: string | undefined;
    name?: string | undefined;
    isSensitiveData?: boolean;
    isMaterialData?: boolean;
    isCoreDefinition?: boolean;
    jurisdiction?: string | undefined;
    dataProtectionJurisdiction?: string | undefined;
    references?: Reference[] | undefined;
    targetEntity?: string | undefined;
    classification?: string | undefined;
    type?: string | undefined;
    conditions?: Condition[] | undefined;
    requirementSetId?: string;
    hasEvaluatedConditionalValue?: boolean;
    evaluatedConditionalValue?: string;

    protected _discriminator: string;

    constructor(data?: IRequirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Requirement";
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.isLocked = _data["isLocked"];
            this.rootVersionId = _data["rootVersionId"];
            this.versionNumber = _data["versionNumber"];
            this.id = _data["id"];
            this.tenant = _data["tenant"];
            this.category = _data["category"];
            this.description = _data["description"];
            this.template = _data["template"];
            this.entityType = _data["entityType"];
            this.name = _data["name"];
            this.isSensitiveData = _data["isSensitiveData"];
            this.isMaterialData = _data["isMaterialData"];
            this.isCoreDefinition = _data["isCoreDefinition"];
            this.jurisdiction = _data["jurisdiction"];
            this.dataProtectionJurisdiction = _data["dataProtectionJurisdiction"];
            if (Array.isArray(_data["references"])) {
                this.references = [] as any;
                for (let item of _data["references"])
                    this.references!.push(Reference.fromJS(item));
            }
            this.targetEntity = _data["targetEntity"];
            this.classification = _data["classification"];
            this.type = _data["type"];
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(Condition.fromJS(item));
            }
            this.requirementSetId = _data["RequirementSetId"];
            this.hasEvaluatedConditionalValue = _data["hasEvaluatedConditionalValue"];
            this.evaluatedConditionalValue = _data["evaluatedConditionalValue"];
        }
    }

    static fromJS(data: any): Requirement {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "Data") {
            let result = new DataRequirement();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "Document") {
            let result = new DocumentRequirement();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "eSignatureDocument") {
            let result = new ESignatureDocumentRequirement();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "OwnershipAndControl") {
            let result = new OwnershipAndControlRequirement();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DataGroup") {
            let result = new DataGroupField();
            result.init(data);
            return result;
        }
        let result = new Requirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["version"] = this.version;
        data["isLocked"] = this.isLocked;
        data["rootVersionId"] = this.rootVersionId;
        data["versionNumber"] = this.versionNumber;
        data["id"] = this.id;
        data["tenant"] = this.tenant;
        data["category"] = this.category;
        data["description"] = this.description;
        data["template"] = this.template;
        data["entityType"] = this.entityType;
        data["name"] = this.name;
        data["isSensitiveData"] = this.isSensitiveData;
        data["isMaterialData"] = this.isMaterialData;
        data["isCoreDefinition"] = this.isCoreDefinition;
        data["jurisdiction"] = this.jurisdiction;
        data["dataProtectionJurisdiction"] = this.dataProtectionJurisdiction;
        if (Array.isArray(this.references)) {
            data["references"] = [];
            for (let item of this.references)
                data["references"].push(item.toJSON());
        }
        data["targetEntity"] = this.targetEntity;
        data["classification"] = this.classification;
        data["type"] = this.type;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["RequirementSetId"] = this.requirementSetId;
        return data;
    }
}

export interface IRequirement {
    version?: number;
    isLocked?: boolean;
    rootVersionId?: string;
    versionNumber?: number;
    id?: string;
    tenant?: string | undefined;
    category?: string | undefined;
    description?: string | undefined;
    template?: string | undefined;
    entityType?: string | undefined;
    name?: string | undefined;
    isSensitiveData?: boolean;
    isMaterialData?: boolean;
    isCoreDefinition?: boolean;
    jurisdiction?: string | undefined;
    dataProtectionJurisdiction?: string | undefined;
    references?: Reference[] | undefined;
    targetEntity?: string | undefined;
    classification?: string | undefined;
    type?: string | undefined;
    conditions?: Condition[] | undefined;
    requirementSetId?: string;
}

export class DataGroupField extends Requirement implements IDataGroupField {
    versionId?: string;
    dataField?: DataField | undefined;
    order?: number | undefined;
    validationRule?: ValidationRule | undefined;
    defaultValue?: string | undefined;
    isReadOnly?: boolean;
    conditionalValues?: ConditionalValue[] | undefined;

    constructor(data?: IDataGroupField) {
        super(data);
        this._discriminator = "DataGroup";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.versionId = _data["versionId"];
            this.dataField = _data["dataField"] ? DataField.fromJS(_data["dataField"]) : <any>undefined;
            this.order = _data["order"];
            this.validationRule = _data["validationRule"] ? ValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
            this.defaultValue = _data["defaultValue"];
            this.isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["conditionalValues"])) {
                this.conditionalValues = [] as any;
                for (let item of _data["conditionalValues"])
                    this.conditionalValues!.push(ConditionalValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataGroupField {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["versionId"] = this.versionId;
        data["dataField"] = this.dataField ? this.dataField.toJSON() : <any>undefined;
        data["order"] = this.order;
        data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
        data["defaultValue"] = this.defaultValue;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.conditionalValues)) {
            data["conditionalValues"] = [];
            for (let item of this.conditionalValues)
                data["conditionalValues"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDataGroupField extends IRequirement {
    versionId?: string;
    dataField?: DataField | undefined;
    order?: number | undefined;
    validationRule?: ValidationRule | undefined;
    defaultValue?: string | undefined;
    isReadOnly?: boolean;
    conditionalValues?: ConditionalValue[] | undefined;
}

/** Response DTO representing data group field data */
export class DataGroupFieldDto implements IDataGroupFieldDto {
    /** The UiD of the data group field */
    identifier?: string;
    /** Data group field name */
    name?: string | undefined;
    /** Data group field type */
    type?: string | undefined;
    /** Data group field order */
    order?: number | undefined;
    /** Data group field data field */
    dataField?: DataFieldDto | undefined;
    /** Data group field sensitive data flag */
    isSensitiveData?: boolean;
    /** Data group field core definition flag */
    isCoreDefinition?: boolean;
    /** Data group field validation data */
    validationRule?: ValidationRule | undefined;
    /** Data group field conditions list */
    conditions?: ConditionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
    /** Default value for this data field */
    defaultValue?: string | undefined;
    /** Is requirement readonly */
    isReadOnly?: boolean;
    /** List of conditional values */
    conditionalValues?: ConditionalValueDto[] | undefined;
    /** Does this field has evaluated conditional value? */
    hasEvaluatedConditionalValue?: boolean;
    /** Evaluated conditional value */
    evaluatedConditionalValue?: string | undefined;

    constructor(data?: IDataGroupFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identifier = _data["identifier"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.order = _data["order"];
            this.dataField = _data["dataField"] ? DataFieldDto.fromJS(_data["dataField"]) : <any>undefined;
            this.isSensitiveData = _data["isSensitiveData"];
            this.isCoreDefinition = _data["isCoreDefinition"];
            this.validationRule = _data["validationRule"] ? ValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            this.version = _data["version"];
            this.defaultValue = _data["defaultValue"];
            this.isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["conditionalValues"])) {
                this.conditionalValues = [] as any;
                for (let item of _data["conditionalValues"])
                    this.conditionalValues!.push(ConditionalValueDto.fromJS(item));
            }
            this.hasEvaluatedConditionalValue = _data["hasEvaluatedConditionalValue"];
            this.evaluatedConditionalValue = _data["evaluatedConditionalValue"];
        }
    }

    static fromJS(data: any): DataGroupFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        data["name"] = this.name;
        data["type"] = this.type;
        data["order"] = this.order;
        data["dataField"] = this.dataField ? this.dataField.toJSON() : <any>undefined;
        data["isSensitiveData"] = this.isSensitiveData;
        data["isCoreDefinition"] = this.isCoreDefinition;
        data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["version"] = this.version;
        data["defaultValue"] = this.defaultValue;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.conditionalValues)) {
            data["conditionalValues"] = [];
            for (let item of this.conditionalValues)
                data["conditionalValues"].push(item.toJSON());
        }
        data["hasEvaluatedConditionalValue"] = this.hasEvaluatedConditionalValue;
        data["evaluatedConditionalValue"] = this.evaluatedConditionalValue;
        return data;
    }
}

/** Response DTO representing data group field data */
export interface IDataGroupFieldDto {
    /** The UiD of the data group field */
    identifier?: string;
    /** Data group field name */
    name?: string | undefined;
    /** Data group field type */
    type?: string | undefined;
    /** Data group field order */
    order?: number | undefined;
    /** Data group field data field */
    dataField?: DataFieldDto | undefined;
    /** Data group field sensitive data flag */
    isSensitiveData?: boolean;
    /** Data group field core definition flag */
    isCoreDefinition?: boolean;
    /** Data group field validation data */
    validationRule?: ValidationRule | undefined;
    /** Data group field conditions list */
    conditions?: ConditionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
    /** Default value for this data field */
    defaultValue?: string | undefined;
    /** Is requirement readonly */
    isReadOnly?: boolean;
    /** List of conditional values */
    conditionalValues?: ConditionalValueDto[] | undefined;
    /** Does this field has evaluated conditional value? */
    hasEvaluatedConditionalValue?: boolean;
    /** Evaluated conditional value */
    evaluatedConditionalValue?: string | undefined;
}

/** Service response data */
export class DataGroupFieldDtoServiceResponse implements IDataGroupFieldDtoServiceResponse {
    /** Response DTO representing data group field data */
    data?: DataGroupFieldDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDataGroupFieldDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DataGroupFieldDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataGroupFieldDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupFieldDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IDataGroupFieldDtoServiceResponse {
    /** Response DTO representing data group field data */
    data?: DataGroupFieldDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class DataGroupIdentifierDto implements IDataGroupIdentifierDto {
    /** Data Group UiD */
    id?: string;
    /** Data Group Version Numbers */
    versionNumbers?: number[] | undefined;

    constructor(data?: IDataGroupIdentifierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["versionNumbers"])) {
                this.versionNumbers = [] as any;
                for (let item of _data["versionNumbers"])
                    this.versionNumbers!.push(item);
            }
        }
    }

    static fromJS(data: any): DataGroupIdentifierDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupIdentifierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.versionNumbers)) {
            data["versionNumbers"] = [];
            for (let item of this.versionNumbers)
                data["versionNumbers"].push(item);
        }
        return data;
    }
}

export interface IDataGroupIdentifierDto {
    /** Data Group UiD */
    id?: string;
    /** Data Group Version Numbers */
    versionNumbers?: number[] | undefined;
}

/** Response DTO representing data group data lite */
export class DataGroupLiteDto implements IDataGroupLiteDto {
    /** The UiD of the data group */
    id?: string;
    /** Versions associated to this data group */
    versions?: DataGroupVersionLiteDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;

    constructor(data?: IDataGroupLiteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(DataGroupVersionLiteDto.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): DataGroupLiteDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupLiteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing data group data lite */
export interface IDataGroupLiteDto {
    /** The UiD of the data group */
    id?: string;
    /** Versions associated to this data group */
    versions?: DataGroupVersionLiteDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
}

/** Service response data */
export class DataGroupLiteDtoIEnumerableServiceResponse implements IDataGroupLiteDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: DataGroupLiteDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDataGroupLiteDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DataGroupLiteDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataGroupLiteDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupLiteDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IDataGroupLiteDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: DataGroupLiteDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing data group version data */
export class DataGroupVersionDto implements IDataGroupVersionDto {
    /** The UiD of the data group version */
    id?: string;
    /** The UiD of the data group that the version belongs to */
    groupId?: string;
    /** Data group Name */
    name?: string | undefined;
    /** Data group description */
    description?: string | undefined;
    /** Property name for Primary Data Group Field */
    primaryDataGroupField?: string | undefined;
    /** Data group cardinality flag */
    cardinality?: boolean;
    /** Data group template */
    template?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    readonly publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
    /** List of data group fields */
    dataGroupFields?: DataGroupFieldDto[] | undefined;

    constructor(data?: IDataGroupVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.primaryDataGroupField = _data["primaryDataGroupField"];
            this.cardinality = _data["cardinality"];
            this.template = _data["template"];
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            (<any>this).publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            this.version = _data["version"];
            if (Array.isArray(_data["dataGroupFields"])) {
                this.dataGroupFields = [] as any;
                for (let item of _data["dataGroupFields"])
                    this.dataGroupFields!.push(DataGroupFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataGroupVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["primaryDataGroupField"] = this.primaryDataGroupField;
        data["cardinality"] = this.cardinality;
        data["template"] = this.template;
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        data["version"] = this.version;
        if (Array.isArray(this.dataGroupFields)) {
            data["dataGroupFields"] = [];
            for (let item of this.dataGroupFields)
                data["dataGroupFields"].push(item.toJSON());
        }
        return data;
    }
}

/** Response DTO representing data group version data */
export interface IDataGroupVersionDto {
    /** The UiD of the data group version */
    id?: string;
    /** The UiD of the data group that the version belongs to */
    groupId?: string;
    /** Data group Name */
    name?: string | undefined;
    /** Data group description */
    description?: string | undefined;
    /** Property name for Primary Data Group Field */
    primaryDataGroupField?: string | undefined;
    /** Data group cardinality flag */
    cardinality?: boolean;
    /** Data group template */
    template?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
    /** List of data group fields */
    dataGroupFields?: DataGroupFieldDto[] | undefined;
}

/** Service response data */
export class DataGroupVersionDtoListServiceResponse implements IDataGroupVersionDtoListServiceResponse {
    /** The service response DTO */
    data?: DataGroupVersionDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDataGroupVersionDtoListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DataGroupVersionDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataGroupVersionDtoListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupVersionDtoListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IDataGroupVersionDtoListServiceResponse {
    /** The service response DTO */
    data?: DataGroupVersionDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Service response data */
export class DataGroupVersionDtoServiceResponse implements IDataGroupVersionDtoServiceResponse {
    /** Response DTO representing data group version data */
    data?: DataGroupVersionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDataGroupVersionDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DataGroupVersionDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataGroupVersionDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupVersionDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IDataGroupVersionDtoServiceResponse {
    /** Response DTO representing data group version data */
    data?: DataGroupVersionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing data group version lite data */
export class DataGroupVersionLiteDto implements IDataGroupVersionLiteDto {
    /** The UiD of the data group version */
    id?: string;
    /** The UiD of the data group that the version belongs to */
    groupId?: string;
    /** Data group Name */
    name?: string | undefined;
    /** Data group description */
    description?: string | undefined;
    /** Property name for Primary Data Group Field */
    primaryDataGroupField?: string | undefined;
    /** Data group cardinality flag */
    cardinality?: boolean;
    /** Data group template */
    template?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    readonly publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;

    constructor(data?: IDataGroupVersionLiteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.primaryDataGroupField = _data["primaryDataGroupField"];
            this.cardinality = _data["cardinality"];
            this.template = _data["template"];
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            (<any>this).publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): DataGroupVersionLiteDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataGroupVersionLiteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["primaryDataGroupField"] = this.primaryDataGroupField;
        data["cardinality"] = this.cardinality;
        data["template"] = this.template;
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing data group version lite data */
export interface IDataGroupVersionLiteDto {
    /** The UiD of the data group version */
    id?: string;
    /** The UiD of the data group that the version belongs to */
    groupId?: string;
    /** Data group Name */
    name?: string | undefined;
    /** Data group description */
    description?: string | undefined;
    /** Property name for Primary Data Group Field */
    primaryDataGroupField?: string | undefined;
    /** Data group cardinality flag */
    cardinality?: boolean;
    /** Data group template */
    template?: string | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
}

export class DataRequirement extends Requirement implements IDataRequirement {
    dataField?: DataField | undefined;
    validationRule?: ValidationRule | undefined;
    order?: number | undefined;
    defaultValue?: string | undefined;
    isReadOnly?: boolean;
    isIndexable?: boolean;
    readonly isMandatoryIndexable?: boolean;
    conditionalValues?: ConditionalValue[] | undefined;
    hasEvaluatedConditionalValue?: boolean;
    evaluatedConditionalValue?: string;

    constructor(data?: IDataRequirement) {
        super(data);
        this._discriminator = "Data";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dataField = _data["dataField"] ? DataField.fromJS(_data["dataField"]) : <any>undefined;
            this.validationRule = _data["validationRule"] ? ValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
            this.order = _data["order"];
            this.defaultValue = _data["defaultValue"];
            this.isReadOnly = _data["isReadOnly"];
            this.isIndexable = _data["isIndexable"];
            (<any>this).isMandatoryIndexable = _data["isMandatoryIndexable"];
            if (Array.isArray(_data["conditionalValues"])) {
                this.conditionalValues = [] as any;
                for (let item of _data["conditionalValues"])
                    this.conditionalValues!.push(ConditionalValue.fromJS(item));
            }
            this.hasEvaluatedConditionalValue = _data["hasEvaluatedConditionalValue"];
            this.evaluatedConditionalValue = _data["evaluatedConditionalValue"];
        }
    }

    static fromJS(data: any): DataRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new DataRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataField"] = this.dataField ? this.dataField.toJSON() : <any>undefined;
        data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
        data["order"] = this.order;
        data["defaultValue"] = this.defaultValue;
        data["isReadOnly"] = this.isReadOnly;
        data["isIndexable"] = this.isIndexable;
        data["isMandatoryIndexable"] = this.isMandatoryIndexable;
        if (Array.isArray(this.conditionalValues)) {
            data["conditionalValues"] = [];
            for (let item of this.conditionalValues)
                data["conditionalValues"].push(item.toJSON());
        }
        data["hasEvaluatedConditionalValue"] = this.hasEvaluatedConditionalValue;
        data["evaluatedConditionalValue"] = this.evaluatedConditionalValue;
        super.toJSON(data);
        return data;
    }
}

export interface IDataRequirement extends IRequirement {
    dataField?: DataField | undefined;
    validationRule?: ValidationRule | undefined;
    order?: number | undefined;
    defaultValue?: string | undefined;
    isReadOnly?: boolean;
    isIndexable?: boolean;
    isMandatoryIndexable?: boolean;
    conditionalValues?: ConditionalValue[] | undefined;
}

export class DateLimitRule implements IDateLimitRule {
    active?: boolean;
    message?: string | undefined;
    minDate?: Date | undefined;
    maxDate?: Date | undefined;

    constructor(data?: IDateLimitRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            this.minDate = _data["minDate"] ? new Date(_data["minDate"].toString()) : <any>undefined;
            this.maxDate = _data["maxDate"] ? new Date(_data["maxDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateLimitRule {
        data = typeof data === 'object' ? data : {};
        let result = new DateLimitRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        data["minDate"] = this.minDate ? this.minDate.toISOString() : <any>undefined;
        data["maxDate"] = this.maxDate ? this.maxDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDateLimitRule {
    active?: boolean;
    message?: string | undefined;
    minDate?: Date | undefined;
    maxDate?: Date | undefined;
}

export enum Decision {
    Approve = "Approve",
    Reject = "Reject",
}

export class DocumentRequirement extends Requirement implements IDocumentRequirement {
    isMandatory?: boolean;
    documentDescription?: string | undefined;
    documentDataKey?: string | undefined;
    documentAccessLayers?: AccessLayer | undefined;

    constructor(data?: IDocumentRequirement) {
        super(data);
        this._discriminator = "Document";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isMandatory = _data["isMandatory"];
            this.documentDescription = _data["documentDescription"];
            this.documentDataKey = _data["documentDataKey"];
            this.documentAccessLayers = _data["documentAccessLayers"] ? AccessLayer.fromJS(_data["documentAccessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMandatory"] = this.isMandatory;
        data["documentDescription"] = this.documentDescription;
        data["documentDataKey"] = this.documentDataKey;
        data["documentAccessLayers"] = this.documentAccessLayers ? this.documentAccessLayers.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDocumentRequirement extends IRequirement {
    isMandatory?: boolean;
    documentDescription?: string | undefined;
    documentDataKey?: string | undefined;
    documentAccessLayers?: AccessLayer | undefined;
}

export class ESignatureDocumentRequirement extends Requirement implements IESignatureDocumentRequirement {
    isMandatory?: boolean;
    documentDescription?: string | undefined;
    documentDataKey?: string | undefined;
    documentAccessLayers?: AccessLayer | undefined;

    constructor(data?: IESignatureDocumentRequirement) {
        super(data);
        this._discriminator = "eSignatureDocument";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isMandatory = _data["isMandatory"];
            this.documentDescription = _data["documentDescription"];
            this.documentDataKey = _data["documentDataKey"];
            this.documentAccessLayers = _data["documentAccessLayers"] ? AccessLayer.fromJS(_data["documentAccessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ESignatureDocumentRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new ESignatureDocumentRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMandatory"] = this.isMandatory;
        data["documentDescription"] = this.documentDescription;
        data["documentDataKey"] = this.documentDataKey;
        data["documentAccessLayers"] = this.documentAccessLayers ? this.documentAccessLayers.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IESignatureDocumentRequirement extends IRequirement {
    isMandatory?: boolean;
    documentDescription?: string | undefined;
    documentDataKey?: string | undefined;
    documentAccessLayers?: AccessLayer | undefined;
}

export class EvaluateRequirementsInScopeRequestDto implements IEvaluateRequirementsInScopeRequestDto {
    /** List of requirement types [Data, Document, OwnershipAndControl] */
    requirementTypes?: string[] | undefined;
    /** Jurisdictions of the requirement in specific version */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** Target entity */
    targetEntity?: string | undefined;
    /** Type of entity */
    entityType?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    categories?: string[] | undefined;
    /** Entity data properties used for condition evaluation */
    properties?: { [key: string]: PropertyDto; } | undefined;

    constructor(data?: IEvaluateRequirementsInScopeRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["requirementTypes"])) {
                this.requirementTypes = [] as any;
                for (let item of _data["requirementTypes"])
                    this.requirementTypes!.push(item);
            }
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(VersionedJurisdictionDto.fromJS(item));
            }
            this.targetEntity = _data["targetEntity"];
            this.entityType = _data["entityType"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): EvaluateRequirementsInScopeRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementsInScopeRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requirementTypes)) {
            data["requirementTypes"] = [];
            for (let item of this.requirementTypes)
                data["requirementTypes"].push(item);
        }
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item.toJSON());
        }
        data["targetEntity"] = this.targetEntity;
        data["entityType"] = this.entityType;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IEvaluateRequirementsInScopeRequestDto {
    /** List of requirement types [Data, Document, OwnershipAndControl] */
    requirementTypes?: string[] | undefined;
    /** Jurisdictions of the requirement in specific version */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** Target entity */
    targetEntity?: string | undefined;
    /** Type of entity */
    entityType?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    categories?: string[] | undefined;
    /** Entity data properties used for condition evaluation */
    properties?: { [key: string]: PropertyDto; } | undefined;
}

/** Service request data */
export class EvaluateRequirementsInScopeRequestDtoServiceRequest implements IEvaluateRequirementsInScopeRequestDtoServiceRequest {
    /** The service request DTO */
    data!: EvaluateRequirementsInScopeRequestDto;

    constructor(data?: IEvaluateRequirementsInScopeRequestDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new EvaluateRequirementsInScopeRequestDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? EvaluateRequirementsInScopeRequestDto.fromJS(_data["data"]) : new EvaluateRequirementsInScopeRequestDto();
        }
    }

    static fromJS(data: any): EvaluateRequirementsInScopeRequestDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluateRequirementsInScopeRequestDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IEvaluateRequirementsInScopeRequestDtoServiceRequest {
    /** The service request DTO */
    data: EvaluateRequirementsInScopeRequestDto;
}

export class GetDataGroupsRequestDto implements IGetDataGroupsRequestDto {
    /** List with DataGroup Id and Version Numbers */
    identifiers?: DataGroupIdentifierDto[] | undefined;

    constructor(data?: IGetDataGroupsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["identifiers"])) {
                this.identifiers = [] as any;
                for (let item of _data["identifiers"])
                    this.identifiers!.push(DataGroupIdentifierDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDataGroupsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataGroupsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.identifiers)) {
            data["identifiers"] = [];
            for (let item of this.identifiers)
                data["identifiers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetDataGroupsRequestDto {
    /** List with DataGroup Id and Version Numbers */
    identifiers?: DataGroupIdentifierDto[] | undefined;
}

/** Service request data */
export class GetDataGroupsRequestDtoServiceRequest implements IGetDataGroupsRequestDtoServiceRequest {
    /** The service request DTO */
    data?: GetDataGroupsRequestDto | undefined;

    constructor(data?: IGetDataGroupsRequestDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GetDataGroupsRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDataGroupsRequestDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataGroupsRequestDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IGetDataGroupsRequestDtoServiceRequest {
    /** The service request DTO */
    data?: GetDataGroupsRequestDto | undefined;
}

/** Request DTO representing light requirenment sets */
export class GetRequirementSetsByIdsLightRequestDto implements IGetRequirementSetsByIdsLightRequestDto {
    /** Entitys data jurisdictions */
    inScopeJurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of Entitys offboarded jursidictions */
    offboardedJurisdictions?: string[] | undefined;

    constructor(data?: IGetRequirementSetsByIdsLightRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["inScopeJurisdictions"])) {
                this.inScopeJurisdictions = [] as any;
                for (let item of _data["inScopeJurisdictions"])
                    this.inScopeJurisdictions!.push(VersionedJurisdictionDto.fromJS(item));
            }
            if (Array.isArray(_data["offboardedJurisdictions"])) {
                this.offboardedJurisdictions = [] as any;
                for (let item of _data["offboardedJurisdictions"])
                    this.offboardedJurisdictions!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRequirementSetsByIdsLightRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRequirementSetsByIdsLightRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.inScopeJurisdictions)) {
            data["inScopeJurisdictions"] = [];
            for (let item of this.inScopeJurisdictions)
                data["inScopeJurisdictions"].push(item.toJSON());
        }
        if (Array.isArray(this.offboardedJurisdictions)) {
            data["offboardedJurisdictions"] = [];
            for (let item of this.offboardedJurisdictions)
                data["offboardedJurisdictions"].push(item);
        }
        return data;
    }
}

/** Request DTO representing light requirenment sets */
export interface IGetRequirementSetsByIdsLightRequestDto {
    /** Entitys data jurisdictions */
    inScopeJurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of Entitys offboarded jursidictions */
    offboardedJurisdictions?: string[] | undefined;
}

/** Service request data */
export class GetRequirementSetsByIdsLightRequestDtoServiceRequest implements IGetRequirementSetsByIdsLightRequestDtoServiceRequest {
    /** Request DTO representing light requirenment sets */
    data?: GetRequirementSetsByIdsLightRequestDto | undefined;

    constructor(data?: IGetRequirementSetsByIdsLightRequestDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GetRequirementSetsByIdsLightRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRequirementSetsByIdsLightRequestDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetRequirementSetsByIdsLightRequestDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IGetRequirementSetsByIdsLightRequestDtoServiceRequest {
    /** Request DTO representing light requirenment sets */
    data?: GetRequirementSetsByIdsLightRequestDto | undefined;
}

/** Response DTO representing validation request data */
export class GetValidationRulesRequestDto implements IGetValidationRulesRequestDto {
    /** List of jurisdictions e.g. ["Global", "Ireland"] */
    jurisdictions?: string[] | undefined;
    /** The type of the entity (Individual, Company, Other, All) */
    entityType?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    category?: string[] | undefined;

    constructor(data?: IGetValidationRulesRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(item);
            }
            this.entityType = _data["entityType"];
            if (Array.isArray(_data["category"])) {
                this.category = [] as any;
                for (let item of _data["category"])
                    this.category!.push(item);
            }
        }
    }

    static fromJS(data: any): GetValidationRulesRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetValidationRulesRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item);
        }
        data["entityType"] = this.entityType;
        if (Array.isArray(this.category)) {
            data["category"] = [];
            for (let item of this.category)
                data["category"].push(item);
        }
        return data;
    }
}

/** Response DTO representing validation request data */
export interface IGetValidationRulesRequestDto {
    /** List of jurisdictions e.g. ["Global", "Ireland"] */
    jurisdictions?: string[] | undefined;
    /** The type of the entity (Individual, Company, Other, All) */
    entityType?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    category?: string[] | undefined;
}

/** Service request data */
export class GetValidationRulesRequestDtoServiceRequest implements IGetValidationRulesRequestDtoServiceRequest {
    /** Response DTO representing validation request data */
    data?: GetValidationRulesRequestDto | undefined;

    constructor(data?: IGetValidationRulesRequestDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GetValidationRulesRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetValidationRulesRequestDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetValidationRulesRequestDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IGetValidationRulesRequestDtoServiceRequest {
    /** Response DTO representing validation request data */
    data?: GetValidationRulesRequestDto | undefined;
}

/** Service response data */
export class ObjectServiceResponse implements IObjectServiceResponse {
    /** The service response DTO */
    data?: any | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IObjectServiceResponse {
    /** The service response DTO */
    data?: any | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class OwnershipAndControlRequirement extends Requirement implements IOwnershipAndControlRequirement {
    ownershipDataKey?: string | undefined;
    partyType?: string | undefined;
    partyTypes?: string[] | undefined;
    uboThreshold?: number | undefined;
    sourceEntityType?: string | undefined;
    relatedPartyEntityTypes?: string[] | undefined;
    directAssociationsOnly?: boolean;
    idvOn?: boolean;
    idvName?: string | undefined;
    idvTooltip?: string | undefined;
    isMandatory?: boolean;
    partyCount?: number | undefined;
    ownershipValidationRule?: OwnershipValidationRule | undefined;

    constructor(data?: IOwnershipAndControlRequirement) {
        super(data);
        this._discriminator = "OwnershipAndControl";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ownershipDataKey = _data["ownershipDataKey"];
            this.partyType = _data["partyType"];
            if (Array.isArray(_data["partyTypes"])) {
                this.partyTypes = [] as any;
                for (let item of _data["partyTypes"])
                    this.partyTypes!.push(item);
            }
            this.uboThreshold = _data["uboThreshold"];
            this.sourceEntityType = _data["sourceEntityType"];
            if (Array.isArray(_data["relatedPartyEntityTypes"])) {
                this.relatedPartyEntityTypes = [] as any;
                for (let item of _data["relatedPartyEntityTypes"])
                    this.relatedPartyEntityTypes!.push(item);
            }
            this.directAssociationsOnly = _data["directAssociationsOnly"];
            this.idvOn = _data["idvOn"];
            this.idvName = _data["idvName"];
            this.idvTooltip = _data["idvTooltip"];
            this.isMandatory = _data["isMandatory"];
            this.partyCount = _data["partyCount"];
            this.ownershipValidationRule = _data["ownershipValidationRule"] ? OwnershipValidationRule.fromJS(_data["ownershipValidationRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OwnershipAndControlRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new OwnershipAndControlRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownershipDataKey"] = this.ownershipDataKey;
        data["partyType"] = this.partyType;
        if (Array.isArray(this.partyTypes)) {
            data["partyTypes"] = [];
            for (let item of this.partyTypes)
                data["partyTypes"].push(item);
        }
        data["uboThreshold"] = this.uboThreshold;
        data["sourceEntityType"] = this.sourceEntityType;
        if (Array.isArray(this.relatedPartyEntityTypes)) {
            data["relatedPartyEntityTypes"] = [];
            for (let item of this.relatedPartyEntityTypes)
                data["relatedPartyEntityTypes"].push(item);
        }
        data["directAssociationsOnly"] = this.directAssociationsOnly;
        data["idvOn"] = this.idvOn;
        data["idvName"] = this.idvName;
        data["idvTooltip"] = this.idvTooltip;
        data["isMandatory"] = this.isMandatory;
        data["partyCount"] = this.partyCount;
        data["ownershipValidationRule"] = this.ownershipValidationRule ? this.ownershipValidationRule.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IOwnershipAndControlRequirement extends IRequirement {
    ownershipDataKey?: string | undefined;
    partyType?: string | undefined;
    partyTypes?: string[] | undefined;
    uboThreshold?: number | undefined;
    sourceEntityType?: string | undefined;
    relatedPartyEntityTypes?: string[] | undefined;
    directAssociationsOnly?: boolean;
    idvOn?: boolean;
    idvName?: string | undefined;
    idvTooltip?: string | undefined;
    isMandatory?: boolean;
    partyCount?: number | undefined;
    ownershipValidationRule?: OwnershipValidationRule | undefined;
}

export class OwnershipValidationData implements IOwnershipValidationData {
    isMandatory?: BasicRule | undefined;
    partyCount?: ValueLimitRule | undefined;
    addAllParties?: BasicRule | undefined;
    idvIsMandatory?: BasicRule | undefined;
    idvPartyCount?: ValueLimitRule | undefined;
    idvAllParties?: BasicRule | undefined;

    constructor(data?: IOwnershipValidationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isMandatory = _data["isMandatory"] ? BasicRule.fromJS(_data["isMandatory"]) : <any>undefined;
            this.partyCount = _data["partyCount"] ? ValueLimitRule.fromJS(_data["partyCount"]) : <any>undefined;
            this.addAllParties = _data["addAllParties"] ? BasicRule.fromJS(_data["addAllParties"]) : <any>undefined;
            this.idvIsMandatory = _data["idvIsMandatory"] ? BasicRule.fromJS(_data["idvIsMandatory"]) : <any>undefined;
            this.idvPartyCount = _data["idvPartyCount"] ? ValueLimitRule.fromJS(_data["idvPartyCount"]) : <any>undefined;
            this.idvAllParties = _data["idvAllParties"] ? BasicRule.fromJS(_data["idvAllParties"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OwnershipValidationData {
        data = typeof data === 'object' ? data : {};
        let result = new OwnershipValidationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMandatory"] = this.isMandatory ? this.isMandatory.toJSON() : <any>undefined;
        data["partyCount"] = this.partyCount ? this.partyCount.toJSON() : <any>undefined;
        data["addAllParties"] = this.addAllParties ? this.addAllParties.toJSON() : <any>undefined;
        data["idvIsMandatory"] = this.idvIsMandatory ? this.idvIsMandatory.toJSON() : <any>undefined;
        data["idvPartyCount"] = this.idvPartyCount ? this.idvPartyCount.toJSON() : <any>undefined;
        data["idvAllParties"] = this.idvAllParties ? this.idvAllParties.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOwnershipValidationData {
    isMandatory?: BasicRule | undefined;
    partyCount?: ValueLimitRule | undefined;
    addAllParties?: BasicRule | undefined;
    idvIsMandatory?: BasicRule | undefined;
    idvPartyCount?: ValueLimitRule | undefined;
    idvAllParties?: BasicRule | undefined;
}

export class OwnershipValidationRule implements IOwnershipValidationRule {
    id?: string;
    setId?: string;
    ownershipValidationData?: OwnershipValidationData | undefined;

    constructor(data?: IOwnershipValidationRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.setId = _data["setId"];
            this.ownershipValidationData = _data["ownershipValidationData"] ? OwnershipValidationData.fromJS(_data["ownershipValidationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OwnershipValidationRule {
        data = typeof data === 'object' ? data : {};
        let result = new OwnershipValidationRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["setId"] = this.setId;
        data["ownershipValidationData"] = this.ownershipValidationData ? this.ownershipValidationData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOwnershipValidationRule {
    id?: string;
    setId?: string;
    ownershipValidationData?: OwnershipValidationData | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

/** Response DTO representing product requirement set data */
export class ProductRequirementSetDto implements IProductRequirementSetDto {
    /** The UiD of the product requirement set */
    id?: string;
    /** Versions associated to this product requirement set */
    versions?: ProductRequirementSetVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
    /** Product Requirement Set status */
    status?: string | undefined;
    /** Jurisdiction of the product requirement set */
    jurisdiction?: string | undefined;

    constructor(data?: IProductRequirementSetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(ProductRequirementSetVersionDto.fromJS(item));
            }
            this.version = _data["version"];
            this.status = _data["status"];
            this.jurisdiction = _data["jurisdiction"];
        }
    }

    static fromJS(data: any): ProductRequirementSetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductRequirementSetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        data["version"] = this.version;
        data["status"] = this.status;
        data["jurisdiction"] = this.jurisdiction;
        return data;
    }
}

/** Response DTO representing product requirement set data */
export interface IProductRequirementSetDto {
    /** The UiD of the product requirement set */
    id?: string;
    /** Versions associated to this product requirement set */
    versions?: ProductRequirementSetVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
    /** Product Requirement Set status */
    status?: string | undefined;
    /** Jurisdiction of the product requirement set */
    jurisdiction?: string | undefined;
}

/** Service response data */
export class ProductRequirementSetDtoIEnumerableServiceResponse implements IProductRequirementSetDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: ProductRequirementSetDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IProductRequirementSetDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductRequirementSetDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductRequirementSetDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductRequirementSetDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IProductRequirementSetDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: ProductRequirementSetDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing product requirement set version data */
export class ProductRequirementSetVersionDto implements IProductRequirementSetVersionDto {
    /** The UiD of the requirement set version */
    id?: string;
    /** The UiD of the requirement set that the version belongs to */
    setId?: string;
    /** Requirement set status */
    requirementSetStatus?: string | undefined;
    /** Requirement set name */
    name?: string | undefined;
    /** Requirement set jurisdiction */
    jurisdiction?: string | undefined;
    /** Default jurisdiction for data protection */
    defaultDataProtectionJurisdiction?: string | undefined;
    /** List of requirements */
    requirements?: Requirement[] | undefined;
    /** Conditions under which the requirement set can be applied */
    conditions?: ConditionDto[] | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    readonly publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;

    constructor(data?: IProductRequirementSetVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.setId = _data["setId"];
            this.requirementSetStatus = _data["requirementSetStatus"];
            this.name = _data["name"];
            this.jurisdiction = _data["jurisdiction"];
            this.defaultDataProtectionJurisdiction = _data["defaultDataProtectionJurisdiction"];
            if (Array.isArray(_data["requirements"])) {
                this.requirements = [] as any;
                for (let item of _data["requirements"])
                    this.requirements!.push(Requirement.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            (<any>this).publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ProductRequirementSetVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductRequirementSetVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["setId"] = this.setId;
        data["requirementSetStatus"] = this.requirementSetStatus;
        data["name"] = this.name;
        data["jurisdiction"] = this.jurisdiction;
        data["defaultDataProtectionJurisdiction"] = this.defaultDataProtectionJurisdiction;
        if (Array.isArray(this.requirements)) {
            data["requirements"] = [];
            for (let item of this.requirements)
                data["requirements"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing product requirement set version data */
export interface IProductRequirementSetVersionDto {
    /** The UiD of the requirement set version */
    id?: string;
    /** The UiD of the requirement set that the version belongs to */
    setId?: string;
    /** Requirement set status */
    requirementSetStatus?: string | undefined;
    /** Requirement set name */
    name?: string | undefined;
    /** Requirement set jurisdiction */
    jurisdiction?: string | undefined;
    /** Default jurisdiction for data protection */
    defaultDataProtectionJurisdiction?: string | undefined;
    /** List of requirements */
    requirements?: Requirement[] | undefined;
    /** Conditions under which the requirement set can be applied */
    conditions?: ConditionDto[] | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
}

/** Service response data */
export class ProductRequirementSetVersionDtoServiceResponse implements IProductRequirementSetVersionDtoServiceResponse {
    /** Response DTO representing product requirement set version data */
    data?: ProductRequirementSetVersionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IProductRequirementSetVersionDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ProductRequirementSetVersionDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductRequirementSetVersionDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductRequirementSetVersionDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IProductRequirementSetVersionDtoServiceResponse {
    /** Response DTO representing product requirement set version data */
    data?: ProductRequirementSetVersionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export enum PropertyType {
    Single = "Single",
    Custom = "Custom",
    Collection = "Collection",
}

export class Reference implements IReference {
    type?: string | undefined;
    description?: string | undefined;
    url?: string | undefined;

    constructor(data?: IReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.description = _data["description"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Reference {
        data = typeof data === 'object' ? data : {};
        let result = new Reference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["url"] = this.url;
        return data;
    }
}

export interface IReference {
    type?: string | undefined;
    description?: string | undefined;
    url?: string | undefined;
}

export class RegexRule implements IRegexRule {
    active?: boolean;
    message?: string | undefined;
    isCaseSensitive?: boolean;
    regexValue?: string | undefined;

    constructor(data?: IRegexRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            this.isCaseSensitive = _data["isCaseSensitive"];
            this.regexValue = _data["regexValue"];
        }
    }

    static fromJS(data: any): RegexRule {
        data = typeof data === 'object' ? data : {};
        let result = new RegexRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        data["isCaseSensitive"] = this.isCaseSensitive;
        data["regexValue"] = this.regexValue;
        return data;
    }
}

export interface IRegexRule {
    active?: boolean;
    message?: string | undefined;
    isCaseSensitive?: boolean;
    regexValue?: string | undefined;
}

/** Service response data */
export class RequirementListServiceResponse implements IRequirementListServiceResponse {
    /** The service response DTO */
    data?: Requirement[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IRequirementListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Requirement.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequirementListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IRequirementListServiceResponse {
    /** The service response DTO */
    data?: Requirement[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Service response data */
export class RequirementServiceResponse implements IRequirementServiceResponse {
    /** The service response DTO */
    data?: Requirement | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IRequirementServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? Requirement.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequirementServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IRequirementServiceResponse {
    /** The service response DTO */
    data?: Requirement | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing requirement set data */
export class RequirementSetDto implements IRequirementSetDto {
    /** The UiD of the requirement set */
    id?: string;
    /** Versions associated to this requirement set */
    versions?: RequirementSetVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
    /** Requirement Set status */
    status?: string | undefined;
    /** Jurisdiction of the requirement set */
    jurisdiction?: string | undefined;

    constructor(data?: IRequirementSetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(RequirementSetVersionDto.fromJS(item));
            }
            this.version = _data["version"];
            this.status = _data["status"];
            this.jurisdiction = _data["jurisdiction"];
        }
    }

    static fromJS(data: any): RequirementSetDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementSetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        data["version"] = this.version;
        data["status"] = this.status;
        data["jurisdiction"] = this.jurisdiction;
        return data;
    }
}

/** Response DTO representing requirement set data */
export interface IRequirementSetDto {
    /** The UiD of the requirement set */
    id?: string;
    /** Versions associated to this requirement set */
    versions?: RequirementSetVersionDto[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
    /** Requirement Set status */
    status?: string | undefined;
    /** Jurisdiction of the requirement set */
    jurisdiction?: string | undefined;
}

/** Service response data */
export class RequirementSetDtoIEnumerableServiceResponse implements IRequirementSetDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: RequirementSetDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IRequirementSetDtoIEnumerableServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RequirementSetDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequirementSetDtoIEnumerableServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementSetDtoIEnumerableServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IRequirementSetDtoIEnumerableServiceResponse {
    /** The service response DTO */
    data?: RequirementSetDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing requirement sets jurisdictions available */
export class RequirementSetJurisdictionDto implements IRequirementSetJurisdictionDto {
    /** List of available jurisdictions in which requirement sets are created */
    availableJurisdictions?: string[] | undefined;

    constructor(data?: IRequirementSetJurisdictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["availableJurisdictions"])) {
                this.availableJurisdictions = [] as any;
                for (let item of _data["availableJurisdictions"])
                    this.availableJurisdictions!.push(item);
            }
        }
    }

    static fromJS(data: any): RequirementSetJurisdictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementSetJurisdictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.availableJurisdictions)) {
            data["availableJurisdictions"] = [];
            for (let item of this.availableJurisdictions)
                data["availableJurisdictions"].push(item);
        }
        return data;
    }
}

/** Response DTO representing requirement sets jurisdictions available */
export interface IRequirementSetJurisdictionDto {
    /** List of available jurisdictions in which requirement sets are created */
    availableJurisdictions?: string[] | undefined;
}

/** Service response data */
export class RequirementSetJurisdictionDtoServiceResponse implements IRequirementSetJurisdictionDtoServiceResponse {
    /** Response DTO representing requirement sets jurisdictions available */
    data?: RequirementSetJurisdictionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IRequirementSetJurisdictionDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? RequirementSetJurisdictionDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequirementSetJurisdictionDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementSetJurisdictionDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IRequirementSetJurisdictionDtoServiceResponse {
    /** Response DTO representing requirement sets jurisdictions available */
    data?: RequirementSetJurisdictionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing light version of jursidiction set */
export class RequirementSetLightDto implements IRequirementSetLightDto {
    /** The UiD of the requirement set */
    id?: string;
    /** Requirement set name */
    name?: string | undefined;
    /** The status of requirenment set */
    status?: string | undefined;
    /** The version number */
    versionNumber?: number;
    /** Jurisdiction of the requirement set */
    jurisdiction?: string | undefined;

    constructor(data?: IRequirementSetLightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.versionNumber = _data["versionNumber"];
            this.jurisdiction = _data["jurisdiction"];
        }
    }

    static fromJS(data: any): RequirementSetLightDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementSetLightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["status"] = this.status;
        data["versionNumber"] = this.versionNumber;
        data["jurisdiction"] = this.jurisdiction;
        return data;
    }
}

/** Response DTO representing light version of jursidiction set */
export interface IRequirementSetLightDto {
    /** The UiD of the requirement set */
    id?: string;
    /** Requirement set name */
    name?: string | undefined;
    /** The status of requirenment set */
    status?: string | undefined;
    /** The version number */
    versionNumber?: number;
    /** Jurisdiction of the requirement set */
    jurisdiction?: string | undefined;
}

/** Service response data */
export class RequirementSetLightDtoListServiceResponse implements IRequirementSetLightDtoListServiceResponse {
    /** The service response DTO */
    data?: RequirementSetLightDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IRequirementSetLightDtoListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RequirementSetLightDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequirementSetLightDtoListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementSetLightDtoListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IRequirementSetLightDtoListServiceResponse {
    /** The service response DTO */
    data?: RequirementSetLightDto[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Response DTO representing requirement set version data */
export class RequirementSetVersionDto implements IRequirementSetVersionDto {
    /** The UiD of the requirement set version */
    id?: string;
    /** The UiD of the requirement set that the version belongs to */
    setId?: string;
    /** Requirement set status */
    requirementSetStatus?: string | undefined;
    /** Requirement set name */
    name?: string | undefined;
    /** Requirement set jurisdiction */
    jurisdiction?: string | undefined;
    /** Default jurisdiction for data protection */
    defaultDataProtectionJurisdiction?: string | undefined;
    /** List of requirements */
    requirements?: Requirement[] | undefined;
    /** Conditions under which the requirement set can be applied */
    conditions?: ConditionDto[] | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    readonly publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;

    constructor(data?: IRequirementSetVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.setId = _data["setId"];
            this.requirementSetStatus = _data["requirementSetStatus"];
            this.name = _data["name"];
            this.jurisdiction = _data["jurisdiction"];
            this.defaultDataProtectionJurisdiction = _data["defaultDataProtectionJurisdiction"];
            if (Array.isArray(_data["requirements"])) {
                this.requirements = [] as any;
                for (let item of _data["requirements"])
                    this.requirements!.push(Requirement.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(ConditionDto.fromJS(item));
            }
            this.versionNumber = _data["versionNumber"];
            this.effectiveFrom = _data["effectiveFrom"] ? new Date(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveUntil = _data["effectiveUntil"] ? new Date(_data["effectiveUntil"].toString()) : <any>undefined;
            (<any>this).publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["signees"])) {
                this.signees = [] as any;
                for (let item of _data["signees"])
                    this.signees!.push(Signee.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): RequirementSetVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementSetVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["setId"] = this.setId;
        data["requirementSetStatus"] = this.requirementSetStatus;
        data["name"] = this.name;
        data["jurisdiction"] = this.jurisdiction;
        data["defaultDataProtectionJurisdiction"] = this.defaultDataProtectionJurisdiction;
        if (Array.isArray(this.requirements)) {
            data["requirements"] = [];
            for (let item of this.requirements)
                data["requirements"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["versionNumber"] = this.versionNumber;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toISOString() : <any>undefined;
        data["effectiveUntil"] = this.effectiveUntil ? this.effectiveUntil.toISOString() : <any>undefined;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.signees)) {
            data["signees"] = [];
            for (let item of this.signees)
                data["signees"].push(item.toJSON());
        }
        data["version"] = this.version;
        return data;
    }
}

/** Response DTO representing requirement set version data */
export interface IRequirementSetVersionDto {
    /** The UiD of the requirement set version */
    id?: string;
    /** The UiD of the requirement set that the version belongs to */
    setId?: string;
    /** Requirement set status */
    requirementSetStatus?: string | undefined;
    /** Requirement set name */
    name?: string | undefined;
    /** Requirement set jurisdiction */
    jurisdiction?: string | undefined;
    /** Default jurisdiction for data protection */
    defaultDataProtectionJurisdiction?: string | undefined;
    /** List of requirements */
    requirements?: Requirement[] | undefined;
    /** Conditions under which the requirement set can be applied */
    conditions?: ConditionDto[] | undefined;
    /** The versions number */
    versionNumber?: number;
    /** The date that the version takes effect when published */
    effectiveFrom?: Date;
    /** The calculated date that the version ceases being active */
    effectiveUntil?: Date | undefined;
    /** The date that the version got published */
    publicationDate?: Date | undefined;
    /** The status of the version */
    status?: VersionStatus;
    /** The creation date of the version */
    created?: Date;
    /** The calculated flag to annotate whether this is the model's latest version
at the time of the query (not necessarily published) */
    isActive?: boolean;
    /** The defined list of signees for the version */
    signees?: Signee[] | undefined;
    /** Version number for given Aggregate (concurrency check) */
    version?: number;
}

/** Service response data */
export class RequirementSetVersionDtoServiceResponse implements IRequirementSetVersionDtoServiceResponse {
    /** Response DTO representing requirement set version data */
    data?: RequirementSetVersionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IRequirementSetVersionDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? RequirementSetVersionDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequirementSetVersionDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementSetVersionDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IRequirementSetVersionDtoServiceResponse {
    /** Response DTO representing requirement set version data */
    data?: RequirementSetVersionDto | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** Request DTO representing requirements search filter */
export class RequirementsInScopeRequestV2Dto implements IRequirementsInScopeRequestV2Dto {
    /** Type of requirement */
    type?: string | undefined;
    /** Exact name of the requirement */
    name?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    category?: string[] | undefined;
    /** Jurisdictions of the requirement in specific version. Null versionId will get the latest. */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** Mandatory flag of the requirement */
    isMandatory?: boolean | undefined;
    /** Type of entity */
    entityType?: string | undefined;
    /** Materiality flag of the requirement */
    isMaterialData?: boolean | undefined;
    /** Sensitive data flag of the requirement */
    isSensitiveData?: boolean | undefined;
    /** Data field definition */
    dataField?: DataFieldDto | undefined;
    /** Requirement is data indexed for search flag */
    isIndexable?: boolean | undefined;
    /** Include conditions flag.
If true, include the Requirements containing conditions.
If false, only the Requirements without conditions will be returned.
<example>false</example> */
    includeConditions?: boolean;
    /** Target entity */
    targetEntity?: string | undefined;
    /** Filter requirements containing conditional values only by basic properties: Target entity and Entity type */
    disableFilteringForConditionalValues?: boolean;
    /** Disable Requirements deduplication based on data key */
    disableDeduplication?: boolean;

    constructor(data?: IRequirementsInScopeRequestV2Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.name = _data["name"];
            if (Array.isArray(_data["category"])) {
                this.category = [] as any;
                for (let item of _data["category"])
                    this.category!.push(item);
            }
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(VersionedJurisdictionDto.fromJS(item));
            }
            this.isMandatory = _data["isMandatory"];
            this.entityType = _data["entityType"];
            this.isMaterialData = _data["isMaterialData"];
            this.isSensitiveData = _data["isSensitiveData"];
            this.dataField = _data["dataField"] ? DataFieldDto.fromJS(_data["dataField"]) : <any>undefined;
            this.isIndexable = _data["isIndexable"];
            this.includeConditions = _data["includeConditions"];
            this.targetEntity = _data["targetEntity"];
            this.disableFilteringForConditionalValues = _data["disableFilteringForConditionalValues"];
            this.disableDeduplication = _data["disableDeduplication"];
        }
    }

    static fromJS(data: any): RequirementsInScopeRequestV2Dto {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementsInScopeRequestV2Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["name"] = this.name;
        if (Array.isArray(this.category)) {
            data["category"] = [];
            for (let item of this.category)
                data["category"].push(item);
        }
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item.toJSON());
        }
        data["isMandatory"] = this.isMandatory;
        data["entityType"] = this.entityType;
        data["isMaterialData"] = this.isMaterialData;
        data["isSensitiveData"] = this.isSensitiveData;
        data["dataField"] = this.dataField ? this.dataField.toJSON() : <any>undefined;
        data["isIndexable"] = this.isIndexable;
        data["includeConditions"] = this.includeConditions;
        data["targetEntity"] = this.targetEntity;
        data["disableFilteringForConditionalValues"] = this.disableFilteringForConditionalValues;
        data["disableDeduplication"] = this.disableDeduplication;
        return data;
    }
}

/** Request DTO representing requirements search filter */
export interface IRequirementsInScopeRequestV2Dto {
    /** Type of requirement */
    type?: string | undefined;
    /** Exact name of the requirement */
    name?: string | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    category?: string[] | undefined;
    /** Jurisdictions of the requirement in specific version. Null versionId will get the latest. */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** Mandatory flag of the requirement */
    isMandatory?: boolean | undefined;
    /** Type of entity */
    entityType?: string | undefined;
    /** Materiality flag of the requirement */
    isMaterialData?: boolean | undefined;
    /** Sensitive data flag of the requirement */
    isSensitiveData?: boolean | undefined;
    /** Data field definition */
    dataField?: DataFieldDto | undefined;
    /** Requirement is data indexed for search flag */
    isIndexable?: boolean | undefined;
    /** Include conditions flag.
If true, include the Requirements containing conditions.
If false, only the Requirements without conditions will be returned.
<example>false</example> */
    includeConditions?: boolean;
    /** Target entity */
    targetEntity?: string | undefined;
    /** Filter requirements containing conditional values only by basic properties: Target entity and Entity type */
    disableFilteringForConditionalValues?: boolean;
    /** Disable Requirements deduplication based on data key */
    disableDeduplication?: boolean;
}

/** Service request data */
export class RequirementsInScopeRequestV2DtoServiceRequest implements IRequirementsInScopeRequestV2DtoServiceRequest {
    /** Request DTO representing requirements search filter */
    data?: RequirementsInScopeRequestV2Dto | undefined;

    constructor(data?: IRequirementsInScopeRequestV2DtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? RequirementsInScopeRequestV2Dto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RequirementsInScopeRequestV2DtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RequirementsInScopeRequestV2DtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface IRequirementsInScopeRequestV2DtoServiceRequest {
    /** Request DTO representing requirements search filter */
    data?: RequirementsInScopeRequestV2Dto | undefined;
}

/** Request DTO representing requirements search filter */
export class SearchRequirementsDto implements ISearchRequirementsDto {
    /** Exact name of the requirement */
    name?: string | undefined;
    /** Type of requirement */
    type?: string | undefined;
    /** Jurisdictions of the requirement in specific version. Null versionId will get the latest. */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    category?: string[] | undefined;
    /** Type of entity */
    entityType?: string | undefined;
    /** Mandatory flag of the requirement */
    isMandatory?: boolean | undefined;
    /** Sensitive data flag of the requirement */
    isSensitiveData?: boolean | undefined;
    /** Materiality flag of the requirement */
    isMaterialData?: boolean | undefined;
    /** Requirement is data indexed for search flag */
    isIndexable?: boolean | undefined;
    /** Data field definition */
    dataField?: DataFieldDto | undefined;
    /** Target entity */
    targetEntity?: string | undefined;
    /** Include conditions flag.
If true, include the Requirements containing conditions.
If false, only the Requirements without conditions will be returned.
<example>false</example> */
    includeConditions?: boolean;

    constructor(data?: ISearchRequirementsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            if (Array.isArray(_data["jurisdictions"])) {
                this.jurisdictions = [] as any;
                for (let item of _data["jurisdictions"])
                    this.jurisdictions!.push(VersionedJurisdictionDto.fromJS(item));
            }
            if (Array.isArray(_data["category"])) {
                this.category = [] as any;
                for (let item of _data["category"])
                    this.category!.push(item);
            }
            this.entityType = _data["entityType"];
            this.isMandatory = _data["isMandatory"];
            this.isSensitiveData = _data["isSensitiveData"];
            this.isMaterialData = _data["isMaterialData"];
            this.isIndexable = _data["isIndexable"];
            this.dataField = _data["dataField"] ? DataFieldDto.fromJS(_data["dataField"]) : <any>undefined;
            this.targetEntity = _data["targetEntity"];
            this.includeConditions = _data["includeConditions"];
        }
    }

    static fromJS(data: any): SearchRequirementsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequirementsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        if (Array.isArray(this.jurisdictions)) {
            data["jurisdictions"] = [];
            for (let item of this.jurisdictions)
                data["jurisdictions"].push(item.toJSON());
        }
        if (Array.isArray(this.category)) {
            data["category"] = [];
            for (let item of this.category)
                data["category"].push(item);
        }
        data["entityType"] = this.entityType;
        data["isMandatory"] = this.isMandatory;
        data["isSensitiveData"] = this.isSensitiveData;
        data["isMaterialData"] = this.isMaterialData;
        data["isIndexable"] = this.isIndexable;
        data["dataField"] = this.dataField ? this.dataField.toJSON() : <any>undefined;
        data["targetEntity"] = this.targetEntity;
        data["includeConditions"] = this.includeConditions;
        return data;
    }
}

/** Request DTO representing requirements search filter */
export interface ISearchRequirementsDto {
    /** Exact name of the requirement */
    name?: string | undefined;
    /** Type of requirement */
    type?: string | undefined;
    /** Jurisdictions of the requirement in specific version. Null versionId will get the latest. */
    jurisdictions?: VersionedJurisdictionDto[] | undefined;
    /** List of requirement category e.g. ["Basic Details", "Enrich Details"] */
    category?: string[] | undefined;
    /** Type of entity */
    entityType?: string | undefined;
    /** Mandatory flag of the requirement */
    isMandatory?: boolean | undefined;
    /** Sensitive data flag of the requirement */
    isSensitiveData?: boolean | undefined;
    /** Materiality flag of the requirement */
    isMaterialData?: boolean | undefined;
    /** Requirement is data indexed for search flag */
    isIndexable?: boolean | undefined;
    /** Data field definition */
    dataField?: DataFieldDto | undefined;
    /** Target entity */
    targetEntity?: string | undefined;
    /** Include conditions flag.
If true, include the Requirements containing conditions.
If false, only the Requirements without conditions will be returned.
<example>false</example> */
    includeConditions?: boolean;
}

/** Service request data */
export class SearchRequirementsDtoServiceRequest implements ISearchRequirementsDtoServiceRequest {
    /** Request DTO representing requirements search filter */
    data?: SearchRequirementsDto | undefined;

    constructor(data?: ISearchRequirementsDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SearchRequirementsDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchRequirementsDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequirementsDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Service request data */
export interface ISearchRequirementsDtoServiceRequest {
    /** Request DTO representing requirements search filter */
    data?: SearchRequirementsDto | undefined;
}

/** Service response data */
export class ServiceResponse implements IServiceResponse {
    /** The service response DTO */
    data?: string | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IServiceResponse {
    /** The service response DTO */
    data?: string | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

/** The message associated to the service response */
export class ServiceResponseMessage implements IServiceResponseMessage {
    /** The message */
    message?: string | undefined;
    /** Type of the message
One of Info, Warning, Error, Forbidden */
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

/** The message associated to the service response */
export interface IServiceResponseMessage {
    /** The message */
    message?: string | undefined;
    /** Type of the message
One of Info, Warning, Error, Forbidden */
    type?: string | undefined;
}

export class Signee implements ISignee {
    subject?: string | undefined;
    successor?: Approver | undefined;
    action?: ApproveAction | undefined;
    readonly hasProcessedRequest?: boolean;

    constructor(data?: ISignee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.successor = _data["successor"] ? Approver.fromJS(_data["successor"]) : <any>undefined;
            this.action = _data["action"] ? ApproveAction.fromJS(_data["action"]) : <any>undefined;
            (<any>this).hasProcessedRequest = _data["hasProcessedRequest"];
        }
    }

    static fromJS(data: any): Signee {
        data = typeof data === 'object' ? data : {};
        let result = new Signee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["successor"] = this.successor ? this.successor.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["hasProcessedRequest"] = this.hasProcessedRequest;
        return data;
    }
}

export interface ISignee {
    subject?: string | undefined;
    successor?: Approver | undefined;
    action?: ApproveAction | undefined;
    hasProcessedRequest?: boolean;
}

export class SinglePropertyDto extends PropertyDto implements ISinglePropertyDto {
    value?: string | undefined;

    constructor(data?: ISinglePropertyDto) {
        super(data);
        this._discriminator = "Single";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SinglePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SinglePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface ISinglePropertyDto extends IPropertyDto {
    value?: string | undefined;
}

export class SpecialCharactersRule implements ISpecialCharactersRule {
    active?: boolean;
    message?: string | undefined;
    excludedCharacters?: string[] | undefined;

    constructor(data?: ISpecialCharactersRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            if (Array.isArray(_data["excludedCharacters"])) {
                this.excludedCharacters = [] as any;
                for (let item of _data["excludedCharacters"])
                    this.excludedCharacters!.push(item);
            }
        }
    }

    static fromJS(data: any): SpecialCharactersRule {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialCharactersRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        if (Array.isArray(this.excludedCharacters)) {
            data["excludedCharacters"] = [];
            for (let item of this.excludedCharacters)
                data["excludedCharacters"].push(item);
        }
        return data;
    }
}

export interface ISpecialCharactersRule {
    active?: boolean;
    message?: string | undefined;
    excludedCharacters?: string[] | undefined;
}

export class ValidationData implements IValidationData {
    isMandatory?: BasicRule | undefined;
    specialCharacters?: SpecialCharactersRule | undefined;
    noNumbers?: BasicRule | undefined;
    onlyInteger?: BasicRule | undefined;
    noNegative?: BasicRule | undefined;
    onlyDecimal?: BasicRule | undefined;
    regex?: RegexRule | undefined;
    characterLimit?: ValueLimitRule | undefined;
    numberLimit?: ValueLimitRule | undefined;
    noFutureDates?: BasicRule | undefined;
    noPastDates?: BasicRule | undefined;
    dateLimit?: DateLimitRule | undefined;
    multiSelectLimit?: ValueLimitRule | undefined;
    collectionMinimumCount?: CollectionMinimumCountRule | undefined;
    collectionMaximumCount?: CollectionMaximumCountRule | undefined;

    constructor(data?: IValidationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isMandatory = _data["isMandatory"] ? BasicRule.fromJS(_data["isMandatory"]) : <any>undefined;
            this.specialCharacters = _data["specialCharacters"] ? SpecialCharactersRule.fromJS(_data["specialCharacters"]) : <any>undefined;
            this.noNumbers = _data["noNumbers"] ? BasicRule.fromJS(_data["noNumbers"]) : <any>undefined;
            this.onlyInteger = _data["onlyInteger"] ? BasicRule.fromJS(_data["onlyInteger"]) : <any>undefined;
            this.noNegative = _data["noNegative"] ? BasicRule.fromJS(_data["noNegative"]) : <any>undefined;
            this.onlyDecimal = _data["onlyDecimal"] ? BasicRule.fromJS(_data["onlyDecimal"]) : <any>undefined;
            this.regex = _data["regex"] ? RegexRule.fromJS(_data["regex"]) : <any>undefined;
            this.characterLimit = _data["characterLimit"] ? ValueLimitRule.fromJS(_data["characterLimit"]) : <any>undefined;
            this.numberLimit = _data["numberLimit"] ? ValueLimitRule.fromJS(_data["numberLimit"]) : <any>undefined;
            this.noFutureDates = _data["noFutureDates"] ? BasicRule.fromJS(_data["noFutureDates"]) : <any>undefined;
            this.noPastDates = _data["noPastDates"] ? BasicRule.fromJS(_data["noPastDates"]) : <any>undefined;
            this.dateLimit = _data["dateLimit"] ? DateLimitRule.fromJS(_data["dateLimit"]) : <any>undefined;
            this.multiSelectLimit = _data["multiSelectLimit"] ? ValueLimitRule.fromJS(_data["multiSelectLimit"]) : <any>undefined;
            this.collectionMinimumCount = _data["collectionMinimumCount"] ? CollectionMinimumCountRule.fromJS(_data["collectionMinimumCount"]) : <any>undefined;
            this.collectionMaximumCount = _data["collectionMaximumCount"] ? CollectionMaximumCountRule.fromJS(_data["collectionMaximumCount"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidationData {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMandatory"] = this.isMandatory ? this.isMandatory.toJSON() : <any>undefined;
        data["specialCharacters"] = this.specialCharacters ? this.specialCharacters.toJSON() : <any>undefined;
        data["noNumbers"] = this.noNumbers ? this.noNumbers.toJSON() : <any>undefined;
        data["onlyInteger"] = this.onlyInteger ? this.onlyInteger.toJSON() : <any>undefined;
        data["noNegative"] = this.noNegative ? this.noNegative.toJSON() : <any>undefined;
        data["onlyDecimal"] = this.onlyDecimal ? this.onlyDecimal.toJSON() : <any>undefined;
        data["regex"] = this.regex ? this.regex.toJSON() : <any>undefined;
        data["characterLimit"] = this.characterLimit ? this.characterLimit.toJSON() : <any>undefined;
        data["numberLimit"] = this.numberLimit ? this.numberLimit.toJSON() : <any>undefined;
        data["noFutureDates"] = this.noFutureDates ? this.noFutureDates.toJSON() : <any>undefined;
        data["noPastDates"] = this.noPastDates ? this.noPastDates.toJSON() : <any>undefined;
        data["dateLimit"] = this.dateLimit ? this.dateLimit.toJSON() : <any>undefined;
        data["multiSelectLimit"] = this.multiSelectLimit ? this.multiSelectLimit.toJSON() : <any>undefined;
        data["collectionMinimumCount"] = this.collectionMinimumCount ? this.collectionMinimumCount.toJSON() : <any>undefined;
        data["collectionMaximumCount"] = this.collectionMaximumCount ? this.collectionMaximumCount.toJSON() : <any>undefined;
        return data;
    }
}

export interface IValidationData {
    isMandatory?: BasicRule | undefined;
    specialCharacters?: SpecialCharactersRule | undefined;
    noNumbers?: BasicRule | undefined;
    onlyInteger?: BasicRule | undefined;
    noNegative?: BasicRule | undefined;
    onlyDecimal?: BasicRule | undefined;
    regex?: RegexRule | undefined;
    characterLimit?: ValueLimitRule | undefined;
    numberLimit?: ValueLimitRule | undefined;
    noFutureDates?: BasicRule | undefined;
    noPastDates?: BasicRule | undefined;
    dateLimit?: DateLimitRule | undefined;
    multiSelectLimit?: ValueLimitRule | undefined;
    collectionMinimumCount?: CollectionMinimumCountRule | undefined;
    collectionMaximumCount?: CollectionMaximumCountRule | undefined;
}

export class ValidationRule implements IValidationRule {
    id?: string;
    setId?: string;
    propertyId?: string;
    propertyName?: string | undefined;
    friendlyName?: string | undefined;
    validationType?: string | undefined;
    isDataGroup?: boolean;
    dataGroupId?: string | undefined;
    validationData?: ValidationData | undefined;

    constructor(data?: IValidationRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.setId = _data["setId"];
            this.propertyId = _data["propertyId"];
            this.propertyName = _data["propertyName"];
            this.friendlyName = _data["friendlyName"];
            this.validationType = _data["validationType"];
            this.isDataGroup = _data["isDataGroup"];
            this.dataGroupId = _data["dataGroupId"];
            this.validationData = _data["validationData"] ? ValidationData.fromJS(_data["validationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidationRule {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["setId"] = this.setId;
        data["propertyId"] = this.propertyId;
        data["propertyName"] = this.propertyName;
        data["friendlyName"] = this.friendlyName;
        data["validationType"] = this.validationType;
        data["isDataGroup"] = this.isDataGroup;
        data["dataGroupId"] = this.dataGroupId;
        data["validationData"] = this.validationData ? this.validationData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IValidationRule {
    id?: string;
    setId?: string;
    propertyId?: string;
    propertyName?: string | undefined;
    friendlyName?: string | undefined;
    validationType?: string | undefined;
    isDataGroup?: boolean;
    dataGroupId?: string | undefined;
    validationData?: ValidationData | undefined;
}

/** Service response data */
export class ValidationRuleListServiceResponse implements IValidationRuleListServiceResponse {
    /** The service response DTO */
    data?: ValidationRule[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IValidationRuleListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ValidationRule.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationRuleListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationRuleListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

/** Service response data */
export interface IValidationRuleListServiceResponse {
    /** The service response DTO */
    data?: ValidationRule[] | undefined;
    /** List of Fenergo.Nebula.Platform.Core.Response.ServiceResponseMessage associated to the service response */
    messages?: ServiceResponseMessage[] | undefined;
}

export class ValueLimitRule implements IValueLimitRule {
    active?: boolean;
    message?: string | undefined;
    minValue?: number | undefined;
    maxValue?: number | undefined;

    constructor(data?: IValueLimitRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.message = _data["message"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
        }
    }

    static fromJS(data: any): ValueLimitRule {
        data = typeof data === 'object' ? data : {};
        let result = new ValueLimitRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["message"] = this.message;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        return data;
    }
}

export interface IValueLimitRule {
    active?: boolean;
    message?: string | undefined;
    minValue?: number | undefined;
    maxValue?: number | undefined;
}

export enum VersionStatus {
    Draft = "Draft",
    Pending = "Pending",
    Rejected = "Rejected",
    Published = "Published",
    Archived = "Archived",
    Deleted = "Deleted",
}

export class VersionedJurisdictionDto implements IVersionedJurisdictionDto {
    /** Jurisdiction of the requirement */
    jurisdiction?: string | undefined;
    /** Id of the requirement version */
    versionId?: string | undefined;

    constructor(data?: IVersionedJurisdictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jurisdiction = _data["jurisdiction"];
            this.versionId = _data["versionId"];
        }
    }

    static fromJS(data: any): VersionedJurisdictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new VersionedJurisdictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jurisdiction"] = this.jurisdiction;
        data["versionId"] = this.versionId;
        return data;
    }
}

export interface IVersionedJurisdictionDto {
    /** Jurisdiction of the requirement */
    jurisdiction?: string | undefined;
    /** Id of the requirement version */
    versionId?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}