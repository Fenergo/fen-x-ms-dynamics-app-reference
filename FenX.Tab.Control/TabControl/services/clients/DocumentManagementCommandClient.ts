//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * Save document metadata and generate the URL to upload the file
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The upload document request
     * @return An instance of the Fenergo.Nebula.DocumentManagement.Command.Application.Dto.CreateSignedUrlToUploadFileRequest class with some metadata that represent the file uploaded
     */
    createDocumentModel(x_TENANT_ID: string, body: CreateSignedUrlToUploadFileRequestServiceRequest | undefined): Promise<CreateSignedUrlToUploadFileResponseServiceResponse>;
    /**
     * Generate URL to upload the new document file
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The update document file request
     * @return Document Model updated successfully
     */
    updateFile(x_TENANT_ID: string, body: UpdateDocumentFileDtoV2ServiceRequest | undefined): Promise<UpdateDocumentFileResponseDtoServiceResponse>;
    /**
     * Update document model access layers
     * @param id Document model id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update document model access layers request
     * @return Success. Document model access layers updated
     */
    updateDocumentAccessLayers(id: string, x_TENANT_ID: string, body: UpdateDocumentAccessLayersDtoServiceRequest | undefined): Promise<void>;
    /**
     * Save document metadata and generate the URL to upload the file for multiple Document Requirements
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The upload multiple document requirements request
     * @return An instance of the Fenergo.Nebula.DocumentManagement.Command.Application.Dto.CreateSignedUrlToUploadFileMultipleRequirementsRequest class with some metadata that represent the files uploaded
     */
    createDocumentModelMultipleRequirements(x_TENANT_ID: string, body: CreateSignedUrlToUploadFileMultipleRequirementsRequestServiceRequest | undefined): Promise<CreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse>;
    /**
     * Clones Document Model which references Original Physical File
     * @param id Document model id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update document model access layers request
     * @return Success. Document model access layers updated
     */
    cloneDocumentModel(id: string, x_TENANT_ID: string, body: CloneDocumentModelDtoServiceRequest | undefined): Promise<CloneDocumentResponseDtoServiceResponse>;
    /**
     * Update Document Model Status
     * @param id Document model id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Document model status updated
     */
    updateDocumentModelStatusError(id: string, x_TENANT_ID: string): Promise<void>;
    /**
     * Updates a document
     * @param id The Id of the existing model to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The update document request
     * @return An instance of the Fenergo.Nebula.DocumentManagement.Command.Application.Dto.UpdateDocumentDto class which contains the properties to update on the document
     */
    updateDocument(id: string, x_TENANT_ID: string, body: UpdateDocumentDtoServiceRequest | undefined): Promise<void>;
    /**
     * Delete a document model
     * @param id The id of the document existing
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Document deleted successfully
     */
    deleteDocumentModel(id: string, x_TENANT_ID: string): Promise<void>;
    /**
     * Update the requirements linked to a document
     * @param id The Id of the existing model to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The list of requirements to update the document model with
     * @return Document Model updated successfully
     */
    updateRequirementIds(id: string, x_TENANT_ID: string, body: string[] | undefined): Promise<void>;
    /**
     * Update the requirement datakey linked to a document
     * @param id The Id of the existing model to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The datakey of requirement to update the document model with
     * @return Document Model updated successfully
     */
    updateDataKey(id: string, x_TENANT_ID: string, body: string | undefined): Promise<void>;
    /**
     * Creates a new DocumentRequirement.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) ServiceRequest with the DocumentRequirement to create
     * @return DocumentRequirementDto model created successfully
     */
    createDocumentRequirement(x_TENANT_ID: string, body: DocumentRequirementRequestDtoServiceRequest | undefined): Promise<DocumentRequirementResponseDtoServiceResponse>;
    /**
     * Updates an existing DocumentRequirement
     * @param id The Id of the existing model to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) ServiceRequest with the DocumentRequirement to update
     * @return DocumentRequirement Model updated successfully
     */
    updateDocumentRequirement(id: string, x_TENANT_ID: string, body: UpdateDocumentRequirementDtoServiceRequest | undefined): Promise<void>;
    /**
     * Sends a request with documents to external provider for eSignature.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) ServiceRequest with the documents and mandatory signers to send
     * @return DocumentSignatureResponseDto model created successfully
     */
    sendDocumentsForSignature(x_TENANT_ID: string, body: DocumentSignatureRequestDtoServiceRequest | undefined): Promise<DocumentSignatureResponseDtoServiceResponse>;
    /**
     * Save Provider status
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) 
     * @return Accepted
     */
    saveProviderStatus(providerId: string, x_TENANT_ID: string, body: BooleanServiceRequest | undefined): Promise<void>;
    /**
     * Save Configuration
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) 
     * @return Success. Provider added
     */
    saveProviderConfiguration(providerId: string, x_TENANT_ID: string, body: ProviderConfigurationDtoServiceRequest | undefined): Promise<SaveProviderConfigurationResponseDtoServiceResponse>;
    /**
     * Creates a new eSignatureDocumentRequirement.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) ServiceRequest with the DocumentRequirement to create
     * @return DocumentRequirementDto model created successfully
     */
    createESignatureDocumentRequirement(x_TENANT_ID: string, body: ESignatureDocumentRequirementRequestDtoServiceRequest | undefined): Promise<ESignatureDocumentRequirementResponseDtoServiceResponse>;
    /**
     * Updates an existing eSignatureDocumentRequirement
     * @param id The Id of the existing model to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) ServiceRequest with the DocumentRequirement to update
     * @return DocumentRequirement Model updated successfully
     */
    updateESignatureDocumentRequirement(id: string, x_TENANT_ID: string, body: UpdateESignatureDocumentRequirementDtoServiceRequest | undefined): Promise<void>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/documentmanagementcommand";

    }

    /**
     * Save document metadata and generate the URL to upload the file
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The upload document request
     * @return An instance of the Fenergo.Nebula.DocumentManagement.Command.Application.Dto.CreateSignedUrlToUploadFileRequest class with some metadata that represent the file uploaded
     */
    createDocumentModel(x_TENANT_ID: string, body: CreateSignedUrlToUploadFileRequestServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<CreateSignedUrlToUploadFileResponseServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/documentmanagement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDocumentModel(_response);
        });
    }

    protected processCreateDocumentModel(response: AxiosResponse): Promise<CreateSignedUrlToUploadFileResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = CreateSignedUrlToUploadFileResponseServiceResponse.fromJS(resultData202);
            return Promise.resolve<CreateSignedUrlToUploadFileResponseServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateSignedUrlToUploadFileResponseServiceResponse>(null as any);
    }

    /**
     * Generate URL to upload the new document file
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The update document file request
     * @return Document Model updated successfully
     */
    updateFile(x_TENANT_ID: string, body: UpdateDocumentFileDtoV2ServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<UpdateDocumentFileResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/documentmanagement/updateFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFile(_response);
        });
    }

    protected processUpdateFile(response: AxiosResponse): Promise<UpdateDocumentFileResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = UpdateDocumentFileResponseDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<UpdateDocumentFileResponseDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateDocumentFileResponseDtoServiceResponse>(null as any);
    }

    /**
     * Update document model access layers
     * @param id Document model id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update document model access layers request
     * @return Success. Document model access layers updated
     */
    updateDocumentAccessLayers(id: string, x_TENANT_ID: string, body: UpdateDocumentAccessLayersDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/documentmanagement/{id}/access-layers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDocumentAccessLayers(_response);
        });
    }

    protected processUpdateDocumentAccessLayers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Save document metadata and generate the URL to upload the file for multiple Document Requirements
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The upload multiple document requirements request
     * @return An instance of the Fenergo.Nebula.DocumentManagement.Command.Application.Dto.CreateSignedUrlToUploadFileMultipleRequirementsRequest class with some metadata that represent the files uploaded
     */
    createDocumentModelMultipleRequirements(x_TENANT_ID: string, body: CreateSignedUrlToUploadFileMultipleRequirementsRequestServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<CreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/documentmanagement/CreateDocumentModelMultipleRequirements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDocumentModelMultipleRequirements(_response);
        });
    }

    protected processCreateDocumentModelMultipleRequirements(response: AxiosResponse): Promise<CreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = CreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse.fromJS(resultData202);
            return Promise.resolve<CreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse>(null as any);
    }

    /**
     * Clones Document Model which references Original Physical File
     * @param id Document model id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) Update document model access layers request
     * @return Success. Document model access layers updated
     */
    cloneDocumentModel(id: string, x_TENANT_ID: string, body: CloneDocumentModelDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<CloneDocumentResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/documentmanagement/{id}/clone";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCloneDocumentModel(_response);
        });
    }

    protected processCloneDocumentModel(response: AxiosResponse): Promise<CloneDocumentResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = CloneDocumentResponseDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<CloneDocumentResponseDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CloneDocumentResponseDtoServiceResponse>(null as any);
    }

    /**
     * Update Document Model Status
     * @param id Document model id
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Success. Document model status updated
     */
    updateDocumentModelStatusError(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/documentmanagement/error/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDocumentModelStatusError(_response);
        });
    }

    protected processUpdateDocumentModelStatusError(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectServiceResponse.fromJS(resultData404);
            return throwException("Resource not found", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Updates a document
     * @param id The Id of the existing model to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The update document request
     * @return An instance of the Fenergo.Nebula.DocumentManagement.Command.Application.Dto.UpdateDocumentDto class which contains the properties to update on the document
     */
    updateDocument(id: string, x_TENANT_ID: string, body: UpdateDocumentDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/documentmanagement/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDocument(_response);
        });
    }

    protected processUpdateDocument(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a document model
     * @param id The id of the document existing
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @return Document deleted successfully
     */
    deleteDocumentModel(id: string, x_TENANT_ID: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/documentmanagement/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteDocumentModel(_response);
        });
    }

    protected processDeleteDocumentModel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Document not found", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update the requirements linked to a document
     * @param id The Id of the existing model to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The list of requirements to update the document model with
     * @return Document Model updated successfully
     */
    updateRequirementIds(id: string, x_TENANT_ID: string, body: string[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/documentmanagement/{id}/requirement-ids";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRequirementIds(_response);
        });
    }

    protected processUpdateRequirementIds(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update the requirement datakey linked to a document
     * @param id The Id of the existing model to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) The datakey of requirement to update the document model with
     * @return Document Model updated successfully
     */
    updateDataKey(id: string, x_TENANT_ID: string, body: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/documentmanagement/{id}/datakey";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDataKey(_response);
        });
    }

    protected processUpdateDataKey(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Creates a new DocumentRequirement.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) ServiceRequest with the DocumentRequirement to create
     * @return DocumentRequirementDto model created successfully
     */
    createDocumentRequirement(x_TENANT_ID: string, body: DocumentRequirementRequestDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentRequirementResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/documentrequirement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDocumentRequirement(_response);
        });
    }

    protected processCreateDocumentRequirement(response: AxiosResponse): Promise<DocumentRequirementResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = DocumentRequirementResponseDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<DocumentRequirementResponseDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentRequirementResponseDtoServiceResponse>(null as any);
    }

    /**
     * Updates an existing DocumentRequirement
     * @param id The Id of the existing model to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) ServiceRequest with the DocumentRequirement to update
     * @return DocumentRequirement Model updated successfully
     */
    updateDocumentRequirement(id: string, x_TENANT_ID: string, body: UpdateDocumentRequirementDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/documentrequirement/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDocumentRequirement(_response);
        });
    }

    protected processUpdateDocumentRequirement(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorModelListServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Sends a request with documents to external provider for eSignature.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) ServiceRequest with the documents and mandatory signers to send
     * @return DocumentSignatureResponseDto model created successfully
     */
    sendDocumentsForSignature(x_TENANT_ID: string, body: DocumentSignatureRequestDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentSignatureResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/esignature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendDocumentsForSignature(_response);
        });
    }

    protected processSendDocumentsForSignature(response: AxiosResponse): Promise<DocumentSignatureResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = DocumentSignatureResponseDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<DocumentSignatureResponseDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("An exception occurred while processing the command", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentSignatureResponseDtoServiceResponse>(null as any);
    }

    /**
     * Save Provider status
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) 
     * @return Accepted
     */
    saveProviderStatus(providerId: string, x_TENANT_ID: string, body: BooleanServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/esignatureconfiguration/provider/{providerId}/status";
        if (providerId === undefined || providerId === null)
            throw new Error("The parameter 'providerId' must be defined.");
        url_ = url_.replace("{providerId}", encodeURIComponent("" + providerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveProviderStatus(_response);
        });
    }

    protected processSaveProviderStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Save Configuration
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) 
     * @return Success. Provider added
     */
    saveProviderConfiguration(providerId: string, x_TENANT_ID: string, body: ProviderConfigurationDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<SaveProviderConfigurationResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/esignatureconfiguration/provider/{providerId}/configuration";
        if (providerId === undefined || providerId === null)
            throw new Error("The parameter 'providerId' must be defined.");
        url_ = url_.replace("{providerId}", encodeURIComponent("" + providerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveProviderConfiguration(_response);
        });
    }

    protected processSaveProviderConfiguration(response: AxiosResponse): Promise<SaveProviderConfigurationResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = SaveProviderConfigurationResponseDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<SaveProviderConfigurationResponseDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaveProviderConfigurationResponseDtoServiceResponse>(null as any);
    }

    /**
     * Creates a new eSignatureDocumentRequirement.
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) ServiceRequest with the DocumentRequirement to create
     * @return DocumentRequirementDto model created successfully
     */
    createESignatureDocumentRequirement(x_TENANT_ID: string, body: ESignatureDocumentRequirementRequestDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<ESignatureDocumentRequirementResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/api/v2/esignaturedocumentrequirement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateESignatureDocumentRequirement(_response);
        });
    }

    protected processCreateESignatureDocumentRequirement(response: AxiosResponse): Promise<ESignatureDocumentRequirementResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = ESignatureDocumentRequirementResponseDtoServiceResponse.fromJS(resultData202);
            return Promise.resolve<ESignatureDocumentRequirementResponseDtoServiceResponse>(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ESignatureDocumentRequirementResponseDtoServiceResponse>(null as any);
    }

    /**
     * Updates an existing eSignatureDocumentRequirement
     * @param id The Id of the existing model to update
     * @param x_TENANT_ID The UiD of the tenant representing organization
     * @param body (optional) ServiceRequest with the DocumentRequirement to update
     * @return DocumentRequirement Model updated successfully
     */
    updateESignatureDocumentRequirement(id: string, x_TENANT_ID: string, body: UpdateESignatureDocumentRequirementDtoServiceRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/esignaturedocumentrequirement/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-TENANT-ID": x_TENANT_ID !== undefined && x_TENANT_ID !== null ? "" + x_TENANT_ID : "",
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateESignatureDocumentRequirement(_response);
        });
    }

    protected processUpdateESignatureDocumentRequirement(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ServiceResponse.fromJS(resultData400);
            return throwException("Bad request. The request has missing/invalid values", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User is not authorized to perform this request", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ObjectServiceResponse.fromJS(resultData403);
            return throwException("Access to resource is forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectServiceResponse.fromJS(resultData500);
            return throwException("Internal server exception. Please, contact your provider.", status, _responseText, _headers, result500);

        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410  = _responseText;
            result410 = StringServiceResponse.fromJS(resultData410);
            return throwException("Terminated obsolete endpoint", status, _responseText, _headers, result410);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

/** DTO representing access layers attached */
export class AccessLayerDto implements IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;

    constructor(data?: IAccessLayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["geographic"])) {
                this.geographic = [] as any;
                for (let item of _data["geographic"])
                    this.geographic!.push(item);
            }
            if (Array.isArray(_data["businessRelated"])) {
                this.businessRelated = [] as any;
                for (let item of _data["businessRelated"])
                    this.businessRelated!.push(item);
            }
        }
    }

    static fromJS(data: any): AccessLayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessLayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.geographic)) {
            data["geographic"] = [];
            for (let item of this.geographic)
                data["geographic"].push(item);
        }
        if (Array.isArray(this.businessRelated)) {
            data["businessRelated"] = [];
            for (let item of this.businessRelated)
                data["businessRelated"].push(item);
        }
        return data;
    }
}

/** DTO representing access layers attached */
export interface IAccessLayerDto {
    /** Collection of geographic access layers */
    geographic?: string[] | undefined;
    /** Collection of business related access layers */
    businessRelated?: string[] | undefined;
}

export class BooleanServiceRequest implements IBooleanServiceRequest {
    data?: boolean;

    constructor(data?: IBooleanServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): BooleanServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        return data;
    }
}

export interface IBooleanServiceRequest {
    data?: boolean;
}

/** Contains the Document Model Attributes needed to clone a document to fulfill a requirement */
export class CloneDocumentModelDto implements ICloneDocumentModelDto {
    /** Id of the document to be cloned */
    id?: string;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** Id of the Entity the document is associated to */
    entityId?: string | undefined;
    /** Id of the journey the document is associated to */
    journeyId?: string | undefined;
    /** Hash Set of Document Requirement Ids from FenX to link the document to document requirements */
    documentRequirementIds?: string[] | undefined;
    /** Document access layers determining the access to the entity draft and related entity */
    accessLayers?: AccessLayerDto | undefined;

    constructor(data?: ICloneDocumentModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.documentDataKey = _data["DocumentDataKey"];
            this.entityId = _data["EntityId"];
            this.journeyId = _data["JourneyId"];
            if (Array.isArray(_data["DocumentRequirementIds"])) {
                this.documentRequirementIds = [] as any;
                for (let item of _data["DocumentRequirementIds"])
                    this.documentRequirementIds!.push(item);
            }
            this.accessLayers = _data["AccessLayers"] ? AccessLayerDto.fromJS(_data["AccessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CloneDocumentModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CloneDocumentModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DocumentDataKey"] = this.documentDataKey;
        data["EntityId"] = this.entityId;
        data["JourneyId"] = this.journeyId;
        if (Array.isArray(this.documentRequirementIds)) {
            data["DocumentRequirementIds"] = [];
            for (let item of this.documentRequirementIds)
                data["DocumentRequirementIds"].push(item);
        }
        data["AccessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        return data;
    }
}

/** Contains the Document Model Attributes needed to clone a document to fulfill a requirement */
export interface ICloneDocumentModelDto {
    /** Id of the document to be cloned */
    id?: string;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** Id of the Entity the document is associated to */
    entityId?: string | undefined;
    /** Id of the journey the document is associated to */
    journeyId?: string | undefined;
    /** Hash Set of Document Requirement Ids from FenX to link the document to document requirements */
    documentRequirementIds?: string[] | undefined;
    /** Document access layers determining the access to the entity draft and related entity */
    accessLayers?: AccessLayerDto | undefined;
}

export class CloneDocumentModelDtoServiceRequest implements ICloneDocumentModelDtoServiceRequest {
    /** Contains the Document Model Attributes needed to clone a document to fulfill a requirement */
    data?: CloneDocumentModelDto | undefined;

    constructor(data?: ICloneDocumentModelDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CloneDocumentModelDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CloneDocumentModelDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CloneDocumentModelDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICloneDocumentModelDtoServiceRequest {
    /** Contains the Document Model Attributes needed to clone a document to fulfill a requirement */
    data?: CloneDocumentModelDto | undefined;
}

/** Contains the Document Model Attributes to return from the document clone command */
export class CloneDocumentResponseDto implements ICloneDocumentResponseDto {
    /** Id of the document that was cloned */
    id?: string;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** Id of the Entity the document is associated to */
    entityId?: string | undefined;
    /** Id of the journey the document is associated to */
    journeyId?: string | undefined;
    /** Hash Set of Document Requirement Ids from FenX to link the document to document requirements */
    documentRequirementIds?: string[] | undefined;
    /** The Reference key for the physical File */
    documentKey?: string | undefined;
    /** The type of the document */
    documentType?: string | undefined;

    constructor(data?: ICloneDocumentResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.documentDataKey = _data["DocumentDataKey"];
            this.entityId = _data["EntityId"];
            this.journeyId = _data["JourneyId"];
            if (Array.isArray(_data["DocumentRequirementIds"])) {
                this.documentRequirementIds = [] as any;
                for (let item of _data["DocumentRequirementIds"])
                    this.documentRequirementIds!.push(item);
            }
            this.documentKey = _data["DocumentKey"];
            this.documentType = _data["documentType"];
        }
    }

    static fromJS(data: any): CloneDocumentResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CloneDocumentResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DocumentDataKey"] = this.documentDataKey;
        data["EntityId"] = this.entityId;
        data["JourneyId"] = this.journeyId;
        if (Array.isArray(this.documentRequirementIds)) {
            data["DocumentRequirementIds"] = [];
            for (let item of this.documentRequirementIds)
                data["DocumentRequirementIds"].push(item);
        }
        data["DocumentKey"] = this.documentKey;
        data["documentType"] = this.documentType;
        return data;
    }
}

/** Contains the Document Model Attributes to return from the document clone command */
export interface ICloneDocumentResponseDto {
    /** Id of the document that was cloned */
    id?: string;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** Id of the Entity the document is associated to */
    entityId?: string | undefined;
    /** Id of the journey the document is associated to */
    journeyId?: string | undefined;
    /** Hash Set of Document Requirement Ids from FenX to link the document to document requirements */
    documentRequirementIds?: string[] | undefined;
    /** The Reference key for the physical File */
    documentKey?: string | undefined;
    /** The type of the document */
    documentType?: string | undefined;
}

export class CloneDocumentResponseDtoServiceResponse implements ICloneDocumentResponseDtoServiceResponse {
    /** Contains the Document Model Attributes to return from the document clone command */
    data?: CloneDocumentResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ICloneDocumentResponseDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CloneDocumentResponseDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CloneDocumentResponseDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CloneDocumentResponseDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICloneDocumentResponseDtoServiceResponse {
    /** Contains the Document Model Attributes to return from the document clone command */
    data?: CloneDocumentResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Metadata needed to create Document models to fulfill multiple requirements and generate signed Url to upload file. Contains all properties needed to fill the metadata of the document being uploaded. */
export class CreateSignedUrlToUploadFileMultipleRequirementsRequest implements ICreateSignedUrlToUploadFileMultipleRequirementsRequest {
    /** Original file name */
    fileName!: string;
    /** Entity Id from FenX to link the document with the entity */
    entityId!: string;
    /** Journey Id from FenX to link the document with the journey */
    journeyId?: string | undefined;
    /** The type of the document */
    documentType?: string | undefined;
    /** The friendly name of the document */
    friendlyName?: string | undefined;
    /** List of Document Requirements to be fulfilled by this document */
    documentRequirements?: DocumentRequirementDto[] | undefined;
    /** Is the document for eSignature */
    isDocumentForESignature?: boolean | undefined;
    /** Does document come from eSignature provider */
    comesFromESignatureProvider?: boolean | undefined;
    /** Custom document properties. */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Document access layers. Can be only additive in relation to the PolicyEnforcedAccessLayers */
    accessLayers?: AccessLayerDto | undefined;
    /** Access layers enforced by policy. The minimal set of access layers. The property is immutable */
    policyEnforcedAccessLayers?: AccessLayerDto | undefined;

    constructor(data?: ICreateSignedUrlToUploadFileMultipleRequirementsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.entityId = _data["entityId"];
            this.journeyId = _data["journeyId"];
            this.documentType = _data["documentType"];
            this.friendlyName = _data["friendlyName"];
            if (Array.isArray(_data["documentRequirements"])) {
                this.documentRequirements = [] as any;
                for (let item of _data["documentRequirements"])
                    this.documentRequirements!.push(DocumentRequirementDto.fromJS(item));
            }
            this.isDocumentForESignature = _data["isDocumentForESignature"];
            this.comesFromESignatureProvider = _data["comesFromESignatureProvider"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.policyEnforcedAccessLayers = _data["policyEnforcedAccessLayers"] ? AccessLayerDto.fromJS(_data["policyEnforcedAccessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSignedUrlToUploadFileMultipleRequirementsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSignedUrlToUploadFileMultipleRequirementsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["entityId"] = this.entityId;
        data["journeyId"] = this.journeyId;
        data["documentType"] = this.documentType;
        data["friendlyName"] = this.friendlyName;
        if (Array.isArray(this.documentRequirements)) {
            data["documentRequirements"] = [];
            for (let item of this.documentRequirements)
                data["documentRequirements"].push(item.toJSON());
        }
        data["isDocumentForESignature"] = this.isDocumentForESignature;
        data["comesFromESignatureProvider"] = this.comesFromESignatureProvider;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["policyEnforcedAccessLayers"] = this.policyEnforcedAccessLayers ? this.policyEnforcedAccessLayers.toJSON() : <any>undefined;
        return data;
    }
}

/** Metadata needed to create Document models to fulfill multiple requirements and generate signed Url to upload file. Contains all properties needed to fill the metadata of the document being uploaded. */
export interface ICreateSignedUrlToUploadFileMultipleRequirementsRequest {
    /** Original file name */
    fileName: string;
    /** Entity Id from FenX to link the document with the entity */
    entityId: string;
    /** Journey Id from FenX to link the document with the journey */
    journeyId?: string | undefined;
    /** The type of the document */
    documentType?: string | undefined;
    /** The friendly name of the document */
    friendlyName?: string | undefined;
    /** List of Document Requirements to be fulfilled by this document */
    documentRequirements?: DocumentRequirementDto[] | undefined;
    /** Is the document for eSignature */
    isDocumentForESignature?: boolean | undefined;
    /** Does document come from eSignature provider */
    comesFromESignatureProvider?: boolean | undefined;
    /** Custom document properties. */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Document access layers. Can be only additive in relation to the PolicyEnforcedAccessLayers */
    accessLayers?: AccessLayerDto | undefined;
    /** Access layers enforced by policy. The minimal set of access layers. The property is immutable */
    policyEnforcedAccessLayers?: AccessLayerDto | undefined;
}

export class CreateSignedUrlToUploadFileMultipleRequirementsRequestServiceRequest implements ICreateSignedUrlToUploadFileMultipleRequirementsRequestServiceRequest {
    /** Metadata needed to create Document models to fulfill multiple requirements and generate signed Url to upload file.
Contains all properties needed to fill the metadata of the document being uploaded. */
    data?: CreateSignedUrlToUploadFileMultipleRequirementsRequest | undefined;

    constructor(data?: ICreateSignedUrlToUploadFileMultipleRequirementsRequestServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateSignedUrlToUploadFileMultipleRequirementsRequest.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSignedUrlToUploadFileMultipleRequirementsRequestServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSignedUrlToUploadFileMultipleRequirementsRequestServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateSignedUrlToUploadFileMultipleRequirementsRequestServiceRequest {
    /** Metadata needed to create Document models to fulfill multiple requirements and generate signed Url to upload file.
Contains all properties needed to fill the metadata of the document being uploaded. */
    data?: CreateSignedUrlToUploadFileMultipleRequirementsRequest | undefined;
}

/** Basic information from the upload document api for multiple requirements */
export class CreateSignedUrlToUploadFileMultipleRequirementsResponse implements ICreateSignedUrlToUploadFileMultipleRequirementsResponse {
    /** List of Document Requirement properties that the document Models are linked to */
    documentRequirements?: DocumentRequirementBulkDto[] | undefined;
    /** The type of the document */
    documentType?: string | undefined;
    /** The status of the uploaded document */
    status?: string | undefined;
    /** Url to upload the file into S3 bucket */
    signedUrlToUpload?: string | undefined;

    constructor(data?: ICreateSignedUrlToUploadFileMultipleRequirementsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["DocumentRequirements"])) {
                this.documentRequirements = [] as any;
                for (let item of _data["DocumentRequirements"])
                    this.documentRequirements!.push(DocumentRequirementBulkDto.fromJS(item));
            }
            this.documentType = _data["documentType"];
            this.status = _data["status"];
            this.signedUrlToUpload = _data["signedUrlToUpload"];
        }
    }

    static fromJS(data: any): CreateSignedUrlToUploadFileMultipleRequirementsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSignedUrlToUploadFileMultipleRequirementsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.documentRequirements)) {
            data["DocumentRequirements"] = [];
            for (let item of this.documentRequirements)
                data["DocumentRequirements"].push(item.toJSON());
        }
        data["documentType"] = this.documentType;
        data["status"] = this.status;
        data["signedUrlToUpload"] = this.signedUrlToUpload;
        return data;
    }
}

/** Basic information from the upload document api for multiple requirements */
export interface ICreateSignedUrlToUploadFileMultipleRequirementsResponse {
    /** List of Document Requirement properties that the document Models are linked to */
    documentRequirements?: DocumentRequirementBulkDto[] | undefined;
    /** The type of the document */
    documentType?: string | undefined;
    /** The status of the uploaded document */
    status?: string | undefined;
    /** Url to upload the file into S3 bucket */
    signedUrlToUpload?: string | undefined;
}

export class CreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse implements ICreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse {
    /** Basic information from the upload document api for multiple requirements */
    data?: CreateSignedUrlToUploadFileMultipleRequirementsResponse | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ICreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateSignedUrlToUploadFileMultipleRequirementsResponse.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateSignedUrlToUploadFileMultipleRequirementsResponseServiceResponse {
    /** Basic information from the upload document api for multiple requirements */
    data?: CreateSignedUrlToUploadFileMultipleRequirementsResponse | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Metadata needed to create Document model and generate signed Url to upload file.. Contains all properties needed to fill the metadata of the document being uploaded. */
export class CreateSignedUrlToUploadFileRequest implements ICreateSignedUrlToUploadFileRequest {
    /** Original file name */
    fileName!: string;
    /** Entity Id from FenX to link the document with the entity */
    entityId!: string;
    /** Journey Id from FenX to link the document with the journey */
    journeyId?: string | undefined;
    /** The type of the document */
    documentType?: string | undefined;
    /** The friendly name of the document */
    friendlyName?: string | undefined;
    /** Hash Set of Document Requirement Ids from FenX to link the document to document requirements */
    documentRequirementIds?: string[] | undefined;
    /** The unique identifier of the document requirement that the document is linked to */
    documentDataKey?: string | undefined;
    /** Is the document for eSignature */
    isDocumentForESignature?: boolean | undefined;
    /** Does document come from eSignature provider */
    comesFromESignatureProvider?: boolean | undefined;
    /** Custom document properties. */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Document access layers. Can be only additive in relation to the PolicyEnforcedAccessLayers */
    accessLayers?: AccessLayerDto | undefined;
    /** Access layers enforced by policy. The minimal set of access layers. The property is immutable */
    policyEnforcedAccessLayers?: AccessLayerDto | undefined;

    constructor(data?: ICreateSignedUrlToUploadFileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.entityId = _data["entityId"];
            this.journeyId = _data["journeyId"];
            this.documentType = _data["documentType"];
            this.friendlyName = _data["friendlyName"];
            if (Array.isArray(_data["documentRequirementIds"])) {
                this.documentRequirementIds = [] as any;
                for (let item of _data["documentRequirementIds"])
                    this.documentRequirementIds!.push(item);
            }
            this.documentDataKey = _data["documentDataKey"];
            this.isDocumentForESignature = _data["isDocumentForESignature"];
            this.comesFromESignatureProvider = _data["comesFromESignatureProvider"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.policyEnforcedAccessLayers = _data["policyEnforcedAccessLayers"] ? AccessLayerDto.fromJS(_data["policyEnforcedAccessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSignedUrlToUploadFileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSignedUrlToUploadFileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["entityId"] = this.entityId;
        data["journeyId"] = this.journeyId;
        data["documentType"] = this.documentType;
        data["friendlyName"] = this.friendlyName;
        if (Array.isArray(this.documentRequirementIds)) {
            data["documentRequirementIds"] = [];
            for (let item of this.documentRequirementIds)
                data["documentRequirementIds"].push(item);
        }
        data["documentDataKey"] = this.documentDataKey;
        data["isDocumentForESignature"] = this.isDocumentForESignature;
        data["comesFromESignatureProvider"] = this.comesFromESignatureProvider;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["policyEnforcedAccessLayers"] = this.policyEnforcedAccessLayers ? this.policyEnforcedAccessLayers.toJSON() : <any>undefined;
        return data;
    }
}

/** Metadata needed to create Document model and generate signed Url to upload file.. Contains all properties needed to fill the metadata of the document being uploaded. */
export interface ICreateSignedUrlToUploadFileRequest {
    /** Original file name */
    fileName: string;
    /** Entity Id from FenX to link the document with the entity */
    entityId: string;
    /** Journey Id from FenX to link the document with the journey */
    journeyId?: string | undefined;
    /** The type of the document */
    documentType?: string | undefined;
    /** The friendly name of the document */
    friendlyName?: string | undefined;
    /** Hash Set of Document Requirement Ids from FenX to link the document to document requirements */
    documentRequirementIds?: string[] | undefined;
    /** The unique identifier of the document requirement that the document is linked to */
    documentDataKey?: string | undefined;
    /** Is the document for eSignature */
    isDocumentForESignature?: boolean | undefined;
    /** Does document come from eSignature provider */
    comesFromESignatureProvider?: boolean | undefined;
    /** Custom document properties. */
    properties?: { [key: string]: PropertyDto; } | undefined;
    /** Document access layers. Can be only additive in relation to the PolicyEnforcedAccessLayers */
    accessLayers?: AccessLayerDto | undefined;
    /** Access layers enforced by policy. The minimal set of access layers. The property is immutable */
    policyEnforcedAccessLayers?: AccessLayerDto | undefined;
}

export class CreateSignedUrlToUploadFileRequestServiceRequest implements ICreateSignedUrlToUploadFileRequestServiceRequest {
    /** Metadata needed to create Document model and generate signed Url to upload file..
Contains all properties needed to fill the metadata of the document being uploaded. */
    data?: CreateSignedUrlToUploadFileRequest | undefined;

    constructor(data?: ICreateSignedUrlToUploadFileRequestServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateSignedUrlToUploadFileRequest.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSignedUrlToUploadFileRequestServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSignedUrlToUploadFileRequestServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateSignedUrlToUploadFileRequestServiceRequest {
    /** Metadata needed to create Document model and generate signed Url to upload file..
Contains all properties needed to fill the metadata of the document being uploaded. */
    data?: CreateSignedUrlToUploadFileRequest | undefined;
}

/** Basic information from the upload document api. */
export class CreateSignedUrlToUploadFileResponse implements ICreateSignedUrlToUploadFileResponse {
    /** The unique identifier of the document */
    id?: string;
    /** List of Document Requirement Ids that the document is linked to */
    documentRequirementIds?: string[] | undefined;
    /** The unique identifier of the document requirement that the document is linked to */
    documentDataKey?: string | undefined;
    /** The type of the document */
    documentType?: string | undefined;
    /** The status of the uploaded document */
    status?: string | undefined;
    /** Url to upload the file into S3 bucket */
    signedUrlToUpload?: string | undefined;

    constructor(data?: ICreateSignedUrlToUploadFileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["documentRequirementIds"])) {
                this.documentRequirementIds = [] as any;
                for (let item of _data["documentRequirementIds"])
                    this.documentRequirementIds!.push(item);
            }
            this.documentDataKey = _data["documentDataKey"];
            this.documentType = _data["documentType"];
            this.status = _data["status"];
            this.signedUrlToUpload = _data["signedUrlToUpload"];
        }
    }

    static fromJS(data: any): CreateSignedUrlToUploadFileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSignedUrlToUploadFileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.documentRequirementIds)) {
            data["documentRequirementIds"] = [];
            for (let item of this.documentRequirementIds)
                data["documentRequirementIds"].push(item);
        }
        data["documentDataKey"] = this.documentDataKey;
        data["documentType"] = this.documentType;
        data["status"] = this.status;
        data["signedUrlToUpload"] = this.signedUrlToUpload;
        return data;
    }
}

/** Basic information from the upload document api. */
export interface ICreateSignedUrlToUploadFileResponse {
    /** The unique identifier of the document */
    id?: string;
    /** List of Document Requirement Ids that the document is linked to */
    documentRequirementIds?: string[] | undefined;
    /** The unique identifier of the document requirement that the document is linked to */
    documentDataKey?: string | undefined;
    /** The type of the document */
    documentType?: string | undefined;
    /** The status of the uploaded document */
    status?: string | undefined;
    /** Url to upload the file into S3 bucket */
    signedUrlToUpload?: string | undefined;
}

export class CreateSignedUrlToUploadFileResponseServiceResponse implements ICreateSignedUrlToUploadFileResponseServiceResponse {
    /** Basic information from the upload document api. */
    data?: CreateSignedUrlToUploadFileResponse | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ICreateSignedUrlToUploadFileResponseServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateSignedUrlToUploadFileResponse.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateSignedUrlToUploadFileResponseServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSignedUrlToUploadFileResponseServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateSignedUrlToUploadFileResponseServiceResponse {
    /** Basic information from the upload document api. */
    data?: CreateSignedUrlToUploadFileResponse | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** Contains document requirement attributes set during the bulk upload for multiple requirements */
export class DocumentRequirementBulkDto implements IDocumentRequirementBulkDto {
    /** The Id of the requirement the document requirement belongs to */
    id?: string;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    name?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** Policy set access layers */
    documentAccessLayers?: AccessLayerDto | undefined;
    /** The Id of the document that is satisfying the requirement */
    documentId?: string;

    constructor(data?: IDocumentRequirementBulkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.documentDataKey = _data["DocumentDataKey"];
            this.name = _data["Name"];
            this.isMandatory = _data["IsMandatory"];
            this.documentAccessLayers = _data["DocumentAccessLayers"] ? AccessLayerDto.fromJS(_data["DocumentAccessLayers"]) : <any>undefined;
            this.documentId = _data["DocumentId"];
        }
    }

    static fromJS(data: any): DocumentRequirementBulkDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementBulkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DocumentDataKey"] = this.documentDataKey;
        data["Name"] = this.name;
        data["IsMandatory"] = this.isMandatory;
        data["DocumentAccessLayers"] = this.documentAccessLayers ? this.documentAccessLayers.toJSON() : <any>undefined;
        data["DocumentId"] = this.documentId;
        return data;
    }
}

/** Contains document requirement attributes set during the bulk upload for multiple requirements */
export interface IDocumentRequirementBulkDto {
    /** The Id of the requirement the document requirement belongs to */
    id?: string;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    name?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** Policy set access layers */
    documentAccessLayers?: AccessLayerDto | undefined;
    /** The Id of the document that is satisfying the requirement */
    documentId?: string;
}

/** Contains document requirement attributes need to be deserialized as input of Initialize Lambda */
export class DocumentRequirementDto implements IDocumentRequirementDto {
    /** The Id of the requirement the document requirement belongs to */
    id?: string;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    name?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** Policy set access layers */
    documentAccessLayers?: AccessLayerDto | undefined;

    constructor(data?: IDocumentRequirementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.documentDataKey = _data["DocumentDataKey"];
            this.name = _data["Name"];
            this.isMandatory = _data["IsMandatory"];
            this.documentAccessLayers = _data["DocumentAccessLayers"] ? AccessLayerDto.fromJS(_data["DocumentAccessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentRequirementDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DocumentDataKey"] = this.documentDataKey;
        data["Name"] = this.name;
        data["IsMandatory"] = this.isMandatory;
        data["DocumentAccessLayers"] = this.documentAccessLayers ? this.documentAccessLayers.toJSON() : <any>undefined;
        return data;
    }
}

/** Contains document requirement attributes need to be deserialized as input of Initialize Lambda */
export interface IDocumentRequirementDto {
    /** The Id of the requirement the document requirement belongs to */
    id?: string;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    name?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** Policy set access layers */
    documentAccessLayers?: AccessLayerDto | undefined;
}

/** A document requirement model */
export class DocumentRequirementRequestDto implements IDocumentRequirementRequestDto {
    /** The Id of the requirement the document requirement belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** IsMandatory attribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status is linked to */
    entityId?: string | undefined;
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;
    /** Document requirement access layers. The property is immutable. */
    accessLayers?: AccessLayerDto | undefined;

    constructor(data?: IDocumentRequirementRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requirementId = _data["requirementId"];
            this.requirementName = _data["requirementName"];
            this.documentDataKey = _data["documentDataKey"];
            this.isMandatory = _data["isMandatory"];
            this.journeyId = _data["journeyId"];
            this.entityId = _data["entityId"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.deferUntil = _data["deferUntil"] ? new Date(_data["deferUntil"].toString()) : <any>undefined;
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentRequirementRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requirementId"] = this.requirementId;
        data["requirementName"] = this.requirementName;
        data["documentDataKey"] = this.documentDataKey;
        data["isMandatory"] = this.isMandatory;
        data["journeyId"] = this.journeyId;
        data["entityId"] = this.entityId;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["deferUntil"] = this.deferUntil ? this.deferUntil.toISOString() : <any>undefined;
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        return data;
    }
}

/** A document requirement model */
export interface IDocumentRequirementRequestDto {
    /** The Id of the requirement the document requirement belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** IsMandatory attribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status is linked to */
    entityId?: string | undefined;
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;
    /** Document requirement access layers. The property is immutable. */
    accessLayers?: AccessLayerDto | undefined;
}

export class DocumentRequirementRequestDtoServiceRequest implements IDocumentRequirementRequestDtoServiceRequest {
    /** A document requirement model */
    data?: DocumentRequirementRequestDto | undefined;

    constructor(data?: IDocumentRequirementRequestDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DocumentRequirementRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentRequirementRequestDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementRequestDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDocumentRequirementRequestDtoServiceRequest {
    /** A document requirement model */
    data?: DocumentRequirementRequestDto | undefined;
}

/** A document requirement model */
export class DocumentRequirementResponseDto implements IDocumentRequirementResponseDto {
    /** The Id of the Document Requirement */
    id?: string;
    /** The Id of the requirement the document requirement belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status is linked to */
    entityId?: string | undefined;
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;

    constructor(data?: IDocumentRequirementResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requirementId = _data["requirementId"];
            this.requirementName = _data["requirementName"];
            this.documentDataKey = _data["documentDataKey"];
            this.isMandatory = _data["isMandatory"];
            this.journeyId = _data["journeyId"];
            this.entityId = _data["entityId"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.deferUntil = _data["deferUntil"] ? new Date(_data["deferUntil"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentRequirementResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requirementId"] = this.requirementId;
        data["requirementName"] = this.requirementName;
        data["documentDataKey"] = this.documentDataKey;
        data["isMandatory"] = this.isMandatory;
        data["journeyId"] = this.journeyId;
        data["entityId"] = this.entityId;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["deferUntil"] = this.deferUntil ? this.deferUntil.toISOString() : <any>undefined;
        return data;
    }
}

/** A document requirement model */
export interface IDocumentRequirementResponseDto {
    /** The Id of the Document Requirement */
    id?: string;
    /** The Id of the requirement the document requirement belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status is linked to */
    entityId?: string | undefined;
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;
}

export class DocumentRequirementResponseDtoServiceResponse implements IDocumentRequirementResponseDtoServiceResponse {
    /** A document requirement model */
    data?: DocumentRequirementResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDocumentRequirementResponseDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DocumentRequirementResponseDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentRequirementResponseDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentRequirementResponseDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDocumentRequirementResponseDtoServiceResponse {
    /** A document requirement model */
    data?: DocumentRequirementResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** A document requirement model for external eSignature provider */
export class DocumentSignatureRequestDto implements IDocumentSignatureRequestDto {
    /** The Id of the task */
    taskId?: string;
    /** The Id of the entity */
    entityId?: string;
    /** The Id of the journey */
    journeyId?: string;
    /** The name of entity */
    entityName?: string | undefined;
    /** The name of external provider */
    providerName?: string | undefined;
    /** List of document requirements identifiers which will be send */
    documentRequirementsIds?: string[] | undefined;
    /** List of persons required to sign off */
    signers?: SignerDto[] | undefined;

    constructor(data?: IDocumentSignatureRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.entityId = _data["entityId"];
            this.journeyId = _data["journeyId"];
            this.entityName = _data["entityName"];
            this.providerName = _data["providerName"];
            if (Array.isArray(_data["documentRequirementsIds"])) {
                this.documentRequirementsIds = [] as any;
                for (let item of _data["documentRequirementsIds"])
                    this.documentRequirementsIds!.push(item);
            }
            if (Array.isArray(_data["signers"])) {
                this.signers = [] as any;
                for (let item of _data["signers"])
                    this.signers!.push(SignerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentSignatureRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentSignatureRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["entityId"] = this.entityId;
        data["journeyId"] = this.journeyId;
        data["entityName"] = this.entityName;
        data["providerName"] = this.providerName;
        if (Array.isArray(this.documentRequirementsIds)) {
            data["documentRequirementsIds"] = [];
            for (let item of this.documentRequirementsIds)
                data["documentRequirementsIds"].push(item);
        }
        if (Array.isArray(this.signers)) {
            data["signers"] = [];
            for (let item of this.signers)
                data["signers"].push(item.toJSON());
        }
        return data;
    }
}

/** A document requirement model for external eSignature provider */
export interface IDocumentSignatureRequestDto {
    /** The Id of the task */
    taskId?: string;
    /** The Id of the entity */
    entityId?: string;
    /** The Id of the journey */
    journeyId?: string;
    /** The name of entity */
    entityName?: string | undefined;
    /** The name of external provider */
    providerName?: string | undefined;
    /** List of document requirements identifiers which will be send */
    documentRequirementsIds?: string[] | undefined;
    /** List of persons required to sign off */
    signers?: SignerDto[] | undefined;
}

export class DocumentSignatureRequestDtoServiceRequest implements IDocumentSignatureRequestDtoServiceRequest {
    /** A document requirement model for external eSignature provider */
    data?: DocumentSignatureRequestDto | undefined;

    constructor(data?: IDocumentSignatureRequestDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DocumentSignatureRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentSignatureRequestDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentSignatureRequestDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDocumentSignatureRequestDtoServiceRequest {
    /** A document requirement model for external eSignature provider */
    data?: DocumentSignatureRequestDto | undefined;
}

/** A document requirement model for an external eSignature provider */
export class DocumentSignatureResponseDto implements IDocumentSignatureResponseDto {
    /** EnvelopeId attribute of the eSignature Document Requirement defined by eSignature Service */
    envelopeId?: string | undefined;
    /** The sent date to external eSignature service */
    dateSent?: Date | undefined;

    constructor(data?: IDocumentSignatureResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.envelopeId = _data["envelopeId"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentSignatureResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentSignatureResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["envelopeId"] = this.envelopeId;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        return data;
    }
}

/** A document requirement model for an external eSignature provider */
export interface IDocumentSignatureResponseDto {
    /** EnvelopeId attribute of the eSignature Document Requirement defined by eSignature Service */
    envelopeId?: string | undefined;
    /** The sent date to external eSignature service */
    dateSent?: Date | undefined;
}

export class DocumentSignatureResponseDtoServiceResponse implements IDocumentSignatureResponseDtoServiceResponse {
    /** A document requirement model for an external eSignature provider */
    data?: DocumentSignatureResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IDocumentSignatureResponseDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DocumentSignatureResponseDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentSignatureResponseDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentSignatureResponseDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDocumentSignatureResponseDtoServiceResponse {
    /** A document requirement model for an external eSignature provider */
    data?: DocumentSignatureResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** A document requirement model for external eSignature provider */
export class ESignatureDocumentRequirementRequestDto implements IESignatureDocumentRequirementRequestDto {
    /** The Id of the requirement the document requirement belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** IsMandatory attribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status is linked to */
    entityId?: string | undefined;
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;
    /** Document requirement access layers. The property is immutable. */
    accessLayers?: AccessLayerDto | undefined;
    /** EnvelopeId atttribute of the eSignature document requirement defined by eSignature Service */
    envelopeId?: string | undefined;
    /** The sent date to external eSignature service */
    dateSent?: Date | undefined;
    /** The last notification date from external eSignature service */
    lastNotificationDate?: Date | undefined;
    /** List of persons needed to sign off */
    signers?: SignerDto[] | undefined;

    constructor(data?: IESignatureDocumentRequirementRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requirementId = _data["requirementId"];
            this.requirementName = _data["requirementName"];
            this.documentDataKey = _data["documentDataKey"];
            this.isMandatory = _data["isMandatory"];
            this.journeyId = _data["journeyId"];
            this.entityId = _data["entityId"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.deferUntil = _data["deferUntil"] ? new Date(_data["deferUntil"].toString()) : <any>undefined;
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
            this.envelopeId = _data["envelopeId"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.lastNotificationDate = _data["lastNotificationDate"] ? new Date(_data["lastNotificationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["signers"])) {
                this.signers = [] as any;
                for (let item of _data["signers"])
                    this.signers!.push(SignerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ESignatureDocumentRequirementRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ESignatureDocumentRequirementRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requirementId"] = this.requirementId;
        data["requirementName"] = this.requirementName;
        data["documentDataKey"] = this.documentDataKey;
        data["isMandatory"] = this.isMandatory;
        data["journeyId"] = this.journeyId;
        data["entityId"] = this.entityId;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["deferUntil"] = this.deferUntil ? this.deferUntil.toISOString() : <any>undefined;
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        data["envelopeId"] = this.envelopeId;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["lastNotificationDate"] = this.lastNotificationDate ? this.lastNotificationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.signers)) {
            data["signers"] = [];
            for (let item of this.signers)
                data["signers"].push(item.toJSON());
        }
        return data;
    }
}

/** A document requirement model for external eSignature provider */
export interface IESignatureDocumentRequirementRequestDto {
    /** The Id of the requirement the document requirement belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** IsMandatory attribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status is linked to */
    entityId?: string | undefined;
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;
    /** Document requirement access layers. The property is immutable. */
    accessLayers?: AccessLayerDto | undefined;
    /** EnvelopeId atttribute of the eSignature document requirement defined by eSignature Service */
    envelopeId?: string | undefined;
    /** The sent date to external eSignature service */
    dateSent?: Date | undefined;
    /** The last notification date from external eSignature service */
    lastNotificationDate?: Date | undefined;
    /** List of persons needed to sign off */
    signers?: SignerDto[] | undefined;
}

export class ESignatureDocumentRequirementRequestDtoServiceRequest implements IESignatureDocumentRequirementRequestDtoServiceRequest {
    /** A document requirement model for external eSignature provider */
    data?: ESignatureDocumentRequirementRequestDto | undefined;

    constructor(data?: IESignatureDocumentRequirementRequestDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ESignatureDocumentRequirementRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ESignatureDocumentRequirementRequestDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ESignatureDocumentRequirementRequestDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IESignatureDocumentRequirementRequestDtoServiceRequest {
    /** A document requirement model for external eSignature provider */
    data?: ESignatureDocumentRequirementRequestDto | undefined;
}

/** A document requirement model for an external eSignature provider */
export class ESignatureDocumentRequirementResponseDto implements IESignatureDocumentRequirementResponseDto {
    /** The Id of the Document Requirement */
    id?: string;
    /** The Id of the requirement the document requirement belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status is linked to */
    entityId?: string | undefined;
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;
    /** EnvelopeId atttribute of the eSignature document requirement defined by eSignature Service */
    envelopeId?: string | undefined;
    /** The sent date to external eSignature service */
    dateSent?: Date | undefined;
    /** The last notification date from external eSignature service */
    lastNotificationDate?: Date | undefined;
    /** List of persons needed to sign off */
    signers?: SignerDto[] | undefined;

    constructor(data?: IESignatureDocumentRequirementResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requirementId = _data["requirementId"];
            this.requirementName = _data["requirementName"];
            this.documentDataKey = _data["documentDataKey"];
            this.isMandatory = _data["isMandatory"];
            this.journeyId = _data["journeyId"];
            this.entityId = _data["entityId"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.deferUntil = _data["deferUntil"] ? new Date(_data["deferUntil"].toString()) : <any>undefined;
            this.envelopeId = _data["envelopeId"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.lastNotificationDate = _data["lastNotificationDate"] ? new Date(_data["lastNotificationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["signers"])) {
                this.signers = [] as any;
                for (let item of _data["signers"])
                    this.signers!.push(SignerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ESignatureDocumentRequirementResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ESignatureDocumentRequirementResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requirementId"] = this.requirementId;
        data["requirementName"] = this.requirementName;
        data["documentDataKey"] = this.documentDataKey;
        data["isMandatory"] = this.isMandatory;
        data["journeyId"] = this.journeyId;
        data["entityId"] = this.entityId;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["deferUntil"] = this.deferUntil ? this.deferUntil.toISOString() : <any>undefined;
        data["envelopeId"] = this.envelopeId;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["lastNotificationDate"] = this.lastNotificationDate ? this.lastNotificationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.signers)) {
            data["signers"] = [];
            for (let item of this.signers)
                data["signers"].push(item.toJSON());
        }
        return data;
    }
}

/** A document requirement model for an external eSignature provider */
export interface IESignatureDocumentRequirementResponseDto {
    /** The Id of the Document Requirement */
    id?: string;
    /** The Id of the requirement the document requirement belongs to */
    requirementId?: string | undefined;
    /** The Name of the document requirement defined in policy configuration */
    requirementName?: string | undefined;
    /** The unique identifier of the document requirement defined in policy configuration */
    documentDataKey?: string | undefined;
    /** IsMandatory atttribute of the document requirement defined in policy configuration */
    isMandatory?: boolean;
    /** The Id of the journey the document requirement belongs to */
    journeyId?: string | undefined;
    /** The Id of the entity the document requirement status is linked to */
    entityId?: string | undefined;
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;
    /** EnvelopeId atttribute of the eSignature document requirement defined by eSignature Service */
    envelopeId?: string | undefined;
    /** The sent date to external eSignature service */
    dateSent?: Date | undefined;
    /** The last notification date from external eSignature service */
    lastNotificationDate?: Date | undefined;
    /** List of persons needed to sign off */
    signers?: SignerDto[] | undefined;
}

export class ESignatureDocumentRequirementResponseDtoServiceResponse implements IESignatureDocumentRequirementResponseDtoServiceResponse {
    /** A document requirement model for an external eSignature provider */
    data?: ESignatureDocumentRequirementResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IESignatureDocumentRequirementResponseDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ESignatureDocumentRequirementResponseDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ESignatureDocumentRequirementResponseDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ESignatureDocumentRequirementResponseDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IESignatureDocumentRequirementResponseDtoServiceResponse {
    /** A document requirement model for an external eSignature provider */
    data?: ESignatureDocumentRequirementResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ObjectServiceResponse implements IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IObjectServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IObjectServiceResponse {
    data?: any | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

/** Contains all the attributes needed in order to add custom fields to the document metadata */
export class PropertyDto implements IPropertyDto {
    /** The custom property value */
    value?: string | undefined;
    /** The custom property type */
    type?: string | undefined;
    /** The custom property type identifier */
    customTypeId?: string;
    /** Nested properties that compose our custom property */
    properties?: { [key: string]: PropertyDto; } | undefined;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.customTypeId = _data["customTypeId"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["customTypeId"] = this.customTypeId;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Contains all the attributes needed in order to add custom fields to the document metadata */
export interface IPropertyDto {
    /** The custom property value */
    value?: string | undefined;
    /** The custom property type */
    type?: string | undefined;
    /** The custom property type identifier */
    customTypeId?: string;
    /** Nested properties that compose our custom property */
    properties?: { [key: string]: PropertyDto; } | undefined;
}

/** DTO representing provider configuration */
export class ProviderConfigurationDto implements IProviderConfigurationDto {
    /** Dictionary with provider configuration settings */
    configuration?: { [key: string]: any; } | undefined;

    constructor(data?: IProviderConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProviderConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

/** DTO representing provider configuration */
export interface IProviderConfigurationDto {
    /** Dictionary with provider configuration settings */
    configuration?: { [key: string]: any; } | undefined;
}

export class ProviderConfigurationDtoServiceRequest implements IProviderConfigurationDtoServiceRequest {
    /** DTO representing provider configuration */
    data?: ProviderConfigurationDto | undefined;

    constructor(data?: IProviderConfigurationDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ProviderConfigurationDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProviderConfigurationDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderConfigurationDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProviderConfigurationDtoServiceRequest {
    /** DTO representing provider configuration */
    data?: ProviderConfigurationDto | undefined;
}

/** DTO representing response after saving the provider configuration */
export class SaveProviderConfigurationResponseDto implements ISaveProviderConfigurationResponseDto {
    /** Provider Status */
    status?: string | undefined;
    /** Is Provider Enabled */
    enabled?: boolean;

    constructor(data?: ISaveProviderConfigurationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): SaveProviderConfigurationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveProviderConfigurationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["enabled"] = this.enabled;
        return data;
    }
}

/** DTO representing response after saving the provider configuration */
export interface ISaveProviderConfigurationResponseDto {
    /** Provider Status */
    status?: string | undefined;
    /** Is Provider Enabled */
    enabled?: boolean;
}

export class SaveProviderConfigurationResponseDtoServiceResponse implements ISaveProviderConfigurationResponseDtoServiceResponse {
    /** DTO representing response after saving the provider configuration */
    data?: SaveProviderConfigurationResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: ISaveProviderConfigurationResponseDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SaveProviderConfigurationResponseDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaveProviderConfigurationResponseDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SaveProviderConfigurationResponseDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaveProviderConfigurationResponseDtoServiceResponse {
    /** DTO representing response after saving the provider configuration */
    data?: SaveProviderConfigurationResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ServiceResponse implements IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ServiceResponseMessage implements IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

export interface IServiceResponseMessage {
    message?: string | undefined;
    type?: string | undefined;
}

export class SignerDto implements ISignerDto {
    signerType?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    relationship?: string | undefined;
    hasSigned?: boolean | undefined;
    order?: number;

    constructor(data?: ISignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signerType = _data["signerType"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.relationship = _data["relationship"];
            this.hasSigned = _data["hasSigned"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): SignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signerType"] = this.signerType;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["relationship"] = this.relationship;
        data["hasSigned"] = this.hasSigned;
        data["order"] = this.order;
        return data;
    }
}

export interface ISignerDto {
    signerType?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    relationship?: string | undefined;
    hasSigned?: boolean | undefined;
    order?: number;
}

export class StringServiceResponse implements IStringServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IStringServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StringServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStringServiceResponse {
    data?: string | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class UpdateDocumentAccessLayersDto implements IUpdateDocumentAccessLayersDto {
    /** Document access layers determining the access to the entity draft and related entity */
    accessLayers?: AccessLayerDto | undefined;

    constructor(data?: IUpdateDocumentAccessLayersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessLayers = _data["accessLayers"] ? AccessLayerDto.fromJS(_data["accessLayers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateDocumentAccessLayersDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentAccessLayersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessLayers"] = this.accessLayers ? this.accessLayers.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateDocumentAccessLayersDto {
    /** Document access layers determining the access to the entity draft and related entity */
    accessLayers?: AccessLayerDto | undefined;
}

export class UpdateDocumentAccessLayersDtoServiceRequest implements IUpdateDocumentAccessLayersDtoServiceRequest {
    data?: UpdateDocumentAccessLayersDto | undefined;

    constructor(data?: IUpdateDocumentAccessLayersDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateDocumentAccessLayersDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateDocumentAccessLayersDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentAccessLayersDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateDocumentAccessLayersDtoServiceRequest {
    data?: UpdateDocumentAccessLayersDto | undefined;
}

/** Properties to update the metadata related to an uploaded document */
export class UpdateDocumentDto implements IUpdateDocumentDto {
    /** The type of the document */
    documentType?: string | undefined;
    /** The friendly name of the document */
    friendlyName?: string | undefined;
    /** Hash Set of Document Requirement Ids from FenX to link the document to document requirements */
    documentRequirementIds?: string[] | undefined;
    /** String represented Document DataKey to uniquely identity a document requirement linked with mutiple document models */
    documentDataKey?: string | undefined;
    /** Custom document properties */
    properties?: { [key: string]: PropertyDto; } | undefined;

    constructor(data?: IUpdateDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"];
            this.friendlyName = _data["friendlyName"];
            if (Array.isArray(_data["documentRequirementIds"])) {
                this.documentRequirementIds = [] as any;
                for (let item of _data["documentRequirementIds"])
                    this.documentRequirementIds!.push(item);
            }
            this.documentDataKey = _data["documentDataKey"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? PropertyDto.fromJS(_data["properties"][key]) : new PropertyDto();
                }
            }
        }
    }

    static fromJS(data: any): UpdateDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        data["friendlyName"] = this.friendlyName;
        if (Array.isArray(this.documentRequirementIds)) {
            data["documentRequirementIds"] = [];
            for (let item of this.documentRequirementIds)
                data["documentRequirementIds"].push(item);
        }
        data["documentDataKey"] = this.documentDataKey;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Properties to update the metadata related to an uploaded document */
export interface IUpdateDocumentDto {
    /** The type of the document */
    documentType?: string | undefined;
    /** The friendly name of the document */
    friendlyName?: string | undefined;
    /** Hash Set of Document Requirement Ids from FenX to link the document to document requirements */
    documentRequirementIds?: string[] | undefined;
    /** String represented Document DataKey to uniquely identity a document requirement linked with mutiple document models */
    documentDataKey?: string | undefined;
    /** Custom document properties */
    properties?: { [key: string]: PropertyDto; } | undefined;
}

export class UpdateDocumentDtoServiceRequest implements IUpdateDocumentDtoServiceRequest {
    /** Properties to update the metadata related to an uploaded document */
    data?: UpdateDocumentDto | undefined;

    constructor(data?: IUpdateDocumentDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateDocumentDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateDocumentDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateDocumentDtoServiceRequest {
    /** Properties to update the metadata related to an uploaded document */
    data?: UpdateDocumentDto | undefined;
}

/** Metadata needed to update a file. */
export class UpdateDocumentFileDtoV2 implements IUpdateDocumentFileDtoV2 {
    /** Id of the document */
    id!: string;
    /** Original file name */
    fileName!: string;

    constructor(data?: IUpdateDocumentFileDtoV2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): UpdateDocumentFileDtoV2 {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentFileDtoV2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        return data;
    }
}

/** Metadata needed to update a file. */
export interface IUpdateDocumentFileDtoV2 {
    /** Id of the document */
    id: string;
    /** Original file name */
    fileName: string;
}

export class UpdateDocumentFileDtoV2ServiceRequest implements IUpdateDocumentFileDtoV2ServiceRequest {
    /** Metadata needed to update a file. */
    data?: UpdateDocumentFileDtoV2 | undefined;

    constructor(data?: IUpdateDocumentFileDtoV2ServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateDocumentFileDtoV2.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateDocumentFileDtoV2ServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentFileDtoV2ServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateDocumentFileDtoV2ServiceRequest {
    /** Metadata needed to update a file. */
    data?: UpdateDocumentFileDtoV2 | undefined;
}

/** Basic information from the upload document api. */
export class UpdateDocumentFileResponseDto implements IUpdateDocumentFileResponseDto {
    /** The unique identifier of the document */
    id?: string;
    /** The status of the uploaded document */
    status?: string | undefined;
    /** Url to upload the file into S3 bucket */
    signedUrlToUpload?: string | undefined;

    constructor(data?: IUpdateDocumentFileResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.signedUrlToUpload = _data["signedUrlToUpload"];
        }
    }

    static fromJS(data: any): UpdateDocumentFileResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentFileResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["signedUrlToUpload"] = this.signedUrlToUpload;
        return data;
    }
}

/** Basic information from the upload document api. */
export interface IUpdateDocumentFileResponseDto {
    /** The unique identifier of the document */
    id?: string;
    /** The status of the uploaded document */
    status?: string | undefined;
    /** Url to upload the file into S3 bucket */
    signedUrlToUpload?: string | undefined;
}

export class UpdateDocumentFileResponseDtoServiceResponse implements IUpdateDocumentFileResponseDtoServiceResponse {
    /** Basic information from the upload document api. */
    data?: UpdateDocumentFileResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IUpdateDocumentFileResponseDtoServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateDocumentFileResponseDto.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateDocumentFileResponseDtoServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentFileResponseDtoServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateDocumentFileResponseDtoServiceResponse {
    /** Basic information from the upload document api. */
    data?: UpdateDocumentFileResponseDto | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

/** A document requirement model */
export class UpdateDocumentRequirementDto implements IUpdateDocumentRequirementDto {
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;

    constructor(data?: IUpdateDocumentRequirementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.deferUntil = _data["deferUntil"] ? new Date(_data["deferUntil"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateDocumentRequirementDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentRequirementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["deferUntil"] = this.deferUntil ? this.deferUntil.toISOString() : <any>undefined;
        return data;
    }
}

/** A document requirement model */
export interface IUpdateDocumentRequirementDto {
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;
}

export class UpdateDocumentRequirementDtoServiceRequest implements IUpdateDocumentRequirementDtoServiceRequest {
    /** A document requirement model */
    data?: UpdateDocumentRequirementDto | undefined;

    constructor(data?: IUpdateDocumentRequirementDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateDocumentRequirementDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateDocumentRequirementDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentRequirementDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateDocumentRequirementDtoServiceRequest {
    /** A document requirement model */
    data?: UpdateDocumentRequirementDto | undefined;
}

/** An update document requirement model for external eSignature provider */
export class UpdateESignatureDocumentRequirementDto implements IUpdateESignatureDocumentRequirementDto {
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;
    /** EnvelopeId atttribute of the eSignature document requirement defined by eSignature Service */
    envelopeId?: string | undefined;
    /** The sent date to external eSignature service */
    dateSent?: Date | undefined;
    /** The last notification date from external eSignature service */
    lastNotificationDate?: Date | undefined;
    /** List of persons needed to sign off */
    signers?: SignerDto[] | undefined;
    /** The flag which indicates whether override eSignature properties */
    doNotOverrideESignature?: boolean | undefined;

    constructor(data?: IUpdateESignatureDocumentRequirementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.deferUntil = _data["deferUntil"] ? new Date(_data["deferUntil"].toString()) : <any>undefined;
            this.envelopeId = _data["envelopeId"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.lastNotificationDate = _data["lastNotificationDate"] ? new Date(_data["lastNotificationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["signers"])) {
                this.signers = [] as any;
                for (let item of _data["signers"])
                    this.signers!.push(SignerDto.fromJS(item));
            }
            this.doNotOverrideESignature = _data["doNotOverrideESignature"];
        }
    }

    static fromJS(data: any): UpdateESignatureDocumentRequirementDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateESignatureDocumentRequirementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["deferUntil"] = this.deferUntil ? this.deferUntil.toISOString() : <any>undefined;
        data["envelopeId"] = this.envelopeId;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["lastNotificationDate"] = this.lastNotificationDate ? this.lastNotificationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.signers)) {
            data["signers"] = [];
            for (let item of this.signers)
                data["signers"].push(item.toJSON());
        }
        data["doNotOverrideESignature"] = this.doNotOverrideESignature;
        return data;
    }
}

/** An update document requirement model for external eSignature provider */
export interface IUpdateESignatureDocumentRequirementDto {
    /** The status of the document requirement */
    status?: string | undefined;
    /** A comment relating to the updated status of the document requirement */
    comment?: string | undefined;
    /** The deferral date of the document requirement if Status is set to Deferral Requested */
    deferUntil?: Date | undefined;
    /** EnvelopeId atttribute of the eSignature document requirement defined by eSignature Service */
    envelopeId?: string | undefined;
    /** The sent date to external eSignature service */
    dateSent?: Date | undefined;
    /** The last notification date from external eSignature service */
    lastNotificationDate?: Date | undefined;
    /** List of persons needed to sign off */
    signers?: SignerDto[] | undefined;
    /** The flag which indicates whether override eSignature properties */
    doNotOverrideESignature?: boolean | undefined;
}

export class UpdateESignatureDocumentRequirementDtoServiceRequest implements IUpdateESignatureDocumentRequirementDtoServiceRequest {
    /** An update document requirement model for external eSignature provider */
    data?: UpdateESignatureDocumentRequirementDto | undefined;

    constructor(data?: IUpdateESignatureDocumentRequirementDtoServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateESignatureDocumentRequirementDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateESignatureDocumentRequirementDtoServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateESignatureDocumentRequirementDtoServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateESignatureDocumentRequirementDtoServiceRequest {
    /** An update document requirement model for external eSignature provider */
    data?: UpdateESignatureDocumentRequirementDto | undefined;
}

export class ValidationErrorModel implements IValidationErrorModel {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    errorCode?: string | undefined;

    constructor(data?: IValidationErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            this.attemptedValue = _data["attemptedValue"];
            this.errorCode = _data["errorCode"];
        }
    }

    static fromJS(data: any): ValidationErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["errorCode"] = this.errorCode;
        return data;
    }
}

export interface IValidationErrorModel {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    errorCode?: string | undefined;
}

export class ValidationErrorModelListServiceResponse implements IValidationErrorModelListServiceResponse {
    data?: ValidationErrorModel[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;

    constructor(data?: IValidationErrorModelListServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ValidationErrorModel.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ServiceResponseMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationErrorModelListServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorModelListServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IValidationErrorModelListServiceResponse {
    data?: ValidationErrorModel[] | undefined;
    messages?: ServiceResponseMessage[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}